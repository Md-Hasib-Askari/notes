# 3.3 Advanced GUI Interactions

## Learning Objectives
By the end of this module, you will:
- Master advanced clipboard operations and data exchange
- Implement sophisticated keyboard and mouse simulation
- Perform screen capture and image analysis
- Build comprehensive GUI automation frameworks
- Create OCR-based text extraction systems
- Develop cross-application integration solutions

## Module Overview

Advanced GUI interactions go beyond basic window management to encompass sophisticated automation, data extraction, and cross-application integration. This module covers comprehensive GUI automation techniques using multiple pywin32 modules to create powerful desktop automation solutions.

You'll learn to build intelligent automation systems that can interact with any Windows application, extract data from complex interfaces, and create seamless workflows between different software applications.

## Key Topics Covered

### 1. Advanced Clipboard Operations
### 2. Sophisticated Input Simulation
### 3. Screen Capture and Analysis
### 4. OCR and Text Recognition
### 5. GUI Automation Frameworks
### 6. Cross-Application Integration
### 7. Test Automation and Validation

---

## 1. Advanced Clipboard Operations

### 1.1 Comprehensive Clipboard Management

```python
import win32clipboard
import win32con
import win32gui
import win32api
import time
import io
from PIL import Image, ImageGrab
import json

class AdvancedClipboard:
    """Advanced clipboard operations and data exchange"""
    
    def __init__(self):
        self.clipboard_history = []
        self.max_history = 100
        self.monitoring = False
    
    def open_clipboard(self, retries=3):
        """Safely open clipboard with retry logic"""
        for attempt in range(retries):
            try:
                win32clipboard.OpenClipboard()
                return True
            except Exception as e:
                if attempt == retries - 1:
                    print(f"Failed to open clipboard after {retries} attempts: {e}")
                    return False
                time.sleep(0.1)
        return False
    
    def close_clipboard(self):
        """Safely close clipboard"""
        try:
            win32clipboard.CloseClipboard()
        except Exception as e:
            print(f"Error closing clipboard: {e}")
    
    def get_text(self):
        """Get text from clipboard"""
        try:
            if not self.open_clipboard():
                return None
            
            try:
                data = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
                return data
            except:
                try:
                    data = win32clipboard.GetClipboardData(win32con.CF_TEXT)
                    return data.decode('utf-8')
                except:
                    return None
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error getting text from clipboard: {e}")
            return None
    
    def set_text(self, text):
        """Set text to clipboard"""
        try:
            if not self.open_clipboard():
                return False
            
            try:
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_UNICODETEXT, text)
                return True
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error setting text to clipboard: {e}")
            return False
    
    def get_image(self):
        """Get image from clipboard"""
        try:
            if not self.open_clipboard():
                return None
            
            try:
                # Try to get bitmap data
                if win32clipboard.IsClipboardFormatAvailable(win32con.CF_BITMAP):
                    data = win32clipboard.GetClipboardData(win32con.CF_BITMAP)
                    # Convert to PIL Image
                    img = ImageGrab.grabclipboard()
                    return img
                else:
                    return None
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error getting image from clipboard: {e}")
            return None
    
    def set_image(self, image_path_or_pil):
        """Set image to clipboard"""
        try:
            if isinstance(image_path_or_pil, str):
                # Load image from file path
                img = Image.open(image_path_or_pil)
            else:
                # Assume it's a PIL Image
                img = image_path_or_pil
            
            # Convert to clipboard format
            output = io.BytesIO()
            img.convert('RGB').save(output, 'BMP')
            data = output.getvalue()[14:]  # Remove BMP header
            
            if not self.open_clipboard():
                return False
            
            try:
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_DIB, data)
                return True
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error setting image to clipboard: {e}")
            return False
    
    def get_files(self):
        """Get file list from clipboard"""
        try:
            if not self.open_clipboard():
                return None
            
            try:
                if win32clipboard.IsClipboardFormatAvailable(win32con.CF_HDROP):
                    files = win32clipboard.GetClipboardData(win32con.CF_HDROP)
                    return files
                else:
                    return None
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error getting files from clipboard: {e}")
            return None
    
    def set_files(self, file_list):
        """Set file list to clipboard"""
        try:
            if not self.open_clipboard():
                return False
            
            try:
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_HDROP, file_list)
                return True
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error setting files to clipboard: {e}")
            return False
    
    def get_all_formats(self):
        """Get all available clipboard formats"""
        try:
            if not self.open_clipboard():
                return []
            
            formats = []
            try:
                format_id = 0
                while True:
                    format_id = win32clipboard.EnumClipboardFormats(format_id)
                    if format_id == 0:
                        break
                    
                    try:
                        format_name = win32clipboard.GetClipboardFormatName(format_id)
                    except:
                        format_name = f"Format_{format_id}"
                    
                    formats.append({
                        'id': format_id,
                        'name': format_name
                    })
                
                return formats
            finally:
                self.close_clipboard()
        
        except Exception as e:
            print(f"Error getting clipboard formats: {e}")
            return []
```

### 1.2 Clipboard Monitoring and History

```python
    def start_monitoring(self, callback=None):
        """Start monitoring clipboard changes"""
        try:
            self.monitoring = True
            self.last_content = self.get_text()
            
            import threading
            monitor_thread = threading.Thread(target=self._monitor_clipboard, args=(callback,), daemon=True)
            monitor_thread.start()
            
            print("Clipboard monitoring started")
            return True
        
        except Exception as e:
            print(f"Error starting clipboard monitoring: {e}")
            return False
    
    def stop_monitoring(self):
        """Stop monitoring clipboard changes"""
        self.monitoring = False
        print("Clipboard monitoring stopped")
    
    def _monitor_clipboard(self, callback=None):
        """Monitor clipboard changes in background thread"""
        while self.monitoring:
            try:
                current_content = self.get_text()
                
                if current_content != self.last_content and current_content is not None:
                    # Content changed
                    clipboard_data = {
                        'timestamp': time.time(),
                        'content': current_content,
                        'type': 'text',
                        'formats': self.get_all_formats()
                    }
                    
                    # Add to history
                    self.clipboard_history.append(clipboard_data)
                    if len(self.clipboard_history) > self.max_history:
                        self.clipboard_history.pop(0)
                    
                    # Call callback if provided
                    if callback:
                        try:
                            callback(clipboard_data)
                        except Exception as e:
                            print(f"Error in clipboard callback: {e}")
                    
                    self.last_content = current_content
                
                time.sleep(0.5)  # Check every 500ms
            
            except Exception as e:
                print(f"Error in clipboard monitoring: {e}")
                time.sleep(1)
    
    def get_history(self, count=None):
        """Get clipboard history"""
        if count is None:
            return self.clipboard_history.copy()
        else:
            return self.clipboard_history[-count:] if count <= len(self.clipboard_history) else self.clipboard_history.copy()
    
    def restore_from_history(self, index):
        """Restore clipboard content from history"""
        try:
            if 0 <= index < len(self.clipboard_history):
                item = self.clipboard_history[index]
                if item['type'] == 'text':
                    return self.set_text(item['content'])
            return False
        except Exception as e:
            print(f"Error restoring from history: {e}")
            return False
```

---

## 2. Sophisticated Input Simulation

### 2.1 Advanced Keyboard Simulation

```python
import win32api
import win32con
import time
import random

class AdvancedKeyboard:
    """Advanced keyboard input simulation"""
    
    def __init__(self):
        # Virtual key codes for special keys
        self.vk_codes = {
            'ENTER': 0x0D, 'TAB': 0x09, 'SPACE': 0x20, 'ESC': 0x1B,
            'SHIFT': 0x10, 'CTRL': 0x11, 'ALT': 0x12, 'WIN': 0x5B,
            'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73,
            'F5': 0x74, 'F6': 0x75, 'F7': 0x76, 'F8': 0x77,
            'F9': 0x78, 'F10': 0x79, 'F11': 0x7A, 'F12': 0x7B,
            'UP': 0x26, 'DOWN': 0x28, 'LEFT': 0x25, 'RIGHT': 0x27,
            'HOME': 0x24, 'END': 0x23, 'PGUP': 0x21, 'PGDN': 0x22,
            'INSERT': 0x2D, 'DELETE': 0x2E, 'BACKSPACE': 0x08,
            'CAPSLOCK': 0x14, 'NUMLOCK': 0x90, 'SCROLLLOCK': 0x91
        }
        
        self.typing_speed = 0.05  # Delay between keystrokes
        self.human_variance = True  # Add human-like variance
    
    def press_key(self, key, duration=0.1):
        """Press and release a key"""
        try:
            if isinstance(key, str):
                if key.upper() in self.vk_codes:
                    vk_code = self.vk_codes[key.upper()]
                else:
                    vk_code = ord(key.upper())
            else:
                vk_code = key
            
            # Press key
            win32api.keybd_event(vk_code, 0, 0, 0)
            time.sleep(duration)
            
            # Release key
            win32api.keybd_event(vk_code, 0, win32con.KEYEVENTF_KEYUP, 0)
            
            return True
        
        except Exception as e:
            print(f"Error pressing key: {e}")
            return False
    
    def hold_key(self, key):
        """Hold a key down (remember to release it)"""
        try:
            if isinstance(key, str):
                if key.upper() in self.vk_codes:
                    vk_code = self.vk_codes[key.upper()]
                else:
                    vk_code = ord(key.upper())
            else:
                vk_code = key
            
            win32api.keybd_event(vk_code, 0, 0, 0)
            return True
        
        except Exception as e:
            print(f"Error holding key: {e}")
            return False
    
    def release_key(self, key):
        """Release a held key"""
        try:
            if isinstance(key, str):
                if key.upper() in self.vk_codes:
                    vk_code = self.vk_codes[key.upper()]
                else:
                    vk_code = ord(key.upper())
            else:
                vk_code = key
            
            win32api.keybd_event(vk_code, 0, win32con.KEYEVENTF_KEYUP, 0)
            return True
        
        except Exception as e:
            print(f"Error releasing key: {e}")
            return False
    
    def key_combination(self, *keys):
        """Press a combination of keys (e.g., Ctrl+C)"""
        try:
            # Press all keys
            vk_codes = []
            for key in keys:
                if isinstance(key, str):
                    if key.upper() in self.vk_codes:
                        vk_code = self.vk_codes[key.upper()]
                    else:
                        vk_code = ord(key.upper())
                else:
                    vk_code = key
                
                vk_codes.append(vk_code)
                win32api.keybd_event(vk_code, 0, 0, 0)
            
            time.sleep(0.1)
            
            # Release all keys in reverse order
            for vk_code in reversed(vk_codes):
                win32api.keybd_event(vk_code, 0, win32con.KEYEVENTF_KEYUP, 0)
            
            return True
        
        except Exception as e:
            print(f"Error with key combination: {e}")
            return False
    
    def type_text(self, text, delay=None):
        """Type text with realistic timing"""
        try:
            if delay is None:
                delay = self.typing_speed
            
            for char in text:
                if char == '\n':
                    self.press_key('ENTER')
                elif char == '\t':
                    self.press_key('TAB')
                else:
                    self.press_key(char)
                
                # Add human-like variance
                if self.human_variance:
                    variance = random.uniform(0.5, 1.5)
                    time.sleep(delay * variance)
                else:
                    time.sleep(delay)
            
            return True
        
        except Exception as e:
            print(f"Error typing text: {e}")
            return False
    
    def type_with_corrections(self, text, error_rate=0.05):
        """Type text with realistic errors and corrections"""
        try:
            for i, char in enumerate(text):
                # Simulate typing errors
                if random.random() < error_rate:
                    # Type wrong character
                    wrong_chars = 'abcdefghijklmnopqrstuvwxyz'
                    wrong_char = random.choice(wrong_chars)
                    self.press_key(wrong_char)
                    time.sleep(self.typing_speed)
                    
                    # Correct the error
                    self.press_key('BACKSPACE')
                    time.sleep(self.typing_speed * 0.5)
                
                # Type correct character
                self.press_key(char)
                
                # Variable delay
                if self.human_variance:
                    delay = self.typing_speed * random.uniform(0.5, 2.0)
                    time.sleep(delay)
                else:
                    time.sleep(self.typing_speed)
            
            return True
        
        except Exception as e:
            print(f"Error typing with corrections: {e}")
            return False
```

### 2.2 Advanced Mouse Simulation

```python
class AdvancedMouse:
    """Advanced mouse input simulation"""
    
    def __init__(self):
        self.movement_speed = 0.01  # Delay between movement steps
        self.smooth_movement = True
        self.current_pos = win32gui.GetCursorPos()
    
    def get_position(self):
        """Get current mouse position"""
        try:
            pos = win32gui.GetCursorPos()
            self.current_pos = pos
            return pos
        except Exception as e:
            print(f"Error getting mouse position: {e}")
            return None
    
    def move_to(self, x, y, smooth=None):
        """Move mouse to specific coordinates"""
        try:
            if smooth is None:
                smooth = self.smooth_movement
            
            if smooth:
                return self._smooth_move_to(x, y)
            else:
                win32api.SetCursorPos((int(x), int(y)))
                self.current_pos = (x, y)
                return True
        
        except Exception as e:
            print(f"Error moving mouse: {e}")
            return False
    
    def _smooth_move_to(self, target_x, target_y):
        """Move mouse smoothly to target position"""
        try:
            start_x, start_y = self.get_position()
            
            # Calculate distance and steps
            distance = ((target_x - start_x) ** 2 + (target_y - start_y) ** 2) ** 0.5
            steps = max(int(distance / 5), 10)  # At least 10 steps
            
            # Calculate increments
            dx = (target_x - start_x) / steps
            dy = (target_y - start_y) / steps
            
            # Move in steps
            for step in range(steps):
                current_x = start_x + (dx * step)
                current_y = start_y + (dy * step)
                
                win32api.SetCursorPos((int(current_x), int(current_y)))
                time.sleep(self.movement_speed)
            
            # Ensure we end exactly at target
            win32api.SetCursorPos((int(target_x), int(target_y)))
            self.current_pos = (target_x, target_y)
            
            return True
        
        except Exception as e:
            print(f"Error in smooth movement: {e}")
            return False
    
    def click(self, x=None, y=None, button='left', clicks=1, delay=0.1):
        """Click at specified position"""
        try:
            # Move to position if specified
            if x is not None and y is not None:
                self.move_to(x, y)
            
            # Determine button constants
            if button.lower() == 'left':
                down_flag = win32con.MOUSEEVENTF_LEFTDOWN
                up_flag = win32con.MOUSEEVENTF_LEFTUP
            elif button.lower() == 'right':
                down_flag = win32con.MOUSEEVENTF_RIGHTDOWN
                up_flag = win32con.MOUSEEVENTF_RIGHTUP
            elif button.lower() == 'middle':
                down_flag = win32con.MOUSEEVENTF_MIDDLEDOWN
                up_flag = win32con.MOUSEEVENTF_MIDDLEUP
            else:
                raise ValueError(f"Unknown button: {button}")
            
            # Perform clicks
            for _ in range(clicks):
                win32api.mouse_event(down_flag, 0, 0, 0, 0)
                time.sleep(0.05)
                win32api.mouse_event(up_flag, 0, 0, 0, 0)
                
                if clicks > 1:
                    time.sleep(delay)
            
            return True
        
        except Exception as e:
            print(f"Error clicking: {e}")
            return False
    
    def drag(self, start_x, start_y, end_x, end_y, button='left', duration=1.0):
        """Drag from start to end position"""
        try:
            # Move to start position
            self.move_to(start_x, start_y)
            time.sleep(0.1)
            
            # Determine button constants
            if button.lower() == 'left':
                down_flag = win32con.MOUSEEVENTF_LEFTDOWN
                up_flag = win32con.MOUSEEVENTF_LEFTUP
            elif button.lower() == 'right':
                down_flag = win32con.MOUSEEVENTF_RIGHTDOWN
                up_flag = win32con.MOUSEEVENTF_RIGHTUP
            else:
                raise ValueError(f"Unknown button: {button}")
            
            # Press button down
            win32api.mouse_event(down_flag, 0, 0, 0, 0)
            time.sleep(0.1)
            
            # Calculate movement steps
            distance = ((end_x - start_x) ** 2 + (end_y - start_y) ** 2) ** 0.5
            steps = max(int(distance / 3), 20)  # Smooth drag
            
            step_delay = duration / steps
            dx = (end_x - start_x) / steps
            dy = (end_y - start_y) / steps
            
            # Drag to end position
            for step in range(steps):
                current_x = start_x + (dx * step)
                current_y = start_y + (dy * step)
                
                win32api.SetCursorPos((int(current_x), int(current_y)))
                time.sleep(step_delay)
            
            # Ensure we end at exact position
            win32api.SetCursorPos((int(end_x), int(end_y)))
            
            # Release button
            time.sleep(0.1)
            win32api.mouse_event(up_flag, 0, 0, 0, 0)
            
            return True
        
        except Exception as e:
            print(f"Error dragging: {e}")
            return False
    
    def scroll(self, x, y, direction='up', clicks=3):
        """Scroll at specified position"""
        try:
            # Move to position
            self.move_to(x, y)
            time.sleep(0.1)
            
            # Determine scroll direction
            if direction.lower() == 'up':
                wheel_delta = 120
            elif direction.lower() == 'down':
                wheel_delta = -120
            else:
                raise ValueError(f"Unknown scroll direction: {direction}")
            
            # Perform scroll
            for _ in range(clicks):
                win32api.mouse_event(
                    win32con.MOUSEEVENTF_WHEEL,
                    0, 0, wheel_delta, 0
                )
                time.sleep(0.1)
            
            return True
        
        except Exception as e:
            print(f"Error scrolling: {e}")
            return False
```

---

## 3. Screen Capture and Analysis

### 3.1 Advanced Screen Capture

```python
import win32gui
import win32ui
import win32con
import win32api
from PIL import Image
import numpy as np
import cv2

class ScreenCapture:
    """Advanced screen capture and analysis"""
    
    def __init__(self):
        self.monitors = self._get_monitors()
    
    def _get_monitors(self):
        """Get information about all monitors"""
        monitors = []
        
        def monitor_enum_proc(hMonitor, hdcMonitor, lprcMonitor, dwData):
            monitor_info = win32api.GetMonitorInfo(hMonitor)
            monitors.append({
                'handle': hMonitor,
                'device': monitor_info['Device'],
                'work_area': monitor_info['Work'],
                'monitor_area': monitor_info['Monitor'],
                'is_primary': bool(monitor_info['Flags'] & win32con.MONITORINFOF_PRIMARY)
            })
            return True
        
        win32api.EnumDisplayMonitors(None, None, monitor_enum_proc, None)
        return monitors
    
    def capture_screen(self, region=None, monitor=0):
        """Capture screen or specific region"""
        try:
            if region is None:
                # Capture entire monitor
                if monitor < len(self.monitors):
                    monitor_rect = self.monitors[monitor]['monitor_area']
                    left, top, right, bottom = monitor_rect
                    width = right - left
                    height = bottom - top
                else:
                    # Default to primary monitor
                    left, top = 0, 0
                    width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
                    height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)
            else:
                # Capture specific region
                left, top, width, height = region
            
            # Get device contexts
            hdesktop = win32gui.GetDesktopWindow()
            hdc = win32gui.GetWindowDC(hdesktop)
            mdc = win32ui.CreateDCFromHandle(hdc)
            mem_dc = mdc.CreateCompatibleDC()
            
            # Create bitmap
            screenshot = win32ui.CreateBitmap()
            screenshot.CreateCompatibleBitmap(mdc, width, height)
            mem_dc.SelectObject(screenshot)
            
            # Copy screen to bitmap
            mem_dc.BitBlt((0, 0), (width, height), mdc, (left, top), win32con.SRCCOPY)
            
            # Convert to PIL Image
            bmpinfo = screenshot.GetInfo()
            bmpstr = screenshot.GetBitmapBits(True)
            
            img = Image.frombuffer(
                'RGB',
                (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
                bmpstr, 'raw', 'BGRX', 0, 1
            )
            
            # Cleanup
            mem_dc.DeleteDC()
            mdc.DeleteDC()
            win32gui.ReleaseDC(hdesktop, hdc)
            win32gui.DeleteObject(screenshot.GetHandle())
            
            return img
        
        except Exception as e:
            print(f"Error capturing screen: {e}")
            return None
    
    def capture_window(self, hwnd):
        """Capture specific window"""
        try:
            # Get window rectangle
            rect = win32gui.GetWindowRect(hwnd)
            left, top, right, bottom = rect
            width = right - left
            height = bottom - top
            
            # Capture window region
            return self.capture_screen((left, top, width, height))
        
        except Exception as e:
            print(f"Error capturing window: {e}")
            return None
    
    def find_image_on_screen(self, template_path, threshold=0.8, region=None):
        """Find image template on screen"""
        try:
            # Capture screen
            screenshot = self.capture_screen(region)
            if screenshot is None:
                return None
            
            # Load template
            template = Image.open(template_path)
            
            # Convert to OpenCV format
            screenshot_cv = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
            template_cv = cv2.cvtColor(np.array(template), cv2.COLOR_RGB2BGR)
            
            # Template matching
            result = cv2.matchTemplate(screenshot_cv, template_cv, cv2.TM_CCOEFF_NORMED)
            locations = np.where(result >= threshold)
            
            # Return all matches
            matches = []
            for pt in zip(*locations[::-1]):
                x, y = pt
                w, h = template.size
                confidence = result[y, x]
                
                matches.append({
                    'x': x,
                    'y': y,
                    'width': w,
                    'height': h,
                    'confidence': confidence,
                    'center': (x + w // 2, y + h // 2)
                })
            
            # Sort by confidence
            matches.sort(key=lambda m: m['confidence'], reverse=True)
            
            return matches
        
        except Exception as e:
            print(f"Error finding image on screen: {e}")
            return []
    
    def wait_for_image(self, template_path, timeout=30, check_interval=1, threshold=0.8):
        """Wait for image to appear on screen"""
        try:
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                matches = self.find_image_on_screen(template_path, threshold)
                if matches:
                    return matches[0]  # Return best match
                
                time.sleep(check_interval)
            
            return None
        
        except Exception as e:
            print(f"Error waiting for image: {e}")
            return None
    
    def compare_images(self, img1_path, img2_path):
        """Compare two images for similarity"""
        try:
            # Load images
            img1 = cv2.imread(img1_path)
            img2 = cv2.imread(img2_path)
            
            # Resize to same dimensions if needed
            if img1.shape != img2.shape:
                img2 = cv2.resize(img2, (img1.shape[1], img1.shape[0]))
            
            # Calculate similarity using SSIM
            from skimage.metrics import structural_similarity as ssim
            
            # Convert to grayscale
            gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
            gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
            
            # Calculate SSIM
            similarity = ssim(gray1, gray2)
            
            return similarity
        
        except Exception as e:
            print(f"Error comparing images: {e}")
            return 0.0
```

### 3.2 Color and Pixel Analysis

```python
    def get_pixel_color(self, x, y):
        """Get color of pixel at specified coordinates"""
        try:
            hdc = win32gui.GetDC(0)
            color = win32gui.GetPixel(hdc, x, y)
            win32gui.ReleaseDC(0, hdc)
            
            # Convert to RGB
            r = color & 0xFF
            g = (color >> 8) & 0xFF
            b = (color >> 16) & 0xFF
            
            return (r, g, b)
        
        except Exception as e:
            print(f"Error getting pixel color: {e}")
            return None
    
    def find_color_on_screen(self, target_color, tolerance=10, region=None):
        """Find locations of specific color on screen"""
        try:
            # Capture screen
            screenshot = self.capture_screen(region)
            if screenshot is None:
                return []
            
            # Convert to numpy array
            img_array = np.array(screenshot)
            
            # Define color range with tolerance
            target_r, target_g, target_b = target_color
            lower_bound = np.array([max(0, target_r - tolerance),
                                   max(0, target_g - tolerance),
                                   max(0, target_b - tolerance)])
            upper_bound = np.array([min(255, target_r + tolerance),
                                   min(255, target_g + tolerance),
                                   min(255, target_b + tolerance)])
            
            # Find pixels within color range
            mask = cv2.inRange(img_array, lower_bound, upper_bound)
            locations = np.where(mask == 255)
            
            # Convert to coordinate list
            coordinates = list(zip(locations[1], locations[0]))  # (x, y) format
            
            return coordinates
        
        except Exception as e:
            print(f"Error finding color on screen: {e}")
            return []
    
    def analyze_region_colors(self, region):
        """Analyze color distribution in a region"""
        try:
            # Capture region
            screenshot = self.capture_screen(region)
            if screenshot is None:
                return None
            
            # Convert to numpy array
            img_array = np.array(screenshot)
            
            # Calculate color statistics
            analysis = {
                'mean_color': np.mean(img_array, axis=(0, 1)).astype(int),
                'dominant_colors': [],
                'color_variance': np.var(img_array, axis=(0, 1)),
                'brightness': np.mean(cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY))
            }
            
            # Find dominant colors using K-means
            from sklearn.cluster import KMeans
            
            # Reshape for clustering
            pixels = img_array.reshape(-1, 3)
            
            # Perform K-means clustering
            kmeans = KMeans(n_clusters=5, random_state=42)
            kmeans.fit(pixels)
            
            # Get dominant colors
            for i, color in enumerate(kmeans.cluster_centers_):
                analysis['dominant_colors'].append({
                    'color': color.astype(int).tolist(),
                    'percentage': np.sum(kmeans.labels_ == i) / len(pixels) * 100
                })
            
            # Sort by percentage
            analysis['dominant_colors'].sort(key=lambda x: x['percentage'], reverse=True)
            
            return analysis
        
        except Exception as e:
            print(f"Error analyzing region colors: {e}")
            return None
```

---

## 4. OCR and Text Recognition

### 4.1 Text Recognition System

```python
import pytesseract
from PIL import ImageEnhance, ImageFilter
import re

class OCRSystem:
    """Optical Character Recognition system"""
    
    def __init__(self, tesseract_path=None):
        if tesseract_path:
            pytesseract.pytesseract.tesseract_cmd = tesseract_path
        
        self.screen_capture = ScreenCapture()
    
    def preprocess_image(self, image, enhance=True):
        """Preprocess image for better OCR results"""
        try:
            # Convert to grayscale
            if image.mode != 'L':
                image = image.convert('L')
            
            if enhance:
                # Enhance contrast
                enhancer = ImageEnhance.Contrast(image)
                image = enhancer.enhance(2.0)
                
                # Enhance sharpness
                enhancer = ImageEnhance.Sharpness(image)
                image = enhancer.enhance(2.0)
                
                # Apply filter to reduce noise
                image = image.filter(ImageFilter.MedianFilter())
            
            return image
        
        except Exception as e:
            print(f"Error preprocessing image: {e}")
            return image
    
    def extract_text_from_image(self, image, lang='eng', config=''):
        """Extract text from image using OCR"""
        try:
            # Preprocess image
            processed_image = self.preprocess_image(image)
            
            # Extract text
            text = pytesseract.image_to_string(
                processed_image,
                lang=lang,
                config=config
            )
            
            return text.strip()
        
        except Exception as e:
            print(f"Error extracting text from image: {e}")
            return ""
    
    def extract_text_from_screen(self, region=None, lang='eng', config=''):
        """Extract text from screen region"""
        try:
            # Capture screen
            screenshot = self.screen_capture.capture_screen(region)
            if screenshot is None:
                return ""
            
            # Extract text
            return self.extract_text_from_image(screenshot, lang, config)
        
        except Exception as e:
            print(f"Error extracting text from screen: {e}")
            return ""
    
    def extract_text_from_window(self, hwnd, lang='eng', config=''):
        """Extract text from specific window"""
        try:
            # Capture window
            screenshot = self.screen_capture.capture_window(hwnd)
            if screenshot is None:
                return ""
            
            # Extract text
            return self.extract_text_from_image(screenshot, lang, config)
        
        except Exception as e:
            print(f"Error extracting text from window: {e}")
            return ""
    
    def find_text_on_screen(self, search_text, region=None, case_sensitive=False):
        """Find specific text on screen and return its location"""
        try:
            # Get text with bounding boxes
            screenshot = self.screen_capture.capture_screen(region)
            if screenshot is None:
                return []
            
            processed_image = self.preprocess_image(screenshot)
            
            # Get detailed OCR data
            data = pytesseract.image_to_data(
                processed_image,
                output_type=pytesseract.Output.DICT
            )
            
            matches = []
            search_lower = search_text.lower() if not case_sensitive else search_text
            
            # Look through OCR results
            for i in range(len(data['text'])):
                text = data['text'][i].strip()
                if not text:
                    continue
                
                text_compare = text.lower() if not case_sensitive else text
                
                if search_lower in text_compare:
                    x = data['left'][i]
                    y = data['top'][i]
                    w = data['width'][i]
                    h = data['height'][i]
                    confidence = data['conf'][i]
                    
                    if region:
                        # Adjust coordinates for region offset
                        x += region[0]
                        y += region[1]
                    
                    matches.append({
                        'text': text,
                        'x': x,
                        'y': y,
                        'width': w,
                        'height': h,
                        'center': (x + w // 2, y + h // 2),
                        'confidence': confidence
                    })
            
            return matches
        
        except Exception as e:
            print(f"Error finding text on screen: {e}")
            return []
    
    def extract_structured_data(self, image, data_patterns):
        """Extract structured data using patterns"""
        try:
            # Extract all text
            text = self.extract_text_from_image(image)
            
            extracted_data = {}
            
            # Apply each pattern
            for pattern_name, pattern_config in data_patterns.items():
                regex_pattern = pattern_config['pattern']
                data_type = pattern_config.get('type', 'string')
                
                matches = re.findall(regex_pattern, text, re.IGNORECASE)
                
                if matches:
                    if data_type == 'list':
                        extracted_data[pattern_name] = matches
                    elif data_type == 'first':
                        extracted_data[pattern_name] = matches[0] if matches else None
                    elif data_type == 'number':
                        try:
                            extracted_data[pattern_name] = float(matches[0]) if matches else None
                        except ValueError:
                            extracted_data[pattern_name] = None
                    else:
                        extracted_data[pattern_name] = matches
                else:
                    extracted_data[pattern_name] = None
            
            return extracted_data
        
        except Exception as e:
            print(f"Error extracting structured data: {e}")
            return {}
    
    def monitor_text_changes(self, region, callback, check_interval=1):
        """Monitor region for text changes"""
        try:
            last_text = ""
            
            while True:
                current_text = self.extract_text_from_screen(region)
                
                if current_text != last_text:
                    if callback:
                        callback({
                            'old_text': last_text,
                            'new_text': current_text,
                            'timestamp': time.time(),
                            'region': region
                        })
                    
                    last_text = current_text
                
                time.sleep(check_interval)
        
        except Exception as e:
            print(f"Error monitoring text changes: {e}")
```

---

## 5. GUI Automation Frameworks

### 5.1 Application Controller

```python
class ApplicationController:
    """High-level application control framework"""
    
    def __init__(self, app_name):
        self.app_name = app_name
        self.window_handle = None
        self.keyboard = AdvancedKeyboard()
        self.mouse = AdvancedMouse()
        self.clipboard = AdvancedClipboard()
        self.screen = ScreenCapture()
        self.ocr = OCRSystem()
        
        self.elements = {}  # Cache for UI elements
        self.timeouts = {
            'default': 30,
            'short': 5,
            'long': 60
        }
    
    def connect(self, window_title=None, class_name=None, process_name=None):
        """Connect to application window"""
        try:
            if window_title:
                handles = self._find_windows_by_title(window_title)
            elif class_name:
                handle = win32gui.FindWindow(class_name, None)
                handles = [handle] if handle else []
            elif process_name:
                handles = self._find_windows_by_process(process_name)
            else:
                raise ValueError("Must specify window_title, class_name, or process_name")
            
            if handles:
                self.window_handle = handles[0]
                print(f"Connected to {self.app_name} (Handle: {self.window_handle})")
                return True
            else:
                print(f"Could not find {self.app_name} window")
                return False
        
        except Exception as e:
            print(f"Error connecting to application: {e}")
            return False
    
    def _find_windows_by_title(self, title):
        """Find windows by title"""
        windows = []
        
        def callback(hwnd, results):
            window_title = win32gui.GetWindowText(hwnd)
            if title.lower() in window_title.lower():
                results.append(hwnd)
            return True
        
        win32gui.EnumWindows(callback, windows)
        return windows
    
    def _find_windows_by_process(self, process_name):
        """Find windows by process name"""
        windows = []
        
        def callback(hwnd, results):
            try:
                _, pid = win32process.GetWindowThreadProcessId(hwnd)
                handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION, False, pid)
                exe_name = win32process.GetModuleFileNameEx(handle, 0)
                win32api.CloseHandle(handle)
                
                if process_name.lower() in exe_name.lower():
                    results.append(hwnd)
            except:
                pass
            return True
        
        win32gui.EnumWindows(callback, windows)
        return windows
    
    def wait_for_element(self, element_type, identifier, timeout=None):
        """Wait for UI element to appear"""
        if timeout is None:
            timeout = self.timeouts['default']
        
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            element = self.find_element(element_type, identifier)
            if element:
                return element
            
            time.sleep(0.5)
        
        return None
    
    def find_element(self, element_type, identifier):
        """Find UI element by type and identifier"""
        try:
            if element_type == 'image':
                # Find by image template
                region = self._get_window_region()
                matches = self.screen.find_image_on_screen(identifier, region=region)
                return matches[0] if matches else None
            
            elif element_type == 'text':
                # Find by text content
                region = self._get_window_region()
                matches = self.ocr.find_text_on_screen(identifier, region=region)
                return matches[0] if matches else None
            
            elif element_type == 'control':
                # Find by control class/text
                if isinstance(identifier, dict):
                    class_name = identifier.get('class')
                    text = identifier.get('text', '')
                    
                    controls = []
                    
                    def callback(hwnd, results):
                        if win32gui.GetClassName(hwnd) == class_name:
                            if not text or win32gui.GetWindowText(hwnd) == text:
                                rect = win32gui.GetWindowRect(hwnd)
                                results.append({
                                    'handle': hwnd,
                                    'x': rect[0],
                                    'y': rect[1],
                                    'width': rect[2] - rect[0],
                                    'height': rect[3] - rect[1],
                                    'center': ((rect[0] + rect[2]) // 2, (rect[1] + rect[3]) // 2)
                                })
                        return True
                    
                    win32gui.EnumChildWindows(self.window_handle, callback, controls)
                    return controls[0] if controls else None
            
            return None
        
        except Exception as e:
            print(f"Error finding element: {e}")
            return None
    
    def click_element(self, element):
        """Click on UI element"""
        try:
            if 'center' in element:
                x, y = element['center']
            else:
                x = element['x'] + element['width'] // 2
                y = element['y'] + element['height'] // 2
            
            return self.mouse.click(x, y)
        
        except Exception as e:
            print(f"Error clicking element: {e}")
            return False
    
    def type_in_element(self, element, text):
        """Type text in UI element"""
        try:
            # Click element first to focus
            self.click_element(element)
            time.sleep(0.2)
            
            # Clear existing text
            self.keyboard.key_combination('CTRL', 'A')
            time.sleep(0.1)
            
            # Type new text
            return self.keyboard.type_text(text)
        
        except Exception as e:
            print(f"Error typing in element: {e}")
            return False
    
    def _get_window_region(self):
        """Get window region for screenshots"""
        try:
            if self.window_handle:
                rect = win32gui.GetWindowRect(self.window_handle)
                left, top, right, bottom = rect
                return (left, top, right - left, bottom - top)
            else:
                return None
        except Exception as e:
            print(f"Error getting window region: {e}")
            return None
    
    def take_screenshot(self, save_path=None):
        """Take screenshot of application window"""
        try:
            screenshot = self.screen.capture_window(self.window_handle)
            
            if save_path and screenshot:
                screenshot.save(save_path)
            
            return screenshot
        
        except Exception as e:
            print(f"Error taking screenshot: {e}")
            return None
```

### 5.2 Workflow Automation

```python
class WorkflowAutomation:
    """Workflow automation framework"""
    
    def __init__(self):
        self.steps = []
        self.variables = {}
        self.error_handlers = {}
        self.retry_settings = {
            'default_retries': 3,
            'retry_delay': 1.0
        }
    
    def add_step(self, name, action, **kwargs):
        """Add step to workflow"""
        step = {
            'name': name,
            'action': action,
            'params': kwargs,
            'retries': kwargs.get('retries', self.retry_settings['default_retries']),
            'timeout': kwargs.get('timeout', 30),
            'on_error': kwargs.get('on_error', 'stop'),
            'condition': kwargs.get('condition', None)
        }
        
        self.steps.append(step)
    
    def set_variable(self, name, value):
        """Set workflow variable"""
        self.variables[name] = value
    
    def get_variable(self, name, default=None):
        """Get workflow variable"""
        return self.variables.get(name, default)
    
    def add_error_handler(self, error_type, handler_func):
        """Add error handler for specific error types"""
        self.error_handlers[error_type] = handler_func
    
    def execute_workflow(self, start_step=0):
        """Execute workflow from specified step"""
        try:
            current_step = start_step
            
            while current_step < len(self.steps):
                step = self.steps[current_step]
                
                print(f"Executing step {current_step + 1}: {step['name']}")
                
                # Check condition if specified
                if step['condition']:
                    if not self._evaluate_condition(step['condition']):
                        print(f"Skipping step {step['name']} - condition not met")
                        current_step += 1
                        continue
                
                # Execute step with retries
                success = self._execute_step_with_retries(step)
                
                if success:
                    current_step += 1
                else:
                    # Handle error based on on_error setting
                    if step['on_error'] == 'stop':
                        print(f"Workflow stopped at step: {step['name']}")
                        return False
                    elif step['on_error'] == 'continue':
                        print(f"Continuing after error in step: {step['name']}")
                        current_step += 1
                    elif step['on_error'] == 'retry':
                        print(f"Retrying step: {step['name']}")
                        # Step will be retried by retry mechanism
                        current_step += 1
                    elif isinstance(step['on_error'], int):
                        # Jump to specific step
                        current_step = step['on_error']
            
            print("Workflow completed successfully")
            return True
        
        except Exception as e:
            print(f"Fatal error in workflow execution: {e}")
            return False
    
    def _execute_step_with_retries(self, step):
        """Execute single step with retry logic"""
        retries = step['retries']
        
        for attempt in range(retries + 1):
            try:
                if attempt > 0:
                    print(f"Retry attempt {attempt} for step: {step['name']}")
                    time.sleep(self.retry_settings['retry_delay'])
                
                # Execute the action
                result = self._execute_action(step['action'], step['params'])
                
                if result:
                    return True
            
            except Exception as e:
                print(f"Error in step {step['name']}, attempt {attempt + 1}: {e}")
                
                # Try error handler if available
                error_type = type(e).__name__
                if error_type in self.error_handlers:
                    try:
                        self.error_handlers[error_type](e, step)
                    except Exception as handler_error:
                        print(f"Error handler failed: {handler_error}")
        
        return False
    
    def _execute_action(self, action, params):
        """Execute a single action"""
        try:
            if callable(action):
                # Direct function call
                return action(**params)
            elif isinstance(action, str):
                # String-based action
                if action == 'click':
                    element = params['element']
                    controller = params['controller']
                    return controller.click_element(element)
                elif action == 'type':
                    element = params['element']
                    text = params['text']
                    controller = params['controller']
                    return controller.type_in_element(element, text)
                elif action == 'wait':
                    duration = params.get('duration', 1)
                    time.sleep(duration)
                    return True
                elif action == 'screenshot':
                    controller = params['controller']
                    path = params.get('path')
                    return controller.take_screenshot(path) is not None
                else:
                    print(f"Unknown action: {action}")
                    return False
            else:
                print(f"Invalid action type: {type(action)}")
                return False
        
        except Exception as e:
            print(f"Error executing action {action}: {e}")
            return False
    
    def _evaluate_condition(self, condition):
        """Evaluate workflow condition"""
        try:
            if callable(condition):
                return condition(self.variables)
            elif isinstance(condition, str):
                # Simple variable check
                return self.variables.get(condition, False)
            elif isinstance(condition, dict):
                # Complex condition
                var_name = condition.get('variable')
                operator = condition.get('operator', '==')
                value = condition.get('value')
                
                var_value = self.variables.get(var_name)
                
                if operator == '==':
                    return var_value == value
                elif operator == '!=':
                    return var_value != value
                elif operator == '>':
                    return var_value > value
                elif operator == '<':
                    return var_value < value
                elif operator == 'in':
                    return var_value in value
                elif operator == 'exists':
                    return var_name in self.variables
                else:
                    return False
            else:
                return bool(condition)
        
        except Exception as e:
            print(f"Error evaluating condition: {e}")
            return False
```

---

## 6. Practical Exercises

### Exercise 1: Advanced Data Entry Automation
Create a sophisticated data entry automation system.

```python
# Your implementation here
def create_data_entry_bot(data_source, target_application):
    """
    Data entry automation:
    - Read data from various sources (Excel, CSV, database)
    - Intelligent field mapping
    - Error detection and correction
    - Progress tracking and reporting
    """
    pass
```

### Exercise 2: Screen Monitoring System
Build a comprehensive screen monitoring and alert system.

```python
# Your implementation here
def create_screen_monitor(watch_regions, alert_conditions):
    """
    Screen monitoring features:
    - Multi-region monitoring
    - Image and text-based alerts
    - Change detection and logging
    - Automated response actions
    """
    pass
```

### Exercise 3: Cross-Application Workflow
Create a workflow that integrates multiple applications.

```python
# Your implementation here
def create_multi_app_workflow(workflow_definition):
    """
    Multi-application workflow:
    - Data extraction from one app
    - Processing and transformation
    - Data input to another app
    - Error handling and validation
    """
    pass
```

### Exercise 4: GUI Test Automation Framework
Build a comprehensive GUI testing framework.

```python
# Your implementation here
def create_gui_test_framework(test_cases):
    """
    GUI testing framework:
    - Test case execution
    - Screenshot comparison
    - Performance measurements
    - Automated reporting
    """
    pass
```

---

## Best Practices

### 1. Robust Element Detection
```python
def find_element_with_fallbacks(primary_method, fallback_methods):
    """Try multiple methods to find UI elements"""
    try:
        element = primary_method()
        if element:
            return element
    except:
        pass
    
    for fallback in fallback_methods:
        try:
            element = fallback()
            if element:
                return element
        except:
            continue
    
    return None
```

### 2. Intelligent Waiting
```python
def smart_wait(condition_func, timeout=30, poll_interval=0.5):
    """Wait intelligently for conditions"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        if condition_func():
            return True
        
        # Adaptive polling - slower as time progresses
        time.sleep(min(poll_interval * 2, 2.0))
        poll_interval *= 1.1
    
    return False
```

### 3. Error Recovery
```python
def with_error_recovery(func, recovery_actions):
    """Execute function with automatic error recovery"""
    try:
        return func()
    except Exception as e:
        for recovery in recovery_actions:
            try:
                recovery()
                return func()  # Retry after recovery
            except:
                continue
        raise e  # Re-raise if all recovery attempts failed
```

---

## Common Pitfalls and Solutions

### 1. Timing Issues
**Problem**: GUI elements not ready when accessed.
**Solution**: Implement intelligent waiting with multiple detection methods.

### 2. Resolution Dependencies
**Problem**: Automation breaks on different screen resolutions.
**Solution**: Use relative positioning and adaptive scaling.

### 3. Application State Management
**Problem**: Applications change state unexpectedly.
**Solution**: Implement state verification and recovery mechanisms.

### 4. Performance Degradation
**Problem**: Automation becomes slow over time.
**Solution**: Optimize image processing and implement caching strategies.

---

## Capstone Project: GUI Automation Framework

### Project Overview
Build a comprehensive GUI automation framework that demonstrates all advanced interaction techniques.

### Core Features
1. **Multi-Application Support**: Framework that works with any Windows application
2. **Intelligent Element Detection**: Multiple detection methods with fallbacks
3. **Visual Workflow Designer**: Drag-and-drop workflow creation
4. **OCR Integration**: Text-based automation and verification
5. **Error Recovery**: Automatic error detection and recovery
6. **Performance Monitoring**: Execution metrics and optimization

### Technical Requirements

```python
class GUIAutomationFramework:
    """Complete GUI automation solution"""
    
    def __init__(self):
        self.applications = {}
        self.workflows = {}
        self.element_library = {}
        self.execution_engine = WorkflowAutomation()
    
    def register_application(self, name, config):
        """Register application with automation framework"""
        # Implementation required
        pass
    
    def create_workflow(self, name, steps):
        """Create automation workflow"""
        # Implementation required
        pass
    
    def execute_workflow(self, name, parameters=None):
        """Execute automation workflow"""
        # Implementation required
        pass
    
    def create_web_interface(self):
        """Create web-based management interface"""
        # Implementation required
        pass

# Implementation guidelines:
# 1. Plugin architecture for application-specific modules
# 2. Configuration-driven element definitions
# 3. Visual workflow designer using web technologies
# 4. Comprehensive logging and debugging tools
# 5. Performance optimization and resource management
```

### Project Deliverables
1. Complete automation framework with all components
2. Visual workflow designer interface
3. Application plugin examples
4. Documentation and tutorials
5. Performance analysis and benchmark results

---

## Summary

Advanced GUI interactions enable sophisticated automation and integration solutions. Key takeaways:

1. **Clipboard Mastery**: Advanced data exchange and monitoring capabilities
2. **Input Simulation**: Realistic keyboard and mouse automation
3. **Screen Analysis**: Comprehensive capture and image analysis
4. **OCR Integration**: Text recognition and extraction systems
5. **Framework Design**: Reusable automation frameworks
6. **Workflow Automation**: Complex multi-step process automation
7. **Error Handling**: Robust error recovery and state management

These skills enable you to build professional-grade automation solutions that can handle complex GUI interactions and create seamless integration between different applications.

**Next Steps**: Continue to [3.4 Security and Permissions](./3.4%20Security%20and%20Permissions.md) to learn Windows security programming and access control management.
