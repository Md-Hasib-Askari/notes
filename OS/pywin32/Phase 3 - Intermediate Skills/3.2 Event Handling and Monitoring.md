# 3.2 Event Handling and Monitoring

## Learning Objectives
By the end of this module, you will:
- Master Windows Event Log programming with `win32evtlog`
- Implement file system monitoring and change detection
- Integrate with WMI (Windows Management Instrumentation) for system monitoring
- Build real-time event processing systems
- Create comprehensive monitoring dashboards
- Design event-driven architectures and alerting systems

## Module Overview

Event handling and monitoring are fundamental aspects of Windows system administration and automation. This module covers the comprehensive use of Windows event systems, from reading and writing event logs to implementing real-time file system monitoring and WMI-based system surveillance.

You'll learn to build sophisticated monitoring solutions that can track system changes, detect security events, monitor application behavior, and automatically respond to critical conditions.

## Key Topics Covered

### 1. Windows Event Log Programming
### 2. File System Monitoring
### 3. WMI Integration and System Monitoring
### 4. Real-time Event Processing
### 5. Alert Systems and Notifications
### 6. Performance Monitoring
### 7. Custom Event Sources and Logging

---

## 1. Windows Event Log Programming

### 1.1 Basic Event Log Operations

```python
import win32evtlog
import win32evtlogutil
import win32api
import win32con
import winerror
import time
from datetime import datetime, timedelta

class WindowsEventLogger:
    """Comprehensive Windows Event Log management"""
    
    def __init__(self, server=None):
        self.server = server  # None for local machine
        self.event_logs = ['System', 'Application', 'Security']
    
    def get_available_logs(self):
        """Get list of available event logs"""
        try:
            logs = []
            key = win32api.RegOpenKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Services\EventLog"
            )
            
            index = 0
            while True:
                try:
                    log_name = win32api.RegEnumKey(key, index)
                    logs.append(log_name)
                    index += 1
                except win32api.error:
                    break
            
            win32api.RegCloseKey(key)
            return logs
        
        except Exception as e:
            print(f"Error getting available logs: {e}")
            return []
    
    def read_event_log(self, log_name, max_records=100, event_types=None):
        """Read events from specified log"""
        try:
            hand = win32evtlog.OpenEventLog(self.server, log_name)
            flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
            
            if event_types is None:
                event_types = [
                    win32evtlog.EVENTLOG_ERROR_TYPE,
                    win32evtlog.EVENTLOG_WARNING_TYPE,
                    win32evtlog.EVENTLOG_INFORMATION_TYPE
                ]
            
            events = []
            records_read = 0
            
            while records_read < max_records:
                events_batch = win32evtlog.ReadEventLog(hand, flags, 0)
                if not events_batch:
                    break
                
                for event in events_batch:
                    if event.EventType in event_types:
                        event_info = {
                            'time_generated': event.TimeGenerated,
                            'time_written': event.TimeWritten,
                            'event_id': event.EventID,
                            'event_type': self._get_event_type_string(event.EventType),
                            'source_name': event.SourceName,
                            'computer_name': event.ComputerName,
                            'user_sid': event.Sid,
                            'event_category': event.EventCategory,
                            'data': event.Data,
                            'string_inserts': event.StringInserts
                        }
                        
                        # Get event description
                        try:
                            event_info['description'] = win32evtlogutil.SafeFormatMessage(event, log_name)
                        except:
                            event_info['description'] = "Unable to format message"
                        
                        events.append(event_info)
                        records_read += 1
                        
                        if records_read >= max_records:
                            break
            
            win32evtlog.CloseEventLog(hand)
            return events
        
        except Exception as e:
            print(f"Error reading event log {log_name}: {e}")
            return []
    
    def _get_event_type_string(self, event_type):
        """Convert event type to string"""
        type_map = {
            win32evtlog.EVENTLOG_ERROR_TYPE: "Error",
            win32evtlog.EVENTLOG_WARNING_TYPE: "Warning",
            win32evtlog.EVENTLOG_INFORMATION_TYPE: "Information",
            win32evtlog.EVENTLOG_AUDIT_SUCCESS: "Audit Success",
            win32evtlog.EVENTLOG_AUDIT_FAILURE: "Audit Failure"
        }
        return type_map.get(event_type, "Unknown")
```

### 1.2 Event Log Filtering and Searching

```python
    def filter_events_by_time(self, log_name, start_time, end_time=None, event_types=None):
        """Filter events by time range"""
        try:
            if end_time is None:
                end_time = datetime.now()
            
            events = self.read_event_log(log_name, max_records=10000, event_types=event_types)
            filtered_events = []
            
            for event in events:
                event_time = event['time_generated']
                if start_time <= event_time <= end_time:
                    filtered_events.append(event)
            
            return filtered_events
        
        except Exception as e:
            print(f"Error filtering events: {e}")
            return []
    
    def search_events(self, log_name, search_criteria, max_records=1000):
        """Search events based on criteria"""
        try:
            events = self.read_event_log(log_name, max_records=max_records)
            matching_events = []
            
            for event in events:
                # Check if event matches search criteria
                match = True
                
                if 'event_id' in search_criteria:
                    if event['event_id'] != search_criteria['event_id']:
                        match = False
                
                if 'source_name' in search_criteria:
                    if search_criteria['source_name'].lower() not in event['source_name'].lower():
                        match = False
                
                if 'event_type' in search_criteria:
                    if event['event_type'] != search_criteria['event_type']:
                        match = False
                
                if 'description_contains' in search_criteria:
                    if search_criteria['description_contains'].lower() not in event['description'].lower():
                        match = False
                
                if match:
                    matching_events.append(event)
            
            return matching_events
        
        except Exception as e:
            print(f"Error searching events: {e}")
            return []
    
    def get_event_statistics(self, log_name, hours_back=24):
        """Get statistics for events in the specified time period"""
        try:
            start_time = datetime.now() - timedelta(hours=hours_back)
            events = self.filter_events_by_time(log_name, start_time)
            
            stats = {
                'total_events': len(events),
                'error_count': 0,
                'warning_count': 0,
                'information_count': 0,
                'source_breakdown': {},
                'hourly_distribution': {}
            }
            
            for event in events:
                # Count by type
                event_type = event['event_type']
                if event_type == 'Error':
                    stats['error_count'] += 1
                elif event_type == 'Warning':
                    stats['warning_count'] += 1
                elif event_type == 'Information':
                    stats['information_count'] += 1
                
                # Count by source
                source = event['source_name']
                stats['source_breakdown'][source] = stats['source_breakdown'].get(source, 0) + 1
                
                # Count by hour
                hour = event['time_generated'].strftime('%Y-%m-%d %H:00')
                stats['hourly_distribution'][hour] = stats['hourly_distribution'].get(hour, 0) + 1
            
            return stats
        
        except Exception as e:
            print(f"Error getting statistics: {e}")
            return {}
```

### 1.3 Writing Custom Events

```python
class CustomEventLogger:
    """Create and write custom events to Windows Event Log"""
    
    def __init__(self, source_name, log_name="Application"):
        self.source_name = source_name
        self.log_name = log_name
        self.register_event_source()
    
    def register_event_source(self):
        """Register custom event source"""
        try:
            # Check if source already exists
            try:
                win32evtlogutil.AddSourceToRegistry(
                    self.source_name,
                    self.log_name,
                    "C:\\Windows\\System32\\kernel32.dll"  # Default message DLL
                )
                print(f"Event source '{self.source_name}' registered successfully")
            except Exception as e:
                if "already exists" not in str(e):
                    print(f"Warning: Could not register event source: {e}")
        
        except Exception as e:
            print(f"Error registering event source: {e}")
    
    def write_event(self, event_id, event_type, message, event_category=0, raw_data=None):
        """Write custom event to log"""
        try:
            # Event type mapping
            type_map = {
                'information': win32evtlog.EVENTLOG_INFORMATION_TYPE,
                'warning': win32evtlog.EVENTLOG_WARNING_TYPE,
                'error': win32evtlog.EVENTLOG_ERROR_TYPE,
                'success': win32evtlog.EVENTLOG_AUDIT_SUCCESS,
                'failure': win32evtlog.EVENTLOG_AUDIT_FAILURE
            }
            
            event_type_value = type_map.get(event_type.lower(), win32evtlog.EVENTLOG_INFORMATION_TYPE)
            
            win32evtlogutil.ReportEvent(
                self.source_name,
                event_id,
                eventCategory=event_category,
                eventType=event_type_value,
                strings=[message],
                data=raw_data
            )
            
            print(f"Event written: ID={event_id}, Type={event_type}, Message={message}")
            return True
        
        except Exception as e:
            print(f"Error writing event: {e}")
            return False
    
    def write_info(self, event_id, message):
        """Write information event"""
        return self.write_event(event_id, 'information', message)
    
    def write_warning(self, event_id, message):
        """Write warning event"""
        return self.write_event(event_id, 'warning', message)
    
    def write_error(self, event_id, message):
        """Write error event"""
        return self.write_event(event_id, 'error', message)

# Usage example
logger = CustomEventLogger("MyApplication")
logger.write_info(1001, "Application started successfully")
logger.write_warning(2001, "Configuration file not found, using defaults")
logger.write_error(3001, "Database connection failed")
```

---

## 2. File System Monitoring

### 2.1 Directory Change Monitoring

```python
import win32file
import win32con
import threading
import queue
import os
from pathlib import Path

class FileSystemMonitor:
    """Monitor file system changes in real-time"""
    
    def __init__(self):
        self.monitors = {}
        self.running = False
        self.event_queue = queue.Queue()
        
        # File change types
        self.change_types = {
            win32file.FILE_ACTION_ADDED: "Added",
            win32file.FILE_ACTION_REMOVED: "Removed",
            win32file.FILE_ACTION_MODIFIED: "Modified",
            win32file.FILE_ACTION_RENAMED_OLD_NAME: "Renamed (Old)",
            win32file.FILE_ACTION_RENAMED_NEW_NAME: "Renamed (New)"
        }
    
    def add_watch(self, path, recursive=True, filters=None):
        """Add directory to watch list"""
        try:
            if not os.path.exists(path):
                raise ValueError(f"Path does not exist: {path}")
            
            # Default filters - watch for file and directory changes
            if filters is None:
                filters = (
                    win32con.FILE_NOTIFY_CHANGE_FILE_NAME |
                    win32con.FILE_NOTIFY_CHANGE_DIR_NAME |
                    win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |
                    win32con.FILE_NOTIFY_CHANGE_SIZE |
                    win32con.FILE_NOTIFY_CHANGE_LAST_WRITE |
                    win32con.FILE_NOTIFY_CHANGE_CREATION
                )
            
            # Open directory handle for monitoring
            handle = win32file.CreateFile(
                path,
                win32file.GENERIC_READ,
                win32file.FILE_SHARE_READ | win32file.FILE_SHARE_WRITE | win32file.FILE_SHARE_DELETE,
                None,
                win32file.OPEN_EXISTING,
                win32file.FILE_FLAG_BACKUP_SEMANTICS,
                None
            )
            
            self.monitors[path] = {
                'handle': handle,
                'recursive': recursive,
                'filters': filters,
                'thread': None
            }
            
            print(f"Added watch for: {path}")
            return True
        
        except Exception as e:
            print(f"Error adding watch for {path}: {e}")
            return False
    
    def start_monitoring(self):
        """Start monitoring all watched directories"""
        try:
            self.running = True
            
            for path, monitor_info in self.monitors.items():
                thread = threading.Thread(
                    target=self._monitor_directory,
                    args=(path, monitor_info),
                    daemon=True
                )
                monitor_info['thread'] = thread
                thread.start()
            
            print(f"Started monitoring {len(self.monitors)} directories")
            return True
        
        except Exception as e:
            print(f"Error starting monitoring: {e}")
            return False
    
    def _monitor_directory(self, path, monitor_info):
        """Monitor a single directory for changes"""
        try:
            handle = monitor_info['handle']
            recursive = monitor_info['recursive']
            filters = monitor_info['filters']
            
            while self.running:
                try:
                    # Wait for changes
                    changes = win32file.ReadDirectoryChangesW(
                        handle,
                        8192,  # Buffer size
                        recursive,
                        filters,
                        None,
                        None
                    )
                    
                    # Process changes
                    for change in changes:
                        action, filename = change
                        change_type = self.change_types.get(action, "Unknown")
                        
                        event = {
                            'timestamp': datetime.now(),
                            'path': path,
                            'filename': filename,
                            'action': change_type,
                            'full_path': os.path.join(path, filename)
                        }
                        
                        self.event_queue.put(event)
                
                except Exception as e:
                    if self.running:  # Only log errors if we're still supposed to be running
                        print(f"Error monitoring {path}: {e}")
                    break
        
        except Exception as e:
            print(f"Fatal error in monitor thread for {path}: {e}")
    
    def get_events(self, timeout=1):
        """Get pending file system events"""
        events = []
        try:
            while True:
                event = self.event_queue.get(timeout=timeout)
                events.append(event)
        except queue.Empty:
            pass
        
        return events
    
    def stop_monitoring(self):
        """Stop monitoring all directories"""
        try:
            self.running = False
            
            # Close all handles
            for path, monitor_info in self.monitors.items():
                try:
                    win32file.CloseHandle(monitor_info['handle'])
                except:
                    pass
            
            print("Monitoring stopped")
        
        except Exception as e:
            print(f"Error stopping monitoring: {e}")
```

### 2.2 Advanced File System Monitoring

```python
class AdvancedFileSystemMonitor(FileSystemMonitor):
    """Extended file system monitor with filtering and analysis"""
    
    def __init__(self):
        super().__init__()
        self.file_filters = []
        self.callbacks = []
        self.statistics = {
            'total_events': 0,
            'events_by_type': {},
            'events_by_extension': {},
            'large_files': [],
            'suspicious_activity': []
        }
    
    def add_file_filter(self, extension=None, size_limit=None, name_pattern=None):
        """Add file filter criteria"""
        filter_criteria = {
            'extension': extension,
            'size_limit': size_limit,
            'name_pattern': name_pattern
        }
        self.file_filters.append(filter_criteria)
    
    def add_callback(self, callback_func):
        """Add callback function for events"""
        self.callbacks.append(callback_func)
    
    def process_event(self, event):
        """Process and analyze file system event"""
        try:
            # Update statistics
            self.statistics['total_events'] += 1
            
            action = event['action']
            self.statistics['events_by_type'][action] = \
                self.statistics['events_by_type'].get(action, 0) + 1
            
            # Analyze file
            full_path = event['full_path']
            if os.path.exists(full_path) and os.path.isfile(full_path):
                try:
                    file_size = os.path.getsize(full_path)
                    file_ext = os.path.splitext(full_path)[1].lower()
                    
                    # Track by extension
                    self.statistics['events_by_extension'][file_ext] = \
                        self.statistics['events_by_extension'].get(file_ext, 0) + 1
                    
                    # Check for large files
                    if file_size > 100 * 1024 * 1024:  # 100MB
                        self.statistics['large_files'].append({
                            'path': full_path,
                            'size': file_size,
                            'timestamp': event['timestamp']
                        })
                    
                    # Check for suspicious activity
                    if self._is_suspicious_activity(event, file_size, file_ext):
                        self.statistics['suspicious_activity'].append(event)
                
                except OSError:
                    pass  # File may have been deleted already
            
            # Apply filters
            if self._passes_filters(event):
                # Call registered callbacks
                for callback in self.callbacks:
                    try:
                        callback(event)
                    except Exception as e:
                        print(f"Error in callback: {e}")
            
            return True
        
        except Exception as e:
            print(f"Error processing event: {e}")
            return False
    
    def _is_suspicious_activity(self, event, file_size, file_ext):
        """Detect potentially suspicious file activity"""
        suspicious_indicators = [
            # Large executable files
            file_ext in ['.exe', '.dll', '.bat', '.cmd', '.ps1'] and file_size > 10 * 1024 * 1024,
            
            # Files in system directories
            any(sys_dir in event['full_path'].lower() for sys_dir in [
                'system32', 'syswow64', 'windows\\system'
            ]),
            
            # Suspicious extensions
            file_ext in ['.scr', '.pif', '.com', '.vbs', '.js'],
            
            # Rapid file creation/deletion
            event['action'] in ['Added', 'Removed']
        ]
        
        return any(suspicious_indicators)
    
    def _passes_filters(self, event):
        """Check if event passes all filters"""
        if not self.file_filters:
            return True
        
        for filter_criteria in self.file_filters:
            if self._matches_filter(event, filter_criteria):
                return True
        
        return False
    
    def _matches_filter(self, event, filter_criteria):
        """Check if event matches specific filter"""
        try:
            full_path = event['full_path']
            
            # Extension filter
            if filter_criteria['extension']:
                file_ext = os.path.splitext(full_path)[1].lower()
                if file_ext != filter_criteria['extension'].lower():
                    return False
            
            # Size filter
            if filter_criteria['size_limit'] and os.path.exists(full_path):
                try:
                    file_size = os.path.getsize(full_path)
                    if file_size > filter_criteria['size_limit']:
                        return False
                except OSError:
                    pass
            
            # Name pattern filter
            if filter_criteria['name_pattern']:
                import re
                if not re.search(filter_criteria['name_pattern'], event['filename']):
                    return False
            
            return True
        
        except Exception as e:
            print(f"Error in filter matching: {e}")
            return False
```

---

## 3. WMI Integration and System Monitoring

### 3.1 WMI Event Monitoring

```python
import wmi
import pythoncom
import threading
import time

class WMIMonitor:
    """Monitor system events using Windows Management Instrumentation"""
    
    def __init__(self):
        self.wmi_connection = None
        self.watchers = []
        self.running = False
        self.initialize_wmi()
    
    def initialize_wmi(self):
        """Initialize WMI connection"""
        try:
            pythoncom.CoInitialize()  # Initialize COM for this thread
            self.wmi_connection = wmi.WMI()
            print("WMI initialized successfully")
        except Exception as e:
            print(f"Failed to initialize WMI: {e}")
            raise
    
    def monitor_process_events(self, callback=None):
        """Monitor process creation and deletion events"""
        try:
            def process_created_callback(event):
                if event is None:
                    return
                
                process_info = {
                    'event_type': 'ProcessCreated',
                    'timestamp': datetime.now(),
                    'process_id': event.ProcessId,
                    'process_name': event.ProcessName,
                    'command_line': getattr(event, 'CommandLine', ''),
                    'parent_process_id': getattr(event, 'ParentProcessId', 0),
                    'user': getattr(event, 'UserName', 'Unknown')
                }
                
                if callback:
                    callback(process_info)
                else:
                    print(f"Process Created: {process_info}")
            
            def process_deleted_callback(event):
                if event is None:
                    return
                
                process_info = {
                    'event_type': 'ProcessDeleted',
                    'timestamp': datetime.now(),
                    'process_id': event.ProcessId,
                    'process_name': event.ProcessName,
                    'exit_status': getattr(event, 'ExitStatus', 0)
                }
                
                if callback:
                    callback(process_info)
                else:
                    print(f"Process Deleted: {process_info}")
            
            # Start process creation watcher
            creation_watcher = self.wmi_connection.Win32_ProcessStartTrace.watch_for(
                notification_type="Creation",
                delay_secs=1
            )
            
            # Start process deletion watcher
            deletion_watcher = self.wmi_connection.Win32_ProcessStopTrace.watch_for(
                notification_type="Deletion",
                delay_secs=1
            )
            
            # Start monitoring threads
            creation_thread = threading.Thread(
                target=self._monitor_wmi_events,
                args=(creation_watcher, process_created_callback),
                daemon=True
            )
            
            deletion_thread = threading.Thread(
                target=self._monitor_wmi_events,
                args=(deletion_watcher, process_deleted_callback),
                daemon=True
            )
            
            creation_thread.start()
            deletion_thread.start()
            
            self.watchers.extend([creation_watcher, deletion_watcher])
            print("Process monitoring started")
            
        except Exception as e:
            print(f"Error starting process monitoring: {e}")
    
    def monitor_service_events(self, callback=None):
        """Monitor Windows service state changes"""
        try:
            def service_callback(event):
                if event is None:
                    return
                
                service_info = {
                    'event_type': 'ServiceStateChange',
                    'timestamp': datetime.now(),
                    'service_name': event.Name,
                    'display_name': getattr(event, 'DisplayName', ''),
                    'state': event.State,
                    'status': getattr(event, 'Status', ''),
                    'start_mode': getattr(event, 'StartMode', '')
                }
                
                if callback:
                    callback(service_info)
                else:
                    print(f"Service State Change: {service_info}")
            
            # Monitor service state changes
            service_watcher = self.wmi_connection.Win32_Service.watch_for(
                notification_type="modification",
                delay_secs=2
            )
            
            service_thread = threading.Thread(
                target=self._monitor_wmi_events,
                args=(service_watcher, service_callback),
                daemon=True
            )
            
            service_thread.start()
            self.watchers.append(service_watcher)
            print("Service monitoring started")
            
        except Exception as e:
            print(f"Error starting service monitoring: {e}")
    
    def monitor_logon_events(self, callback=None):
        """Monitor user logon events"""
        try:
            def logon_callback(event):
                if event is None:
                    return
                
                logon_info = {
                    'event_type': 'UserLogon',
                    'timestamp': datetime.now(),
                    'logon_id': getattr(event, 'LogonId', ''),
                    'logon_type': getattr(event, 'LogonType', ''),
                    'user_name': getattr(event, 'UserName', ''),
                    'domain': getattr(event, 'Domain', ''),
                    'authentication_package': getattr(event, 'AuthenticationPackage', '')
                }
                
                if callback:
                    callback(logon_info)
                else:
                    print(f"User Logon: {logon_info}")
            
            # Monitor logon events
            logon_watcher = self.wmi_connection.Win32_LogonSession.watch_for(
                notification_type="creation",
                delay_secs=1
            )
            
            logon_thread = threading.Thread(
                target=self._monitor_wmi_events,
                args=(logon_watcher, logon_callback),
                daemon=True
            )
            
            logon_thread.start()
            self.watchers.append(logon_watcher)
            print("Logon monitoring started")
            
        except Exception as e:
            print(f"Error starting logon monitoring: {e}")
    
    def _monitor_wmi_events(self, watcher, callback):
        """Generic WMI event monitoring thread"""
        try:
            pythoncom.CoInitialize()  # Initialize COM for this thread
            
            while self.running:
                try:
                    event = watcher(timeout_ms=1000)  # 1 second timeout
                    if event:
                        callback(event)
                except wmi.x_wmi_timed_out:
                    continue  # Timeout is normal, continue monitoring
                except Exception as e:
                    print(f"Error in WMI monitoring: {e}")
                    break
        
        except Exception as e:
            print(f"Fatal error in WMI monitoring thread: {e}")
        finally:
            pythoncom.CoUninitialize()
    
    def start_monitoring(self):
        """Start all WMI monitoring"""
        self.running = True
        print("WMI monitoring started")
    
    def stop_monitoring(self):
        """Stop all WMI monitoring"""
        self.running = False
        print("WMI monitoring stopped")
```

### 3.2 System Performance Monitoring

```python
class SystemPerformanceMonitor:
    """Monitor system performance metrics using WMI"""
    
    def __init__(self):
        self.wmi_connection = wmi.WMI()
        self.performance_data = {
            'cpu_usage': [],
            'memory_usage': [],
            'disk_usage': [],
            'network_usage': []
        }
    
    def get_cpu_usage(self):
        """Get current CPU usage percentage"""
        try:
            cpu_usage = self.wmi_connection.Win32_Processor()[0].LoadPercentage
            self.performance_data['cpu_usage'].append({
                'timestamp': datetime.now(),
                'value': cpu_usage
            })
            return cpu_usage
        except Exception as e:
            print(f"Error getting CPU usage: {e}")
            return None
    
    def get_memory_usage(self):
        """Get current memory usage information"""
        try:
            os_info = self.wmi_connection.Win32_OperatingSystem()[0]
            total_memory = int(os_info.TotalVisibleMemorySize) * 1024
            available_memory = int(os_info.AvailablePhysicalMemory) * 1024
            used_memory = total_memory - available_memory
            usage_percentage = (used_memory / total_memory) * 100
            
            memory_info = {
                'timestamp': datetime.now(),
                'total_memory': total_memory,
                'used_memory': used_memory,
                'available_memory': available_memory,
                'usage_percentage': usage_percentage
            }
            
            self.performance_data['memory_usage'].append(memory_info)
            return memory_info
        
        except Exception as e:
            print(f"Error getting memory usage: {e}")
            return None
    
    def get_disk_usage(self):
        """Get disk usage for all drives"""
        try:
            disk_info = []
            
            for disk in self.wmi_connection.Win32_LogicalDisk():
                if disk.Size:  # Only process drives with size info
                    total_size = int(disk.Size)
                    free_space = int(disk.FreeSpace)
                    used_space = total_size - free_space
                    usage_percentage = (used_space / total_size) * 100
                    
                    drive_info = {
                        'drive': disk.Caption,
                        'total_size': total_size,
                        'used_space': used_space,
                        'free_space': free_space,
                        'usage_percentage': usage_percentage,
                        'file_system': disk.FileSystem
                    }
                    
                    disk_info.append(drive_info)
            
            self.performance_data['disk_usage'].append({
                'timestamp': datetime.now(),
                'disks': disk_info
            })
            
            return disk_info
        
        except Exception as e:
            print(f"Error getting disk usage: {e}")
            return []
    
    def get_network_usage(self):
        """Get network adapter usage statistics"""
        try:
            network_info = []
            
            for adapter in self.wmi_connection.Win32_PerfRawData_Tcpip_NetworkInterface():
                if adapter.Name and 'Loopback' not in adapter.Name:
                    adapter_info = {
                        'name': adapter.Name,
                        'bytes_sent': int(adapter.BytesSentPerSec),
                        'bytes_received': int(adapter.BytesReceivedPerSec),
                        'packets_sent': int(adapter.PacketsSentPerSec),
                        'packets_received': int(adapter.PacketsReceivedPerSec)
                    }
                    
                    network_info.append(adapter_info)
            
            self.performance_data['network_usage'].append({
                'timestamp': datetime.now(),
                'adapters': network_info
            })
            
            return network_info
        
        except Exception as e:
            print(f"Error getting network usage: {e}")
            return []
    
    def get_comprehensive_status(self):
        """Get comprehensive system status"""
        return {
            'cpu_usage': self.get_cpu_usage(),
            'memory_usage': self.get_memory_usage(),
            'disk_usage': self.get_disk_usage(),
            'network_usage': self.get_network_usage(),
            'timestamp': datetime.now()
        }
```

---

## 4. Real-time Event Processing

### 4.1 Event Processing Engine

```python
import json
import sqlite3
from collections import deque
from threading import Lock

class EventProcessor:
    """Process and analyze events in real-time"""
    
    def __init__(self, db_path="events.db"):
        self.db_path = db_path
        self.event_buffer = deque(maxlen=10000)
        self.processors = []
        self.alert_handlers = []
        self.lock = Lock()
        self.statistics = {
            'total_processed': 0,
            'alerts_generated': 0,
            'errors': 0
        }
        self.setup_database()
    
    def setup_database(self):
        """Setup SQLite database for event storage"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    event_type TEXT,
                    source TEXT,
                    severity TEXT,
                    message TEXT,
                    data TEXT,
                    processed BOOLEAN DEFAULT FALSE
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS alerts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    alert_type TEXT,
                    severity TEXT,
                    message TEXT,
                    event_data TEXT,
                    acknowledged BOOLEAN DEFAULT FALSE
                )
            ''')
            
            conn.commit()
            conn.close()
            print("Event database initialized")
        
        except Exception as e:
            print(f"Error setting up database: {e}")
    
    def add_processor(self, processor_func):
        """Add event processor function"""
        self.processors.append(processor_func)
    
    def add_alert_handler(self, handler_func):
        """Add alert handler function"""
        self.alert_handlers.append(handler_func)
    
    def process_event(self, event):
        """Process a single event"""
        try:
            with self.lock:
                # Add to buffer
                self.event_buffer.append(event)
                
                # Store in database
                self.store_event(event)
                
                # Run processors
                for processor in self.processors:
                    try:
                        processor(event)
                    except Exception as e:
                        print(f"Error in event processor: {e}")
                        self.statistics['errors'] += 1
                
                self.statistics['total_processed'] += 1
            
            return True
        
        except Exception as e:
            print(f"Error processing event: {e}")
            self.statistics['errors'] += 1
            return False
    
    def store_event(self, event):
        """Store event in database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO events (timestamp, event_type, source, severity, message, data)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                event.get('timestamp', datetime.now()).isoformat(),
                event.get('event_type', 'Unknown'),
                event.get('source', 'Unknown'),
                event.get('severity', 'Info'),
                event.get('message', ''),
                json.dumps(event.get('data', {}))
            ))
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            print(f"Error storing event: {e}")
    
    def generate_alert(self, alert_type, severity, message, event_data=None):
        """Generate system alert"""
        try:
            alert = {
                'timestamp': datetime.now(),
                'alert_type': alert_type,
                'severity': severity,
                'message': message,
                'event_data': event_data or {}
            }
            
            # Store alert
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO alerts (timestamp, alert_type, severity, message, event_data)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                alert['timestamp'].isoformat(),
                alert_type,
                severity,
                message,
                json.dumps(event_data or {})
            ))
            
            conn.commit()
            conn.close()
            
            # Call alert handlers
            for handler in self.alert_handlers:
                try:
                    handler(alert)
                except Exception as e:
                    print(f"Error in alert handler: {e}")
            
            self.statistics['alerts_generated'] += 1
            return True
        
        except Exception as e:
            print(f"Error generating alert: {e}")
            return False
    
    def get_recent_events(self, count=100, event_type=None):
        """Get recent events from database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if event_type:
                cursor.execute('''
                    SELECT * FROM events 
                    WHERE event_type = ? 
                    ORDER BY timestamp DESC 
                    LIMIT ?
                ''', (event_type, count))
            else:
                cursor.execute('''
                    SELECT * FROM events 
                    ORDER BY timestamp DESC 
                    LIMIT ?
                ''', (count,))
            
            events = cursor.fetchall()
            conn.close()
            
            return events
        
        except Exception as e:
            print(f"Error getting recent events: {e}")
            return []
```

### 4.2 Pattern Detection and Alerting

```python
class PatternDetector:
    """Detect patterns and anomalies in event streams"""
    
    def __init__(self, event_processor):
        self.event_processor = event_processor
        self.patterns = {
            'failed_logins': {'count': 0, 'window': 300, 'threshold': 5},
            'high_cpu': {'count': 0, 'window': 180, 'threshold': 3},
            'disk_full': {'count': 0, 'window': 60, 'threshold': 1},
            'service_failures': {'count': 0, 'window': 120, 'threshold': 3}
        }
        self.event_history = deque(maxlen=1000)
    
    def analyze_event(self, event):
        """Analyze event for patterns"""
        try:
            self.event_history.append(event)
            
            # Check for various patterns
            self.check_login_failures(event)
            self.check_performance_issues(event)
            self.check_service_issues(event)
            self.check_security_events(event)
            
        except Exception as e:
            print(f"Error in pattern analysis: {e}")
    
    def check_login_failures(self, event):
        """Check for repeated login failures"""
        if (event.get('event_type') == 'SecurityEvent' and 
            'failed' in event.get('message', '').lower() and
            'login' in event.get('message', '').lower()):
            
            # Count recent failures
            recent_failures = self.count_recent_events(
                lambda e: (e.get('event_type') == 'SecurityEvent' and 
                          'failed' in e.get('message', '').lower() and
                          'login' in e.get('message', '').lower()),
                window_seconds=self.patterns['failed_logins']['window']
            )
            
            if recent_failures >= self.patterns['failed_logins']['threshold']:
                self.event_processor.generate_alert(
                    'Security',
                    'High',
                    f'Multiple login failures detected: {recent_failures} failures in last {self.patterns["failed_logins"]["window"]} seconds',
                    event
                )
    
    def check_performance_issues(self, event):
        """Check for performance-related issues"""
        if event.get('event_type') == 'PerformanceEvent':
            cpu_usage = event.get('data', {}).get('cpu_usage')
            memory_usage = event.get('data', {}).get('memory_usage', {}).get('usage_percentage')
            
            # High CPU usage
            if cpu_usage and cpu_usage > 90:
                recent_high_cpu = self.count_recent_events(
                    lambda e: (e.get('event_type') == 'PerformanceEvent' and
                              e.get('data', {}).get('cpu_usage', 0) > 90),
                    window_seconds=self.patterns['high_cpu']['window']
                )
                
                if recent_high_cpu >= self.patterns['high_cpu']['threshold']:
                    self.event_processor.generate_alert(
                        'Performance',
                        'Medium',
                        f'High CPU usage detected: {cpu_usage}% (sustained)',
                        event
                    )
            
            # High memory usage
            if memory_usage and memory_usage > 95:
                self.event_processor.generate_alert(
                    'Performance',
                    'High',
                    f'Critical memory usage detected: {memory_usage:.1f}%',
                    event
                )
    
    def check_service_issues(self, event):
        """Check for service-related issues"""
        if (event.get('event_type') == 'ServiceStateChange' and
            event.get('data', {}).get('state') == 'Stopped'):
            
            recent_service_failures = self.count_recent_events(
                lambda e: (e.get('event_type') == 'ServiceStateChange' and
                          e.get('data', {}).get('state') == 'Stopped'),
                window_seconds=self.patterns['service_failures']['window']
            )
            
            if recent_service_failures >= self.patterns['service_failures']['threshold']:
                self.event_processor.generate_alert(
                    'System',
                    'Medium',
                    f'Multiple service failures detected: {recent_service_failures} services stopped',
                    event
                )
    
    def check_security_events(self, event):
        """Check for security-related events"""
        # Check for privilege escalation
        if (event.get('event_type') == 'ProcessCreated' and
            any(keyword in event.get('data', {}).get('command_line', '').lower() 
                for keyword in ['runas', 'elevate', 'administrator'])):
            
            self.event_processor.generate_alert(
                'Security',
                'Medium',
                'Potential privilege escalation detected',
                event
            )
        
        # Check for suspicious process creation
        suspicious_processes = ['powershell.exe', 'cmd.exe', 'wscript.exe', 'cscript.exe']
        if (event.get('event_type') == 'ProcessCreated' and
            any(proc in event.get('data', {}).get('process_name', '').lower() 
                for proc in suspicious_processes)):
            
            # Count recent suspicious processes
            recent_suspicious = self.count_recent_events(
                lambda e: (e.get('event_type') == 'ProcessCreated' and
                          any(proc in e.get('data', {}).get('process_name', '').lower() 
                              for proc in suspicious_processes)),
                window_seconds=300
            )
            
            if recent_suspicious > 10:
                self.event_processor.generate_alert(
                    'Security',
                    'High',
                    f'High volume of suspicious process creation: {recent_suspicious} processes in 5 minutes',
                    event
                )
    
    def count_recent_events(self, condition_func, window_seconds):
        """Count events matching condition in time window"""
        current_time = datetime.now()
        count = 0
        
        for event in reversed(self.event_history):
            event_time = event.get('timestamp')
            if isinstance(event_time, str):
                event_time = datetime.fromisoformat(event_time.replace('Z', '+00:00'))
            
            time_diff = (current_time - event_time).total_seconds()
            if time_diff > window_seconds:
                break
            
            if condition_func(event):
                count += 1
        
        return count
```

---

## 5. Alert Systems and Notifications

### 5.1 Multi-Channel Alert System

```python
import smtplib
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class AlertSystem:
    """Multi-channel alert notification system"""
    
    def __init__(self, config):
        self.config = config
        self.alert_channels = {}
        self.setup_channels()
    
    def setup_channels(self):
        """Setup notification channels"""
        if 'email' in self.config:
            self.alert_channels['email'] = self.send_email_alert
        
        if 'webhook' in self.config:
            self.alert_channels['webhook'] = self.send_webhook_alert
        
        if 'file' in self.config:
            self.alert_channels['file'] = self.send_file_alert
    
    def send_alert(self, alert, channels=None):
        """Send alert through specified channels"""
        if channels is None:
            channels = list(self.alert_channels.keys())
        
        for channel in channels:
            if channel in self.alert_channels:
                try:
                    self.alert_channels[channel](alert)
                    print(f"Alert sent via {channel}")
                except Exception as e:
                    print(f"Error sending alert via {channel}: {e}")
    
    def send_email_alert(self, alert):
        """Send alert via email"""
        try:
            email_config = self.config['email']
            
            msg = MIMEMultipart()
            msg['From'] = email_config['from']
            msg['To'] = email_config['to']
            msg['Subject'] = f"[{alert['severity']}] {alert['alert_type']} Alert"
            
            body = f"""
Alert Details:
--------------
Type: {alert['alert_type']}
Severity: {alert['severity']}
Time: {alert['timestamp']}
Message: {alert['message']}

Event Data:
{json.dumps(alert.get('event_data', {}), indent=2)}
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(email_config['smtp_server'], email_config['smtp_port'])
            if email_config.get('use_tls'):
                server.starttls()
            
            if email_config.get('username') and email_config.get('password'):
                server.login(email_config['username'], email_config['password'])
            
            server.send_message(msg)
            server.quit()
            
        except Exception as e:
            print(f"Error sending email alert: {e}")
    
    def send_webhook_alert(self, alert):
        """Send alert via webhook"""
        try:
            webhook_config = self.config['webhook']
            
            payload = {
                'alert_type': alert['alert_type'],
                'severity': alert['severity'],
                'timestamp': alert['timestamp'].isoformat(),
                'message': alert['message'],
                'event_data': alert.get('event_data', {})
            }
            
            response = requests.post(
                webhook_config['url'],
                json=payload,
                headers=webhook_config.get('headers', {}),
                timeout=10
            )
            
            response.raise_for_status()
            
        except Exception as e:
            print(f"Error sending webhook alert: {e}")
    
    def send_file_alert(self, alert):
        """Send alert to file"""
        try:
            file_config = self.config['file']
            
            alert_text = f"[{alert['timestamp']}] [{alert['severity']}] {alert['alert_type']}: {alert['message']}\n"
            
            with open(file_config['path'], 'a') as f:
                f.write(alert_text)
            
        except Exception as e:
            print(f"Error sending file alert: {e}")
```

---

## 6. Practical Exercises

### Exercise 1: Event Log Analyzer
Create a comprehensive event log analysis tool.

```python
# Your implementation here
def analyze_security_events(log_name="Security", hours_back=24):
    """
    Analyze security events:
    - Failed login attempts
    - Privilege escalations
    - Account changes
    - Policy modifications
    """
    pass
```

### Exercise 2: File System Security Monitor
Build a file system security monitoring tool.

```python
# Your implementation here
def security_file_monitor(protected_directories):
    """
    Monitor protected directories:
    - Unauthorized access attempts
    - File modifications
    - Permission changes
    - Suspicious activity patterns
    """
    pass
```

### Exercise 3: System Health Dashboard
Create a real-time system health monitoring dashboard.

```python
# Your implementation here
def create_health_dashboard():
    """
    Health dashboard features:
    - Real-time performance metrics
    - Event log summaries
    - Alert notifications
    - Historical trend analysis
    """
    pass
```

### Exercise 4: Automated Incident Response
Build an automated incident response system.

```python
# Your implementation here
def incident_response_system(alert_rules):
    """
    Incident response features:
    - Automated threat detection
    - Response workflow execution
    - Evidence collection
    - Notification escalation
    """
    pass
```

---

## Best Practices

### 1. Performance Optimization
```python
# Use efficient event filtering
def efficient_event_filter(events, criteria):
    return filter(lambda e: all(
        e.get(key) == value for key, value in criteria.items()
    ), events)
```

### 2. Resource Management
```python
# Properly manage WMI connections
class WMIContextManager:
    def __enter__(self):
        pythoncom.CoInitialize()
        return wmi.WMI()
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        pythoncom.CoUninitialize()
```

### 3. Error Resilience
```python
# Implement retry logic for critical operations
def retry_operation(operation, max_retries=3, delay=1):
    for attempt in range(max_retries):
        try:
            return operation()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            time.sleep(delay)
```

---

## Common Pitfalls and Solutions

### 1. Event Log Access Permissions
**Problem**: Access denied when reading security logs.
**Solution**: Run with administrator privileges or use appropriate service accounts.

### 2. WMI Performance Impact
**Problem**: WMI queries consuming too many resources.
**Solution**: Use efficient queries, implement proper timeouts, and limit result sets.

### 3. Memory Leaks in Long-Running Monitoring
**Problem**: Memory usage grows over time.
**Solution**: Implement proper cleanup, use bounded buffers, and restart monitoring threads periodically.

### 4. Alert Fatigue
**Problem**: Too many alerts overwhelming administrators.
**Solution**: Implement intelligent filtering, alert correlation, and escalation policies.

---

## Capstone Project: System Monitoring Dashboard

### Project Overview
Build a comprehensive system monitoring dashboard that integrates all learned concepts.

### Core Features
1. **Real-time Event Monitoring**: Windows Event Log, file system, and WMI integration
2. **Pattern Detection**: Automated threat and anomaly detection
3. **Alert Management**: Multi-channel notifications with escalation
4. **Performance Tracking**: System health and performance metrics
5. **Web Dashboard**: Real-time visualization and management interface

### Technical Requirements

```python
class MonitoringDashboard:
    """Complete system monitoring solution"""
    
    def __init__(self, config_path):
        self.config = self.load_config(config_path)
        self.event_processor = EventProcessor()
        self.pattern_detector = PatternDetector(self.event_processor)
        self.alert_system = AlertSystem(self.config['alerts'])
        self.monitors = {}
    
    def start_monitoring(self):
        """Start all monitoring components"""
        # Implementation required
        pass
    
    def create_web_interface(self):
        """Create web-based dashboard interface"""
        # Implementation required
        pass
    
    def generate_reports(self):
        """Generate monitoring reports"""
        # Implementation required
        pass

# Implementation guidelines:
# 1. Modular architecture with clear separation of concerns
# 2. Configuration-driven setup for flexibility
# 3. Web interface using Flask or similar framework
# 4. Real-time updates using WebSockets
# 5. Comprehensive logging and error handling
```

### Project Deliverables
1. Complete monitoring system with all components
2. Web-based dashboard interface
3. Configuration templates and documentation
4. Installation and deployment scripts
5. Performance analysis and optimization report

---

## Summary

Event handling and monitoring provide the foundation for robust system administration and security. Key takeaways:

1. **Event Log Programming**: Master reading, writing, and analyzing Windows Event Logs
2. **File System Monitoring**: Implement real-time file and directory change detection
3. **WMI Integration**: Leverage WMI for comprehensive system monitoring
4. **Pattern Detection**: Build intelligent alert systems with anomaly detection
5. **Alert Management**: Create multi-channel notification systems
6. **Performance Monitoring**: Track system health and performance metrics
7. **Integration**: Combine multiple monitoring sources for comprehensive coverage

These skills enable you to build professional monitoring solutions that can detect threats, track system health, and automatically respond to critical conditions.

**Next Steps**: Continue to [3.3 Advanced GUI Interactions](./3.3%20Advanced%20GUI%20Interactions.md) to learn sophisticated GUI automation and interaction techniques.
