# 4.1 Performance Monitoring

## Learning Objectives
By the end of this module, you will:
- Master Windows performance monitoring with pywin32
- Implement real-time performance data collection
- Create custom performance counters and metrics
- Build comprehensive monitoring dashboards
- Integrate with WMI for advanced system metrics
- Develop enterprise-grade monitoring solutions

## Module Overview
Performance monitoring is critical for maintaining system health and optimizing performance. This module covers advanced performance monitoring techniques using pywin32, including performance counters, WMI integration, and building scalable monitoring systems.

### Key pywin32 Modules
- `win32pdh` - Performance Data Helper for accessing performance counters
- `win32api` - System API functions for performance data
- `wmi` - Windows Management Instrumentation
- `win32con` - Windows constants
- `win32file` - File system performance monitoring

## 1. Performance Data Helper (PDH) Fundamentals

### Understanding Performance Counters
Performance counters provide real-time metrics about system performance.

```python
import win32pdh
import win32api
import time
import threading
from collections import defaultdict

class PerformanceCounter:
    """A wrapper for Windows performance counters."""
    
    def __init__(self, counter_path):
        """Initialize a performance counter.
        
        Args:
            counter_path: Counter path like '\\Processor(_Total)\\% Processor Time'
        """
        self.counter_path = counter_path
        self.query = None
        self.counter = None
        self._initialize_counter()
    
    def _initialize_counter(self):
        """Initialize the PDH query and counter."""
        try:
            # Create a new query
            self.query = win32pdh.OpenQuery(None, 0)
            
            # Add the counter to the query
            self.counter = win32pdh.AddCounter(self.query, self.counter_path, 0)
            
            # Collect an initial sample
            win32pdh.CollectQueryData(self.query)
            
        except Exception as e:
            print(f"Error initializing counter {self.counter_path}: {e}")
            raise
    
    def get_value(self):
        """Get the current counter value."""
        try:
            # Collect query data
            win32pdh.CollectQueryData(self.query)
            
            # Get the formatted counter value
            status, value = win32pdh.GetFormattedCounterValue(
                self.counter, win32pdh.PDH_FMT_DOUBLE
            )
            
            return value
        except Exception as e:
            print(f"Error getting counter value: {e}")
            return None
    
    def close(self):
        """Clean up PDH resources."""
        try:
            if self.counter:
                win32pdh.RemoveCounter(self.counter)
            if self.query:
                win32pdh.CloseQuery(self.query)
        except Exception as e:
            print(f"Error closing counter: {e}")

def list_available_counters():
    """List all available performance counters."""
    try:
        # Get list of performance objects
        objects = win32pdh.EnumObjects(None, None, 0)
        
        counters_info = {}
        for obj in objects:
            try:
                # Get counters for this object
                items, counters = win32pdh.EnumObjectItems(
                    None, None, obj, 0
                )
                counters_info[obj] = {
                    'instances': items,
                    'counters': counters
                }
            except Exception as e:
                print(f"Error getting counters for {obj}: {e}")
        
        return counters_info
    except Exception as e:
        print(f"Error listing counters: {e}")
        return {}

# Example usage
def monitor_cpu_usage():
    """Monitor CPU usage in real-time."""
    cpu_counter = PerformanceCounter(r'\Processor(_Total)\% Processor Time')
    
    try:
        print("Monitoring CPU usage (Press Ctrl+C to stop):")
        while True:
            value = cpu_counter.get_value()
            if value is not None:
                print(f"CPU Usage: {value:.2f}%")
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nMonitoring stopped.")
    finally:
        cpu_counter.close()
```

### System Performance Metrics Collection

```python
import psutil
import json
from datetime import datetime
import threading

class SystemPerformanceMonitor:
    """Comprehensive system performance monitoring."""
    
    def __init__(self):
        self.counters = {}
        self.is_monitoring = False
        self.monitor_thread = None
        self.data_callback = None
        
        # Initialize performance counters
        self._initialize_counters()
    
    def _initialize_counters(self):
        """Initialize all performance counters."""
        counter_paths = {
            'cpu_usage': r'\Processor(_Total)\% Processor Time',
            'memory_available': r'\Memory\Available MBytes',
            'memory_committed': r'\Memory\Committed Bytes',
            'disk_reads': r'\PhysicalDisk(_Total)\Disk Reads/sec',
            'disk_writes': r'\PhysicalDisk(_Total)\Disk Writes/sec',
            'network_bytes_total': r'\Network Interface(*)\Bytes Total/sec',
            'process_count': r'\System\Processes',
            'thread_count': r'\System\Threads',
        }
        
        for name, path in counter_paths.items():
            try:
                self.counters[name] = PerformanceCounter(path)
            except Exception as e:
                print(f"Failed to initialize counter {name}: {e}")
    
    def get_current_metrics(self):
        """Get current performance metrics."""
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'system': {}
        }
        
        # Collect PDH counter values
        for name, counter in self.counters.items():
            try:
                value = counter.get_value()
                if value is not None:
                    metrics['system'][name] = value
            except Exception as e:
                print(f"Error getting {name}: {e}")
        
        # Add additional metrics using psutil
        try:
            # CPU information
            cpu_percent = psutil.cpu_percent(interval=0.1)
            cpu_count = psutil.cpu_count()
            
            # Memory information
            memory = psutil.virtual_memory()
            
            # Disk information
            disk_usage = psutil.disk_usage('C:')
            disk_io = psutil.disk_io_counters()
            
            # Network information
            network_io = psutil.net_io_counters()
            
            metrics['system'].update({
                'cpu_percent_psutil': cpu_percent,
                'cpu_count': cpu_count,
                'memory_total_gb': memory.total / (1024**3),
                'memory_used_gb': memory.used / (1024**3),
                'memory_percent': memory.percent,
                'disk_total_gb': disk_usage.total / (1024**3),
                'disk_used_gb': disk_usage.used / (1024**3),
                'disk_free_gb': disk_usage.free / (1024**3),
                'disk_percent': (disk_usage.used / disk_usage.total) * 100,
                'network_bytes_sent': network_io.bytes_sent if network_io else 0,
                'network_bytes_recv': network_io.bytes_recv if network_io else 0,
            })
            
            if disk_io:
                metrics['system'].update({
                    'disk_read_bytes': disk_io.read_bytes,
                    'disk_write_bytes': disk_io.write_bytes,
                })
                
        except Exception as e:
            print(f"Error getting psutil metrics: {e}")
        
        return metrics
    
    def start_monitoring(self, interval=5, callback=None):
        """Start continuous monitoring."""
        self.data_callback = callback
        self.is_monitoring = True
        
        def monitor_loop():
            while self.is_monitoring:
                try:
                    metrics = self.get_current_metrics()
                    if self.data_callback:
                        self.data_callback(metrics)
                    else:
                        print(f"Metrics at {metrics['timestamp']}:")
                        for key, value in metrics['system'].items():
                            print(f"  {key}: {value}")
                        print("-" * 50)
                except Exception as e:
                    print(f"Error in monitoring loop: {e}")
                
                time.sleep(interval)
        
        self.monitor_thread = threading.Thread(target=monitor_loop)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
    
    def stop_monitoring(self):
        """Stop monitoring."""
        self.is_monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
    
    def cleanup(self):
        """Clean up resources."""
        self.stop_monitoring()
        for counter in self.counters.values():
            counter.close()

# Example usage
def demo_performance_monitoring():
    """Demonstrate performance monitoring."""
    monitor = SystemPerformanceMonitor()
    
    try:
        print("Starting performance monitoring...")
        monitor.start_monitoring(interval=2)
        
        # Let it run for 30 seconds
        time.sleep(30)
        
    except KeyboardInterrupt:
        print("\nStopping monitoring...")
    finally:
        monitor.cleanup()
```

## 2. WMI Integration for Advanced Monitoring

### WMI Performance Providers

```python
import wmi
import json
from datetime import datetime
import threading
import time

class WMIPerformanceMonitor:
    """Advanced performance monitoring using WMI."""
    
    def __init__(self):
        self.wmi_conn = wmi.WMI()
        self.process_watchers = []
        self.service_watchers = []
        self.is_monitoring = False
    
    def get_system_info(self):
        """Get comprehensive system information."""
        try:
            # Computer system information
            computer_system = self.wmi_conn.Win32_ComputerSystem()[0]
            
            # Operating system information
            os_info = self.wmi_conn.Win32_OperatingSystem()[0]
            
            # Processor information
            processors = self.wmi_conn.Win32_Processor()
            
            # Memory information
            memory_modules = self.wmi_conn.Win32_PhysicalMemory()
            
            system_info = {
                'computer': {
                    'name': computer_system.Name,
                    'manufacturer': computer_system.Manufacturer,
                    'model': computer_system.Model,
                    'total_memory_gb': float(computer_system.TotalPhysicalMemory) / (1024**3),
                    'domain': computer_system.Domain,
                },
                'operating_system': {
                    'name': os_info.Name.split('|')[0],
                    'version': os_info.Version,
                    'architecture': os_info.OSArchitecture,
                    'install_date': str(os_info.InstallDate),
                    'last_boot': str(os_info.LastBootUpTime),
                },
                'processors': [],
                'memory_modules': []
            }
            
            # Processor details
            for proc in processors:
                system_info['processors'].append({
                    'name': proc.Name,
                    'cores': proc.NumberOfCores,
                    'logical_processors': proc.NumberOfLogicalProcessors,
                    'max_speed_mhz': proc.MaxClockSpeed,
                    'current_speed_mhz': proc.CurrentClockSpeed,
                })
            
            # Memory module details
            for mem in memory_modules:
                system_info['memory_modules'].append({
                    'capacity_gb': float(mem.Capacity) / (1024**3) if mem.Capacity else 0,
                    'speed_mhz': mem.Speed,
                    'manufacturer': mem.Manufacturer,
                    'part_number': mem.PartNumber,
                })
            
            return system_info
            
        except Exception as e:
            print(f"Error getting system info: {e}")
            return {}
    
    def get_process_performance(self):
        """Get process performance metrics."""
        try:
            processes = self.wmi_conn.Win32_Process()
            process_metrics = []
            
            for proc in processes:
                try:
                    # Get additional performance data
                    perf_proc = None
                    for perf in self.wmi_conn.Win32_PerfRawData_PerfProc_Process():
                        if perf.IDProcess == proc.ProcessId:
                            perf_proc = perf
                            break
                    
                    process_info = {
                        'pid': proc.ProcessId,
                        'name': proc.Name,
                        'executable_path': proc.ExecutablePath,
                        'command_line': proc.CommandLine,
                        'creation_date': str(proc.CreationDate) if proc.CreationDate else None,
                        'working_set_size': proc.WorkingSetSize,
                        'virtual_size': proc.VirtualSize,
                        'page_file_usage': proc.PageFileUsage,
                        'thread_count': proc.ThreadCount,
                        'handle_count': proc.HandleCount,
                    }
                    
                    if perf_proc:
                        process_info.update({
                            'processor_time': perf_proc.PercentProcessorTime,
                            'user_time': perf_proc.PercentUserTime,
                            'privileged_time': perf_proc.PercentPrivilegedTime,
                            'io_read_bytes': perf_proc.IOReadBytesPerSec,
                            'io_write_bytes': perf_proc.IOWriteBytesPerSec,
                        })
                    
                    process_metrics.append(process_info)
                    
                except Exception as e:
                    # Skip processes we can't access
                    continue
            
            return process_metrics
            
        except Exception as e:
            print(f"Error getting process performance: {e}")
            return []
    
    def get_service_status(self):
        """Get Windows service status."""
        try:
            services = self.wmi_conn.Win32_Service()
            service_info = []
            
            for service in services:
                service_info.append({
                    'name': service.Name,
                    'display_name': service.DisplayName,
                    'state': service.State,
                    'status': service.Status,
                    'start_mode': service.StartMode,
                    'service_type': service.ServiceType,
                    'path_name': service.PathName,
                    'process_id': service.ProcessId,
                })
            
            return service_info
            
        except Exception as e:
            print(f"Error getting service status: {e}")
            return []
    
    def get_disk_performance(self):
        """Get disk performance metrics."""
        try:
            disks = self.wmi_conn.Win32_LogicalDisk()
            disk_metrics = []
            
            for disk in disks:
                if disk.DriveType == 3:  # Local disk
                    disk_metrics.append({
                        'drive': disk.DeviceID,
                        'label': disk.VolumeName,
                        'file_system': disk.FileSystem,
                        'size_gb': float(disk.Size) / (1024**3) if disk.Size else 0,
                        'free_space_gb': float(disk.FreeSpace) / (1024**3) if disk.FreeSpace else 0,
                        'used_space_gb': (float(disk.Size) - float(disk.FreeSpace)) / (1024**3) if disk.Size and disk.FreeSpace else 0,
                        'percent_used': ((float(disk.Size) - float(disk.FreeSpace)) / float(disk.Size)) * 100 if disk.Size and disk.FreeSpace else 0,
                    })
            
            return disk_metrics
            
        except Exception as e:
            print(f"Error getting disk performance: {e}")
            return []
    
    def get_network_adapters(self):
        """Get network adapter information."""
        try:
            adapters = self.wmi_conn.Win32_NetworkAdapter()
            adapter_info = []
            
            for adapter in adapters:
                if adapter.NetEnabled:
                    adapter_info.append({
                        'name': adapter.Name,
                        'description': adapter.Description,
                        'mac_address': adapter.MACAddress,
                        'adapter_type': adapter.AdapterType,
                        'speed': adapter.Speed,
                        'manufacturer': adapter.Manufacturer,
                        'net_enabled': adapter.NetEnabled,
                    })
            
            return adapter_info
            
        except Exception as e:
            print(f"Error getting network adapters: {e}")
            return []
    
    def monitor_process_events(self, callback=None):
        """Monitor process creation and termination events."""
        try:
            # Monitor process creation
            process_watcher = self.wmi_conn.Win32_Process.watch_for("creation")
            
            def process_created():
                while self.is_monitoring:
                    try:
                        new_process = process_watcher(timeout_ms=1000)
                        event_data = {
                            'event_type': 'process_created',
                            'timestamp': datetime.now().isoformat(),
                            'process_id': new_process.ProcessId,
                            'process_name': new_process.Name,
                            'executable_path': new_process.ExecutablePath,
                            'command_line': new_process.CommandLine,
                        }
                        
                        if callback:
                            callback(event_data)
                        else:
                            print(f"Process Created: {event_data}")
                            
                    except wmi.x_wmi_timed_out:
                        continue
                    except Exception as e:
                        print(f"Error monitoring process events: {e}")
                        break
            
            process_thread = threading.Thread(target=process_created)
            process_thread.daemon = True
            process_thread.start()
            self.process_watchers.append(process_thread)
            
        except Exception as e:
            print(f"Error setting up process monitoring: {e}")
    
    def start_comprehensive_monitoring(self, interval=10, callback=None):
        """Start comprehensive system monitoring."""
        self.is_monitoring = True
        
        def monitoring_loop():
            while self.is_monitoring:
                try:
                    metrics = {
                        'timestamp': datetime.now().isoformat(),
                        'system_info': self.get_system_info(),
                        'processes': self.get_process_performance(),
                        'services': self.get_service_status(),
                        'disks': self.get_disk_performance(),
                        'network_adapters': self.get_network_adapters(),
                    }
                    
                    if callback:
                        callback(metrics)
                    else:
                        print(f"System metrics collected at {metrics['timestamp']}")
                        print(f"Processes: {len(metrics['processes'])}")
                        print(f"Services: {len(metrics['services'])}")
                        print(f"Disks: {len(metrics['disks'])}")
                        print("-" * 50)
                        
                except Exception as e:
                    print(f"Error in monitoring loop: {e}")
                
                time.sleep(interval)
        
        monitor_thread = threading.Thread(target=monitoring_loop)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        # Also start process event monitoring
        self.monitor_process_events(callback)
    
    def stop_monitoring(self):
        """Stop all monitoring."""
        self.is_monitoring = False

# Example usage
def demo_wmi_monitoring():
    """Demonstrate WMI monitoring capabilities."""
    wmi_monitor = WMIPerformanceMonitor()
    
    try:
        print("Getting system information...")
        system_info = wmi_monitor.get_system_info()
        print(json.dumps(system_info, indent=2))
        
        print("\nStarting comprehensive monitoring...")
        wmi_monitor.start_comprehensive_monitoring(interval=15)
        
        # Let it run for 60 seconds
        time.sleep(60)
        
    except KeyboardInterrupt:
        print("\nStopping monitoring...")
    finally:
        wmi_monitor.stop_monitoring()
```

## 3. Custom Performance Metrics and Alerting

### Custom Metrics Framework

```python
import sqlite3
import json
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
import threading
import queue
import statistics

class MetricsDatabase:
    """Database for storing performance metrics."""
    
    def __init__(self, db_path="performance_metrics.db"):
        self.db_path = db_path
        self._initialize_db()
    
    def _initialize_db(self):
        """Initialize the database schema."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create metrics table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS metrics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                metric_name TEXT NOT NULL,
                metric_value REAL NOT NULL,
                metric_unit TEXT,
                source TEXT,
                metadata TEXT
            )
        ''')
        
        # Create alerts table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                alert_type TEXT NOT NULL,
                metric_name TEXT NOT NULL,
                threshold_value REAL,
                actual_value REAL,
                severity TEXT,
                message TEXT,
                resolved BOOLEAN DEFAULT FALSE
            )
        ''')
        
        # Create indexes
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_metrics_timestamp ON metrics(timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_metrics_name ON metrics(metric_name)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_alerts_timestamp ON alerts(timestamp)')
        
        conn.commit()
        conn.close()
    
    def store_metrics(self, metrics_list):
        """Store multiple metrics in the database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            for metric in metrics_list:
                cursor.execute('''
                    INSERT INTO metrics (timestamp, metric_name, metric_value, metric_unit, source, metadata)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (
                    metric.get('timestamp', datetime.now().isoformat()),
                    metric['name'],
                    metric['value'],
                    metric.get('unit', ''),
                    metric.get('source', ''),
                    json.dumps(metric.get('metadata', {}))
                ))
            
            conn.commit()
        except Exception as e:
            print(f"Error storing metrics: {e}")
            conn.rollback()
        finally:
            conn.close()
    
    def get_metrics(self, metric_name, start_time=None, end_time=None, limit=None):
        """Retrieve metrics from the database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM metrics WHERE metric_name = ?"
        params = [metric_name]
        
        if start_time:
            query += " AND timestamp >= ?"
            params.append(start_time)
        
        if end_time:
            query += " AND timestamp <= ?"
            params.append(end_time)
        
        query += " ORDER BY timestamp DESC"
        
        if limit:
            query += " LIMIT ?"
            params.append(limit)
        
        cursor.execute(query, params)
        results = cursor.fetchall()
        conn.close()
        
        return results
    
    def store_alert(self, alert_data):
        """Store an alert in the database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                INSERT INTO alerts (timestamp, alert_type, metric_name, threshold_value, 
                                  actual_value, severity, message)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                alert_data.get('timestamp', datetime.now().isoformat()),
                alert_data['type'],
                alert_data['metric_name'],
                alert_data.get('threshold_value'),
                alert_data.get('actual_value'),
                alert_data.get('severity', 'warning'),
                alert_data.get('message', '')
            ))
            
            conn.commit()
            return cursor.lastrowid
        except Exception as e:
            print(f"Error storing alert: {e}")
            conn.rollback()
            return None
        finally:
            conn.close()

class AlertManager:
    """Manage performance alerts and notifications."""
    
    def __init__(self, smtp_config=None):
        self.thresholds = {}
        self.alert_history = {}
        self.smtp_config = smtp_config
        self.database = MetricsDatabase()
    
    def add_threshold(self, metric_name, threshold_type, value, severity='warning'):
        """Add a threshold for monitoring.
        
        Args:
            metric_name: Name of the metric to monitor
            threshold_type: 'greater_than', 'less_than', 'equals'
            value: Threshold value
            severity: 'info', 'warning', 'critical'
        """
        if metric_name not in self.thresholds:
            self.thresholds[metric_name] = []
        
        self.thresholds[metric_name].append({
            'type': threshold_type,
            'value': value,
            'severity': severity
        })
    
    def check_thresholds(self, metric_name, metric_value):
        """Check if a metric value exceeds any thresholds."""
        alerts = []
        
        if metric_name in self.thresholds:
            for threshold in self.thresholds[metric_name]:
                triggered = False
                
                if threshold['type'] == 'greater_than' and metric_value > threshold['value']:
                    triggered = True
                elif threshold['type'] == 'less_than' and metric_value < threshold['value']:
                    triggered = True
                elif threshold['type'] == 'equals' and metric_value == threshold['value']:
                    triggered = True
                
                if triggered:
                    alert = {
                        'timestamp': datetime.now().isoformat(),
                        'type': 'threshold_exceeded',
                        'metric_name': metric_name,
                        'threshold_value': threshold['value'],
                        'actual_value': metric_value,
                        'severity': threshold['severity'],
                        'message': f"{metric_name} {threshold['type']} {threshold['value']} (actual: {metric_value})"
                    }
                    alerts.append(alert)
                    
                    # Store in database
                    self.database.store_alert(alert)
        
        return alerts
    
    def send_email_alert(self, alert):
        """Send email notification for an alert."""
        if not self.smtp_config:
            print("SMTP not configured, cannot send email alerts")
            return False
        
        try:
            msg = MIMEMultipart()
            msg['From'] = self.smtp_config['from_email']
            msg['To'] = self.smtp_config['to_email']
            msg['Subject'] = f"Performance Alert: {alert['metric_name']} - {alert['severity'].upper()}"
            
            body = f"""
            Performance Alert Details:
            
            Metric: {alert['metric_name']}
            Severity: {alert['severity'].upper()}
            Threshold: {alert['threshold_value']}
            Actual Value: {alert['actual_value']}
            Time: {alert['timestamp']}
            Message: {alert['message']}
            
            Please investigate this performance issue.
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(self.smtp_config['smtp_server'], self.smtp_config['smtp_port'])
            if self.smtp_config.get('use_tls'):
                server.starttls()
            if self.smtp_config.get('username'):
                server.login(self.smtp_config['username'], self.smtp_config['password'])
            
            server.send_message(msg)
            server.quit()
            
            print(f"Email alert sent for {alert['metric_name']}")
            return True
            
        except Exception as e:
            print(f"Error sending email alert: {e}")
            return False

class PerformanceMonitoringSystem:
    """Comprehensive performance monitoring system."""
    
    def __init__(self, smtp_config=None):
        self.pdh_monitor = SystemPerformanceMonitor()
        self.wmi_monitor = WMIPerformanceMonitor()
        self.alert_manager = AlertManager(smtp_config)
        self.database = MetricsDatabase()
        self.metrics_queue = queue.Queue()
        self.is_running = False
        
        # Setup default thresholds
        self._setup_default_thresholds()
    
    def _setup_default_thresholds(self):
        """Setup default performance thresholds."""
        # CPU thresholds
        self.alert_manager.add_threshold('cpu_usage', 'greater_than', 80, 'warning')
        self.alert_manager.add_threshold('cpu_usage', 'greater_than', 95, 'critical')
        
        # Memory thresholds
        self.alert_manager.add_threshold('memory_percent', 'greater_than', 85, 'warning')
        self.alert_manager.add_threshold('memory_percent', 'greater_than', 95, 'critical')
        
        # Disk thresholds
        self.alert_manager.add_threshold('disk_percent', 'greater_than', 90, 'warning')
        self.alert_manager.add_threshold('disk_percent', 'greater_than', 98, 'critical')
    
    def process_metrics(self, metrics_data):
        """Process collected metrics and check for alerts."""
        try:
            metrics_list = []
            timestamp = metrics_data.get('timestamp', datetime.now().isoformat())
            
            # Process system metrics
            for metric_name, value in metrics_data.get('system', {}).items():
                if isinstance(value, (int, float)):
                    metric = {
                        'timestamp': timestamp,
                        'name': metric_name,
                        'value': value,
                        'source': 'system',
                        'metadata': {'category': 'performance'}
                    }
                    metrics_list.append(metric)
                    
                    # Check thresholds
                    alerts = self.alert_manager.check_thresholds(metric_name, value)
                    for alert in alerts:
                        print(f"ALERT: {alert['message']}")
                        self.alert_manager.send_email_alert(alert)
            
            # Store metrics in database
            if metrics_list:
                self.database.store_metrics(metrics_list)
            
        except Exception as e:
            print(f"Error processing metrics: {e}")
    
    def start_monitoring(self, interval=30):
        """Start comprehensive monitoring."""
        self.is_running = True
        
        # Start PDH monitoring
        self.pdh_monitor.start_monitoring(
            interval=interval,
            callback=self.process_metrics
        )
        
        # Start WMI monitoring (less frequent)
        self.wmi_monitor.start_comprehensive_monitoring(
            interval=interval * 2,
            callback=lambda data: print(f"WMI data collected: {len(data.get('processes', []))} processes")
        )
        
        print(f"Performance monitoring started with {interval}s interval")
    
    def stop_monitoring(self):
        """Stop all monitoring."""
        self.is_running = False
        self.pdh_monitor.stop_monitoring()
        self.wmi_monitor.stop_monitoring()
        print("Performance monitoring stopped")
    
    def get_performance_report(self, hours=24):
        """Generate a performance report for the specified time period."""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        
        report = {
            'period': f"{start_time.isoformat()} to {end_time.isoformat()}",
            'metrics_summary': {},
            'alerts_summary': {}
        }
        
        # Get metrics for key performance indicators
        key_metrics = ['cpu_usage', 'memory_percent', 'disk_percent']
        
        for metric_name in key_metrics:
            metrics = self.database.get_metrics(
                metric_name,
                start_time.isoformat(),
                end_time.isoformat()
            )
            
            if metrics:
                values = [float(row[3]) for row in metrics]  # metric_value is column 3
                
                report['metrics_summary'][metric_name] = {
                    'count': len(values),
                    'average': statistics.mean(values),
                    'min': min(values),
                    'max': max(values),
                    'median': statistics.median(values),
                }
                
                if len(values) > 1:
                    report['metrics_summary'][metric_name]['std_dev'] = statistics.stdev(values)
        
        return report

# Example usage and testing
def demo_comprehensive_monitoring():
    """Demonstrate comprehensive performance monitoring system."""
    
    # SMTP configuration (optional)
    smtp_config = {
        'smtp_server': 'smtp.gmail.com',
        'smtp_port': 587,
        'use_tls': True,
        'username': 'your_email@gmail.com',
        'password': 'your_password',
        'from_email': 'your_email@gmail.com',
        'to_email': 'admin@company.com'
    }
    
    # Create monitoring system (without email for demo)
    monitor_system = PerformanceMonitoringSystem()  # smtp_config for email alerts
    
    try:
        print("Starting comprehensive performance monitoring...")
        monitor_system.start_monitoring(interval=10)
        
        # Let it run for 2 minutes
        time.sleep(120)
        
        # Generate a report
        print("\nGenerating performance report...")
        report = monitor_system.get_performance_report(hours=1)
        print(json.dumps(report, indent=2))
        
    except KeyboardInterrupt:
        print("\nStopping monitoring...")
    finally:
        monitor_system.stop_monitoring()

if __name__ == "__main__":
    demo_comprehensive_monitoring()
```

## 4. Real-time Dashboard and Visualization

### Web-based Performance Dashboard

```python
import flask
from flask import render_template, jsonify
import json
from datetime import datetime, timedelta
import threading
import os

# Create Flask app for dashboard
app = flask.Flask(__name__)

# Global monitoring system instance
monitoring_system = None

@app.route('/')
def dashboard():
    """Main dashboard page."""
    return render_template('dashboard.html')

@app.route('/api/current_metrics')
def get_current_metrics():
    """API endpoint for current metrics."""
    if monitoring_system:
        metrics = monitoring_system.pdh_monitor.get_current_metrics()
        return jsonify(metrics)
    return jsonify({'error': 'Monitoring not active'})

@app.route('/api/historical_metrics/<metric_name>')
def get_historical_metrics(metric_name):
    """API endpoint for historical metrics."""
    hours = int(flask.request.args.get('hours', 24))
    
    if monitoring_system:
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        
        metrics = monitoring_system.database.get_metrics(
            metric_name,
            start_time.isoformat(),
            end_time.isoformat(),
            limit=1000
        )
        
        # Format for chart
        chart_data = []
        for row in metrics:
            chart_data.append({
                'timestamp': row[1],  # timestamp
                'value': float(row[3])  # metric_value
            })
        
        return jsonify(chart_data)
    
    return jsonify([])

@app.route('/api/alerts')
def get_alerts():
    """API endpoint for recent alerts."""
    # This would query the alerts table
    return jsonify([])

# HTML template for dashboard
dashboard_html = '''
<!DOCTYPE html>
<html>
<head>
    <title>Performance Monitoring Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .metric-card { 
            border: 1px solid #ddd; 
            padding: 15px; 
            margin: 10px; 
            border-radius: 5px; 
            display: inline-block; 
            width: 300px; 
            vertical-align: top;
        }
        .metric-value { 
            font-size: 24px; 
            font-weight: bold; 
            color: #333; 
        }
        .chart-container { 
            width: 100%; 
            height: 400px; 
            margin: 20px 0; 
        }
        .alert { 
            background-color: #f8d7da; 
            border: 1px solid #f5c6cb; 
            padding: 10px; 
            margin: 5px 0; 
            border-radius: 3px; 
        }
    </style>
</head>
<body>
    <h1>System Performance Dashboard</h1>
    
    <div id="current-metrics">
        <h2>Current Metrics</h2>
        <div id="metrics-cards"></div>
    </div>
    
    <div id="charts">
        <h2>Performance Trends</h2>
        <div class="chart-container">
            <canvas id="cpu-chart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="memory-chart"></canvas>
        </div>
    </div>
    
    <div id="alerts">
        <h2>Recent Alerts</h2>
        <div id="alerts-list"></div>
    </div>

    <script>
        // Initialize charts
        const cpuChart = new Chart(document.getElementById('cpu-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'CPU Usage %',
                    data: [],
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100
                    }
                }
            }
        });

        const memoryChart = new Chart(document.getElementById('memory-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Memory Usage %',
                    data: [],
                    borderColor: 'rgb(255, 99, 132)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100
                    }
                }
            }
        });

        // Update current metrics
        function updateCurrentMetrics() {
            fetch('/api/current_metrics')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('metrics-cards');
                    container.innerHTML = '';
                    
                    if (data.system) {
                        for (const [key, value] of Object.entries(data.system)) {
                            if (typeof value === 'number') {
                                const card = document.createElement('div');
                                card.className = 'metric-card';
                                card.innerHTML = `
                                    <div class="metric-name">${key.replace(/_/g, ' ').toUpperCase()}</div>
                                    <div class="metric-value">${value.toFixed(2)}</div>
                                `;
                                container.appendChild(card);
                            }
                        }
                    }
                });
        }

        // Update charts
        function updateCharts() {
            // Update CPU chart
            fetch('/api/historical_metrics/cpu_usage?hours=1')
                .then(response => response.json())
                .then(data => {
                    const labels = data.map(item => new Date(item.timestamp).toLocaleTimeString());
                    const values = data.map(item => item.value);
                    
                    cpuChart.data.labels = labels;
                    cpuChart.data.datasets[0].data = values;
                    cpuChart.update();
                });

            // Update Memory chart
            fetch('/api/historical_metrics/memory_percent?hours=1')
                .then(response => response.json())
                .then(data => {
                    const labels = data.map(item => new Date(item.timestamp).toLocaleTimeString());
                    const values = data.map(item => item.value);
                    
                    memoryChart.data.labels = labels;
                    memoryChart.data.datasets[0].data = values;
                    memoryChart.update();
                });
        }

        // Initial load and set up refresh intervals
        updateCurrentMetrics();
        updateCharts();
        
        setInterval(updateCurrentMetrics, 5000);  // Update every 5 seconds
        setInterval(updateCharts, 30000);  // Update every 30 seconds
    </script>
</body>
</html>
'''

def setup_dashboard():
    """Setup the dashboard templates."""
    templates_dir = 'templates'
    if not os.path.exists(templates_dir):
        os.makedirs(templates_dir)
    
    with open(os.path.join(templates_dir, 'dashboard.html'), 'w') as f:
        f.write(dashboard_html)

def start_dashboard(monitoring_sys, port=5000):
    """Start the web dashboard."""
    global monitoring_system
    monitoring_system = monitoring_sys
    
    setup_dashboard()
    
    print(f"Starting dashboard on http://localhost:{port}")
    app.run(host='0.0.0.0', port=port, debug=False)
```

## 5. Practical Exercises

### Exercise 1: Basic Performance Counter
Create a script that monitors CPU and memory usage for 5 minutes and saves the data to a CSV file.

### Exercise 2: Process Monitoring
Build a tool that monitors specific processes and alerts when they consume too much CPU or memory.

### Exercise 3: Disk Space Monitoring
Create a disk space monitoring system that checks all drives and sends alerts when space is low.

### Exercise 4: Network Performance
Build a network monitoring tool that tracks bandwidth usage and connection statistics.

### Exercise 5: Custom Metrics
Implement a custom performance counter for your application and integrate it with the monitoring system.

## 6. Best Practices

### Performance Monitoring Best Practices
1. **Minimize Monitoring Overhead**: Use efficient collection methods
2. **Set Appropriate Intervals**: Balance accuracy with performance impact
3. **Implement Proper Error Handling**: Handle counter access failures gracefully
4. **Use Batched Operations**: Collect multiple metrics in single operations
5. **Clean Up Resources**: Always close PDH queries and handles
6. **Store Historical Data**: Maintain trends for analysis
7. **Implement Alerting**: Set meaningful thresholds and notifications
8. **Regular Maintenance**: Clean up old data and optimize storage

### Security Considerations
1. **Access Control**: Secure access to performance data
2. **Data Privacy**: Protect sensitive system information
3. **Network Security**: Secure remote monitoring connections
4. **Audit Logging**: Log access to monitoring systems
5. **Credential Management**: Secure storage of authentication credentials

## 7. Common Pitfalls

### PDH-Related Issues
- Not calling `CollectQueryData` before getting values
- Forgetting to close queries and counters
- Using invalid counter paths
- Accessing counters too frequently

### WMI Performance Issues
- Not filtering WMI queries appropriately
- Creating too many WMI connections
- Not handling WMI exceptions properly
- Memory leaks with WMI objects

### Monitoring System Design
- Collecting too much data without analysis
- Not implementing proper data retention policies
- Inadequate error handling and recovery
- Poor alerting threshold configuration

## 8. Capstone Project: Enterprise System Monitor

### Project Overview
Build a comprehensive enterprise-grade system monitoring solution with the following features:

### Requirements
1. **Real-time Monitoring**
   - CPU, memory, disk, and network metrics
   - Process and service monitoring
   - Custom application metrics
   - Real-time dashboard interface

2. **Historical Analysis**
   - Long-term data storage
   - Trend analysis and reporting
   - Performance baseline establishment
   - Capacity planning metrics

3. **Alerting System**
   - Configurable thresholds
   - Multiple notification channels (email, SMS, webhook)
   - Alert escalation and acknowledgment
   - Automated remediation actions

4. **Reporting and Analytics**
   - Daily, weekly, monthly reports
   - Performance trend analysis
   - Capacity utilization reports
   - SLA compliance reporting

5. **Management Interface**
   - Web-based administration console
   - Configuration management
   - User access control
   - System health dashboard

### Implementation Guidelines
1. Use modular design with separate components
2. Implement comprehensive error handling
3. Follow security best practices
4. Include thorough documentation
5. Provide installation and deployment scripts
6. Include unit tests and validation procedures

### Evaluation Criteria
- **Functionality** (30%): All requirements implemented correctly
- **Performance** (25%): Efficient and scalable design
- **Security** (20%): Proper security measures implemented
- **Usability** (15%): User-friendly interface and documentation
- **Code Quality** (10%): Clean, maintainable code structure

## Summary
This module covered advanced Windows performance monitoring using pywin32, including PDH counters, WMI integration, custom metrics, alerting systems, and dashboard development. You learned to build enterprise-grade monitoring solutions with comprehensive data collection, analysis, and reporting capabilities.

### Key Takeaways
1. Performance monitoring requires careful balance between accuracy and overhead
2. PDH provides efficient access to Windows performance counters
3. WMI offers comprehensive system information and event monitoring
4. Custom metrics and alerting enable proactive system management
5. Web dashboards provide real-time visibility into system performance
6. Proper error handling and resource management are critical
7. Security considerations are important for enterprise deployments

### Next Steps
- Explore advanced monitoring frameworks and tools
- Learn about distributed monitoring systems
- Study performance optimization techniques
- Practice with real-world monitoring scenarios
- Contribute to open-source monitoring projects

---

**Estimated Time**: 12-15 hours
**Difficulty**: Advanced
**Prerequisites**: Strong Python knowledge, Windows system administration
**Next Module**: [4.2 Network Operations](./4.2%20Network%20Operations.md)
