# 4.2 Network Operations

## Learning Objectives
By the end of this module, you will:
- Master Windows network programming with pywin32
- Implement network share management and monitoring
- Create internet connectivity and protocol handling solutions
- Build network discovery and asset management tools
- Develop network security and authentication systems
- Create a comprehensive network management suite

## Module Overview
Network operations are fundamental to modern system administration and automation. This module covers advanced network programming using pywin32, including network shares, internet operations, protocol handling, and building scalable network management systems.

### Key pywin32 Modules
- `win32net` - Network resource management
- `win32netcon` - Network constants
- `win32inet` - Internet operations
- `win32wnet` - Windows networking
- `win32security` - Network security
- `socket` - Low-level network operations

## 1. Network Share Management

### Understanding Network Shares
Network shares allow file and resource sharing across the network.

```python
import win32net
import win32netcon
import win32api
import win32security
import win32con
from datetime import datetime
import socket
import subprocess

class NetworkShareManager:
    """Comprehensive network share management."""
    
    def __init__(self, server_name=None):
        """Initialize with optional server name (None for local machine)."""
        self.server_name = server_name
    
    def create_share(self, share_name, path, description="", max_users=-1):
        """Create a new network share.
        
        Args:
            share_name: Name of the share
            path: Local path to share
            description: Description of the share
            max_users: Maximum concurrent users (-1 for unlimited)
        """
        try:
            share_info = {
                'netname': share_name,
                'type': win32netcon.STYPE_DISKTREE,
                'remark': description,
                'permissions': 0,
                'max_uses': max_users,
                'current_uses': 0,
                'path': path,
                'passwd': None
            }
            
            win32net.NetShareAdd(self.server_name, 2, share_info)
            print(f"Share '{share_name}' created successfully")
            return True
            
        except Exception as e:
            print(f"Error creating share: {e}")
            return False
    
    def delete_share(self, share_name):
        """Delete a network share."""
        try:
            win32net.NetShareDel(self.server_name, share_name)
            print(f"Share '{share_name}' deleted successfully")
            return True
            
        except Exception as e:
            print(f"Error deleting share: {e}")
            return False
    
    def list_shares(self):
        """List all network shares."""
        try:
            shares = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetShareEnum(
                        self.server_name, 2, resume_handle
                    )
                    
                    for share in data:
                        share_info = {
                            'name': share['netname'],
                            'path': share['path'],
                            'type': self._get_share_type_name(share['type']),
                            'description': share['remark'],
                            'current_uses': share['current_uses'],
                            'max_uses': share['max_uses'],
                        }
                        shares.append(share_info)
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error listing shares: {e}")
                    break
            
            return shares
            
        except Exception as e:
            print(f"Error in list_shares: {e}")
            return []
    
    def get_share_info(self, share_name):
        """Get detailed information about a specific share."""
        try:
            share_info = win32net.NetShareGetInfo(self.server_name, share_name, 2)
            
            detailed_info = {
                'name': share_info['netname'],
                'path': share_info['path'],
                'type': self._get_share_type_name(share_info['type']),
                'description': share_info['remark'],
                'current_uses': share_info['current_uses'],
                'max_uses': share_info['max_uses'],
                'permissions': share_info['permissions'],
            }
            
            return detailed_info
            
        except Exception as e:
            print(f"Error getting share info: {e}")
            return None
    
    def get_share_connections(self, share_name=None):
        """Get current connections to shares."""
        try:
            connections = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetConnectionEnum(
                        self.server_name, share_name, 1, resume_handle
                    )
                    
                    for conn in data:
                        connection_info = {
                            'connection_id': conn['coni1_id'],
                            'type': conn['coni1_type'],
                            'num_opens': conn['coni1_num_opens'],
                            'num_users': conn['coni1_num_users'],
                            'time': conn['coni1_time'],
                            'username': conn['coni1_username'],
                            'netname': conn['coni1_netname'],
                        }
                        connections.append(connection_info)
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error getting connections: {e}")
                    break
            
            return connections
            
        except Exception as e:
            print(f"Error in get_share_connections: {e}")
            return []
    
    def get_open_files(self, base_path=None, username=None):
        """Get list of open files on shared resources."""
        try:
            open_files = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetFileEnum(
                        self.server_name, base_path, username, 3, resume_handle
                    )
                    
                    for file_info in data:
                        file_data = {
                            'file_id': file_info['fi3_id'],
                            'permissions': file_info['fi3_permissions'],
                            'num_locks': file_info['fi3_num_locks'],
                            'pathname': file_info['fi3_pathname'],
                            'username': file_info['fi3_username'],
                        }
                        open_files.append(file_data)
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error getting open files: {e}")
                    break
            
            return open_files
            
        except Exception as e:
            print(f"Error in get_open_files: {e}")
            return []
    
    def close_file(self, file_id):
        """Close an open file by its ID."""
        try:
            win32net.NetFileClose(self.server_name, file_id)
            print(f"File {file_id} closed successfully")
            return True
            
        except Exception as e:
            print(f"Error closing file: {e}")
            return False
    
    def _get_share_type_name(self, share_type):
        """Convert share type constant to readable name."""
        share_types = {
            win32netcon.STYPE_DISKTREE: "Disk Drive",
            win32netcon.STYPE_PRINTQ: "Print Queue",
            win32netcon.STYPE_DEVICE: "Communication Device",
            win32netcon.STYPE_IPC: "IPC",
            win32netcon.STYPE_SPECIAL: "Special",
        }
        return share_types.get(share_type & 0xFF, "Unknown")

# Example usage
def demo_share_management():
    """Demonstrate network share management."""
    share_manager = NetworkShareManager()
    
    print("=== Network Share Management Demo ===")
    
    # List existing shares
    print("\nCurrent shares:")
    shares = share_manager.list_shares()
    for share in shares:
        print(f"  {share['name']}: {share['path']} ({share['type']})")
    
    # Get connections
    print("\nShare connections:")
    connections = share_manager.get_share_connections()
    for conn in connections:
        print(f"  User: {conn['username']}, Share: {conn['netname']}, Time: {conn['time']}s")
    
    # Get open files
    print("\nOpen files:")
    open_files = share_manager.get_open_files()
    for file_info in open_files:
        print(f"  {file_info['pathname']} (User: {file_info['username']})")

if __name__ == "__main__":
    demo_share_management()
```

### Network Drive Mapping

```python
import win32wnet
import win32netcon
import win32api

class NetworkDriveManager:
    """Manage network drive connections."""
    
    def __init__(self):
        pass
    
    def map_drive(self, local_drive, remote_path, username=None, password=None, persistent=True):
        """Map a network drive.
        
        Args:
            local_drive: Local drive letter (e.g., 'Z:')
            remote_path: UNC path to remote resource
            username: Username for authentication
            password: Password for authentication
            persistent: Whether to reconnect at logon
        """
        try:
            # Prepare network resource info
            net_resource = {
                'dwType': win32netcon.RESOURCETYPE_DISK,
                'lpLocalName': local_drive,
                'lpRemoteName': remote_path,
                'lpProvider': None
            }
            
            # Set connection flags
            flags = 0
            if persistent:
                flags |= win32netcon.CONNECT_UPDATE_PROFILE
            
            # Connect to the network resource
            win32wnet.WNetAddConnection2(
                net_resource,
                password,
                username,
                flags
            )
            
            print(f"Drive {local_drive} mapped to {remote_path}")
            return True
            
        except Exception as e:
            print(f"Error mapping drive: {e}")
            return False
    
    def unmap_drive(self, local_drive, force=False, persistent=True):
        """Unmap a network drive."""
        try:
            flags = 0
            if force:
                flags |= win32netcon.CONNECT_UPDATE_PROFILE
            if persistent:
                flags |= win32netcon.CONNECT_UPDATE_PROFILE
            
            win32wnet.WNetCancelConnection2(local_drive, flags, force)
            print(f"Drive {local_drive} unmapped")
            return True
            
        except Exception as e:
            print(f"Error unmapping drive: {e}")
            return False
    
    def list_mapped_drives(self):
        """List all mapped network drives."""
        try:
            mapped_drives = []
            
            # Enumerate network resources
            handle = win32wnet.WNetOpenEnum(
                win32netcon.RESOURCE_REMEMBERED,
                win32netcon.RESOURCETYPE_DISK,
                0,
                None
            )
            
            try:
                resources = win32wnet.WNetEnumResource(handle, 0)
                
                for resource in resources:
                    drive_info = {
                        'local_name': resource.lpLocalName,
                        'remote_name': resource.lpRemoteName,
                        'provider': resource.lpProvider,
                        'type': 'Disk'
                    }
                    mapped_drives.append(drive_info)
                    
            finally:
                win32wnet.WNetCloseEnum(handle)
            
            return mapped_drives
            
        except Exception as e:
            print(f"Error listing mapped drives: {e}")
            return []
    
    def get_drive_info(self, local_drive):
        """Get information about a specific mapped drive."""
        try:
            # Get the remote name for the local drive
            remote_name = win32wnet.WNetGetConnection(local_drive)
            
            # Get additional information
            drive_info = {
                'local_name': local_drive,
                'remote_name': remote_name,
                'is_connected': True
            }
            
            return drive_info
            
        except Exception as e:
            print(f"Error getting drive info for {local_drive}: {e}")
            return None

# Example usage
def demo_drive_mapping():
    """Demonstrate network drive mapping."""
    drive_manager = NetworkDriveManager()
    
    print("=== Network Drive Management Demo ===")
    
    # List current mapped drives
    print("\nCurrently mapped drives:")
    drives = drive_manager.list_mapped_drives()
    for drive in drives:
        print(f"  {drive['local_name']} -> {drive['remote_name']}")
    
    # Example: Map a drive (uncomment and modify as needed)
    # drive_manager.map_drive('Z:', r'\\server\share', 'username', 'password')
    
    # Example: Get specific drive info
    # info = drive_manager.get_drive_info('Z:')
    # if info:
    #     print(f"Drive Z: -> {info['remote_name']}")

if __name__ == "__main__":
    demo_drive_mapping()
```

## 2. Internet Operations and Connectivity

### Internet Connectivity Testing

```python
import win32inet
import win32api
import urllib.request
import urllib.error
import socket
import time
import threading
from datetime import datetime
import json

class InternetConnectivityMonitor:
    """Monitor internet connectivity and performance."""
    
    def __init__(self):
        self.test_urls = [
            'http://www.google.com',
            'http://www.microsoft.com',
            'http://www.cloudflare.com',
            'http://8.8.8.8'  # Google DNS
        ]
        self.dns_servers = [
            '8.8.8.8',      # Google DNS
            '1.1.1.1',      # Cloudflare DNS
            '208.67.222.222' # OpenDNS
        ]
    
    def check_internet_connection(self):
        """Check if internet connection is available."""
        try:
            # Use Windows API to check connectivity
            connected = win32inet.InternetCheckConnection(
                'http://www.microsoft.com', 
                win32inet.FLAG_ICC_FORCE_CONNECTION, 
                0
            )
            return connected
            
        except Exception as e:
            print(f"Error checking connection: {e}")
            return False
    
    def test_url_connectivity(self, url, timeout=10):
        """Test connectivity to a specific URL."""
        try:
            start_time = time.time()
            
            with urllib.request.urlopen(url, timeout=timeout) as response:
                response_time = (time.time() - start_time) * 1000  # Convert to ms
                
                result = {
                    'url': url,
                    'status_code': response.getcode(),
                    'response_time_ms': response_time,
                    'success': True,
                    'timestamp': datetime.now().isoformat(),
                    'error': None
                }
                
                return result
                
        except urllib.error.URLError as e:
            return {
                'url': url,
                'status_code': None,
                'response_time_ms': None,
                'success': False,
                'timestamp': datetime.now().isoformat(),
                'error': str(e)
            }
        except Exception as e:
            return {
                'url': url,
                'status_code': None,
                'response_time_ms': None,
                'success': False,
                'timestamp': datetime.now().isoformat(),
                'error': str(e)
            }
    
    def test_dns_resolution(self, hostname, dns_server=None):
        """Test DNS resolution for a hostname."""
        try:
            start_time = time.time()
            
            if dns_server:
                # Configure custom DNS server
                original_dns = socket.getdefaulttimeout()
                socket.setdefaulttimeout(5)
                
                try:
                    # This is a simplified approach - in practice you'd use dnspython
                    ip_address = socket.gethostbyname(hostname)
                finally:
                    socket.setdefaulttimeout(original_dns)
            else:
                ip_address = socket.gethostbyname(hostname)
            
            resolution_time = (time.time() - start_time) * 1000
            
            return {
                'hostname': hostname,
                'ip_address': ip_address,
                'dns_server': dns_server or 'system',
                'resolution_time_ms': resolution_time,
                'success': True,
                'timestamp': datetime.now().isoformat(),
                'error': None
            }
            
        except Exception as e:
            return {
                'hostname': hostname,
                'ip_address': None,
                'dns_server': dns_server or 'system',
                'resolution_time_ms': None,
                'success': False,
                'timestamp': datetime.now().isoformat(),
                'error': str(e)
            }
    
    def ping_host(self, hostname, count=4):
        """Ping a host and return statistics."""
        try:
            import subprocess
            
            # Use Windows ping command
            result = subprocess.run(
                ['ping', '-n', str(count), hostname],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            output = result.stdout
            ping_stats = {
                'hostname': hostname,
                'packets_sent': count,
                'packets_received': 0,
                'packet_loss_percent': 100,
                'min_time_ms': None,
                'max_time_ms': None,
                'avg_time_ms': None,
                'success': False,
                'timestamp': datetime.now().isoformat(),
                'raw_output': output
            }
            
            # Parse ping output (simplified parsing)
            lines = output.split('\n')
            for line in lines:
                if 'Packets:' in line:
                    # Parse packet statistics
                    parts = line.split(',')
                    for part in parts:
                        if 'Received' in part:
                            ping_stats['packets_received'] = int(part.split('=')[1].strip())
                        elif 'Lost' in part:
                            loss_info = part.split('(')[1].split('%')[0]
                            ping_stats['packet_loss_percent'] = int(loss_info)
                
                elif 'Minimum' in line:
                    # Parse timing statistics
                    times = line.split(',')
                    for time_stat in times:
                        if 'Minimum' in time_stat:
                            ping_stats['min_time_ms'] = int(time_stat.split('=')[1].strip().replace('ms', ''))
                        elif 'Maximum' in time_stat:
                            ping_stats['max_time_ms'] = int(time_stat.split('=')[1].strip().replace('ms', ''))
                        elif 'Average' in time_stat:
                            ping_stats['avg_time_ms'] = int(time_stat.split('=')[1].strip().replace('ms', ''))
            
            ping_stats['success'] = ping_stats['packets_received'] > 0
            return ping_stats
            
        except Exception as e:
            return {
                'hostname': hostname,
                'packets_sent': count,
                'packets_received': 0,
                'packet_loss_percent': 100,
                'success': False,
                'timestamp': datetime.now().isoformat(),
                'error': str(e)
            }
    
    def comprehensive_connectivity_test(self):
        """Run a comprehensive connectivity test."""
        test_results = {
            'timestamp': datetime.now().isoformat(),
            'internet_connection': self.check_internet_connection(),
            'url_tests': [],
            'dns_tests': [],
            'ping_tests': []
        }
        
        # Test URLs
        print("Testing URL connectivity...")
        for url in self.test_urls:
            result = self.test_url_connectivity(url)
            test_results['url_tests'].append(result)
            print(f"  {url}: {'SUCCESS' if result['success'] else 'FAILED'} "
                  f"({result['response_time_ms']}ms)" if result['success'] else f"({result['error']})")
        
        # Test DNS resolution
        print("\nTesting DNS resolution...")
        test_hostnames = ['google.com', 'microsoft.com', 'github.com']
        for hostname in test_hostnames:
            result = self.test_dns_resolution(hostname)
            test_results['dns_tests'].append(result)
            print(f"  {hostname}: {'SUCCESS' if result['success'] else 'FAILED'} "
                  f"({result['ip_address']})" if result['success'] else f"({result['error']})")
        
        # Test ping
        print("\nTesting ping connectivity...")
        ping_hosts = ['8.8.8.8', 'google.com', 'microsoft.com']
        for host in ping_hosts:
            result = self.ping_host(host)
            test_results['ping_tests'].append(result)
            print(f"  {host}: {'SUCCESS' if result['success'] else 'FAILED'} "
                  f"(avg: {result['avg_time_ms']}ms, loss: {result['packet_loss_percent']}%)" 
                  if result['success'] else f"({result.get('error', 'Failed')})")
        
        return test_results

# Example usage
def demo_connectivity_monitoring():
    """Demonstrate internet connectivity monitoring."""
    monitor = InternetConnectivityMonitor()
    
    print("=== Internet Connectivity Monitor Demo ===")
    
    # Run comprehensive test
    results = monitor.comprehensive_connectivity_test()
    
    # Summary
    print(f"\n=== Test Summary ===")
    print(f"Internet Connection: {'CONNECTED' if results['internet_connection'] else 'DISCONNECTED'}")
    
    url_success = sum(1 for test in results['url_tests'] if test['success'])
    print(f"URL Tests: {url_success}/{len(results['url_tests'])} successful")
    
    dns_success = sum(1 for test in results['dns_tests'] if test['success'])
    print(f"DNS Tests: {dns_success}/{len(results['dns_tests'])} successful")
    
    ping_success = sum(1 for test in results['ping_tests'] if test['success'])
    print(f"Ping Tests: {ping_success}/{len(results['ping_tests'])} successful")

if __name__ == "__main__":
    demo_connectivity_monitoring()
```

### HTTP Client Operations

```python
import win32inet
import urllib.request
import urllib.parse
import json
import base64
from datetime import datetime

class HTTPClientManager:
    """Advanced HTTP client operations using Windows APIs."""
    
    def __init__(self, user_agent="PyWin32 HTTP Client"):
        self.user_agent = user_agent
        self.session_cookies = {}
    
    def create_internet_session(self):
        """Create an internet session using WinINet."""
        try:
            session = win32inet.InternetOpen(
                self.user_agent,
                win32inet.INTERNET_OPEN_TYPE_PRECONFIG,
                None,
                None,
                0
            )
            return session
            
        except Exception as e:
            print(f"Error creating internet session: {e}")
            return None
    
    def http_request(self, url, method='GET', headers=None, data=None, auth=None):
        """Make HTTP request using WinINet."""
        session = None
        connection = None
        request = None
        
        try:
            # Parse URL
            parsed_url = urllib.parse.urlparse(url)
            
            # Create internet session
            session = self.create_internet_session()
            if not session:
                return None
            
            # Create connection
            port = parsed_url.port
            if not port:
                port = 443 if parsed_url.scheme == 'https' else 80
            
            connection = win32inet.InternetConnect(
                session,
                parsed_url.hostname,
                port,
                None,  # username
                None,  # password
                win32inet.INTERNET_SERVICE_HTTP,
                0,
                0
            )
            
            # Set flags for HTTPS
            flags = 0
            if parsed_url.scheme == 'https':
                flags = win32inet.INTERNET_FLAG_SECURE
            
            # Create HTTP request
            request = win32inet.HttpOpenRequest(
                connection,
                method,
                parsed_url.path + ('?' + parsed_url.query if parsed_url.query else ''),
                None,  # version
                None,  # referrer
                None,  # accept types
                flags,
                0
            )
            
            # Add headers
            if headers:
                header_string = '\r\n'.join([f"{k}: {v}" for k, v in headers.items()])
                win32inet.HttpAddRequestHeaders(request, header_string, 0)
            
            # Add authentication
            if auth:
                auth_string = base64.b64encode(f"{auth[0]}:{auth[1]}".encode()).decode()
                win32inet.HttpAddRequestHeaders(
                    request, 
                    f"Authorization: Basic {auth_string}", 
                    0
                )
            
            # Send request
            win32inet.HttpSendRequest(request, None, data)
            
            # Get response
            response_data = b""
            while True:
                chunk = win32inet.InternetReadFile(request, 8192)
                if not chunk:
                    break
                response_data += chunk
            
            # Get status code
            status_code = win32inet.HttpQueryInfo(
                request, 
                win32inet.HTTP_QUERY_STATUS_CODE
            )
            
            return {
                'status_code': int(status_code),
                'data': response_data,
                'success': True
            }
            
        except Exception as e:
            return {
                'status_code': None,
                'data': None,
                'success': False,
                'error': str(e)
            }
        
        finally:
            # Clean up handles
            if request:
                win32inet.InternetCloseHandle(request)
            if connection:
                win32inet.InternetCloseHandle(connection)
            if session:
                win32inet.InternetCloseHandle(session)
    
    def download_file(self, url, local_path, progress_callback=None):
        """Download a file from URL to local path."""
        try:
            def progress_hook(block_num, block_size, total_size):
                if progress_callback and total_size > 0:
                    percent = min(100, (block_num * block_size * 100) // total_size)
                    progress_callback(percent, block_num * block_size, total_size)
            
            urllib.request.urlretrieve(url, local_path, progress_hook)
            
            return {
                'success': True,
                'local_path': local_path,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def upload_file(self, url, file_path, field_name='file', additional_data=None):
        """Upload a file using multipart/form-data."""
        try:
            import mimetypes
            
            # Determine MIME type
            mime_type, _ = mimetypes.guess_type(file_path)
            if not mime_type:
                mime_type = 'application/octet-stream'
            
            # Read file data
            with open(file_path, 'rb') as f:
                file_data = f.read()
            
            # Create multipart data
            boundary = f"----formdata-pywin32-{int(time.time())}"
            
            form_data = []
            
            # Add additional form fields
            if additional_data:
                for key, value in additional_data.items():
                    form_data.append(f"--{boundary}")
                    form_data.append(f'Content-Disposition: form-data; name="{key}"')
                    form_data.append("")
                    form_data.append(str(value))
            
            # Add file data
            form_data.append(f"--{boundary}")
            form_data.append(f'Content-Disposition: form-data; name="{field_name}"; filename="{file_path}"')
            form_data.append(f"Content-Type: {mime_type}")
            form_data.append("")
            
            # Convert to bytes
            header_data = '\r\n'.join(form_data).encode() + b'\r\n'
            footer_data = f'\r\n--{boundary}--\r\n'.encode()
            
            post_data = header_data + file_data + footer_data
            
            # Set headers
            headers = {
                'Content-Type': f'multipart/form-data; boundary={boundary}',
                'Content-Length': str(len(post_data))
            }
            
            # Send request
            result = self.http_request(url, 'POST', headers, post_data)
            
            return result
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }

# Example usage
def demo_http_operations():
    """Demonstrate HTTP client operations."""
    client = HTTPClientManager()
    
    print("=== HTTP Client Operations Demo ===")
    
    # Simple GET request
    print("\nTesting GET request...")
    result = client.http_request('http://httpbin.org/get')
    if result['success']:
        print(f"Status: {result['status_code']}")
        print(f"Response length: {len(result['data'])} bytes")
    else:
        print(f"Error: {result.get('error')}")
    
    # POST request with data
    print("\nTesting POST request...")
    post_data = json.dumps({'test': 'data'}).encode()
    headers = {'Content-Type': 'application/json'}
    result = client.http_request('http://httpbin.org/post', 'POST', headers, post_data)
    if result['success']:
        print(f"Status: {result['status_code']}")
        print(f"Response length: {len(result['data'])} bytes")
    else:
        print(f"Error: {result.get('error')}")

if __name__ == "__main__":
    demo_http_operations()
```

## 3. Network Discovery and Asset Management

### Network Scanner

```python
import socket
import threading
import subprocess
import ipaddress
import time
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import json

class NetworkScanner:
    """Network discovery and asset scanning."""
    
    def __init__(self, max_threads=50):
        self.max_threads = max_threads
        self.discovered_hosts = []
        self.scan_results = {}
    
    def ping_host(self, ip_address, timeout=1):
        """Ping a single host."""
        try:
            result = subprocess.run(
                ['ping', '-n', '1', '-w', str(timeout * 1000), str(ip_address)],
                capture_output=True,
                text=True,
                timeout=timeout + 1
            )
            
            return {
                'ip': str(ip_address),
                'reachable': result.returncode == 0,
                'response_time': self._parse_ping_time(result.stdout) if result.returncode == 0 else None,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'ip': str(ip_address),
                'reachable': False,
                'response_time': None,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def _parse_ping_time(self, ping_output):
        """Parse ping response time from output."""
        try:
            for line in ping_output.split('\n'):
                if 'time=' in line:
                    time_part = line.split('time=')[1].split('ms')[0]
                    return float(time_part)
            return None
        except:
            return None
    
    def scan_network_range(self, network_cidr, timeout=1):
        """Scan a network range for reachable hosts."""
        try:
            network = ipaddress.IPv4Network(network_cidr, strict=False)
            
            print(f"Scanning network {network_cidr} ({network.num_addresses} addresses)...")
            
            reachable_hosts = []
            
            def scan_host(ip):
                result = self.ping_host(ip, timeout)
                if result['reachable']:
                    reachable_hosts.append(result)
                    print(f"  Found: {result['ip']} ({result['response_time']}ms)")
                return result
            
            # Use thread pool for concurrent scanning
            with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                futures = [executor.submit(scan_host, ip) for ip in network.hosts()]
                
                # Wait for all scans to complete
                for future in futures:
                    future.result()
            
            self.discovered_hosts = reachable_hosts
            return reachable_hosts
            
        except Exception as e:
            print(f"Error scanning network: {e}")
            return []
    
    def port_scan(self, ip_address, ports, timeout=1):
        """Scan specific ports on a host."""
        open_ports = []
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((str(ip_address), port))
                sock.close()
                
                if result == 0:
                    return port
                return None
                
            except Exception:
                return None
        
        print(f"Port scanning {ip_address}...")
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            futures = [executor.submit(scan_port, port) for port in ports]
            
            for future in futures:
                result = future.result()
                if result:
                    open_ports.append(result)
                    print(f"  Port {result} is open")
        
        return open_ports
    
    def get_hostname(self, ip_address):
        """Get hostname for an IP address."""
        try:
            hostname, _, _ = socket.gethostbyaddr(str(ip_address))
            return hostname
        except Exception:
            return None
    
    def get_mac_address(self, ip_address):
        """Get MAC address for an IP address using ARP."""
        try:
            # Use ARP to get MAC address
            result = subprocess.run(
                ['arp', '-a', str(ip_address)],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if str(ip_address) in line:
                        parts = line.split()
                        for part in parts:
                            if '-' in part and len(part) == 17:  # MAC format xx-xx-xx-xx-xx-xx
                                return part.replace('-', ':')
            
            return None
            
        except Exception:
            return None
    
    def comprehensive_host_scan(self, ip_address):
        """Perform comprehensive scan of a single host."""
        print(f"Comprehensive scan of {ip_address}...")
        
        # Basic connectivity
        ping_result = self.ping_host(ip_address)
        
        if not ping_result['reachable']:
            return {
                'ip': str(ip_address),
                'reachable': False,
                'timestamp': datetime.now().isoformat()
            }
        
        # Get hostname
        hostname = self.get_hostname(ip_address)
        
        # Get MAC address
        mac_address = self.get_mac_address(ip_address)
        
        # Common ports to scan
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 3389, 5432]
        
        # Port scan
        open_ports = self.port_scan(ip_address, common_ports)
        
        # Service identification (basic)
        services = self._identify_services(open_ports)
        
        host_info = {
            'ip': str(ip_address),
            'hostname': hostname,
            'mac_address': mac_address,
            'reachable': True,
            'response_time': ping_result['response_time'],
            'open_ports': open_ports,
            'services': services,
            'timestamp': datetime.now().isoformat()
        }
        
        return host_info
    
    def _identify_services(self, open_ports):
        """Basic service identification based on common ports."""
        service_map = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            135: 'RPC',
            139: 'NetBIOS',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S',
            1433: 'SQL Server',
            3389: 'RDP',
            5432: 'PostgreSQL'
        }
        
        services = []
        for port in open_ports:
            service_name = service_map.get(port, f'Unknown (Port {port})')
            services.append({
                'port': port,
                'service': service_name
            })
        
        return services
    
    def scan_and_inventory_network(self, network_cidr):
        """Complete network inventory scan."""
        print(f"Starting complete network inventory for {network_cidr}")
        
        # First, discover reachable hosts
        reachable_hosts = self.scan_network_range(network_cidr)
        
        # Then perform comprehensive scan on each host
        inventory = []
        
        for host in reachable_hosts:
            host_info = self.comprehensive_host_scan(host['ip'])
            inventory.append(host_info)
        
        # Save results
        self.scan_results = {
            'network': network_cidr,
            'scan_date': datetime.now().isoformat(),
            'total_hosts_scanned': len(list(ipaddress.IPv4Network(network_cidr, strict=False).hosts())),
            'reachable_hosts': len(reachable_hosts),
            'inventory': inventory
        }
        
        return self.scan_results
    
    def generate_report(self, output_file=None):
        """Generate a network inventory report."""
        if not self.scan_results:
            print("No scan results available")
            return
        
        report = {
            'summary': {
                'network': self.scan_results['network'],
                'scan_date': self.scan_results['scan_date'],
                'total_addresses': self.scan_results['total_hosts_scanned'],
                'reachable_hosts': self.scan_results['reachable_hosts'],
                'unreachable_hosts': self.scan_results['total_hosts_scanned'] - self.scan_results['reachable_hosts']
            },
            'hosts': self.scan_results['inventory']
        }
        
        # Service summary
        service_count = {}
        for host in self.scan_results['inventory']:
            for service in host.get('services', []):
                service_name = service['service']
                service_count[service_name] = service_count.get(service_name, 0) + 1
        
        report['service_summary'] = service_count
        
        if output_file:
            with open(output_file, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"Report saved to {output_file}")
        
        return report

# Example usage
def demo_network_scanning():
    """Demonstrate network scanning capabilities."""
    scanner = NetworkScanner(max_threads=20)
    
    print("=== Network Scanner Demo ===")
    
    # Scan local network (modify as appropriate)
    network = "192.168.1.0/24"  # Change to your network
    
    # Perform comprehensive network scan
    results = scanner.scan_and_inventory_network(network)
    
    # Generate and display report
    report = scanner.generate_report("network_inventory.json")
    
    print(f"\n=== Scan Summary ===")
    print(f"Network: {report['summary']['network']}")
    print(f"Total addresses scanned: {report['summary']['total_addresses']}")
    print(f"Reachable hosts: {report['summary']['reachable_hosts']}")
    print(f"Unreachable hosts: {report['summary']['unreachable_hosts']}")
    
    print(f"\n=== Service Summary ===")
    for service, count in report['service_summary'].items():
        print(f"  {service}: {count} hosts")
    
    print(f"\n=== Host Details ===")
    for host in report['hosts']:
        print(f"  {host['ip']} ({host.get('hostname', 'Unknown')})")
        print(f"    MAC: {host.get('mac_address', 'Unknown')}")
        print(f"    Open ports: {', '.join(map(str, host['open_ports']))}")

if __name__ == "__main__":
    demo_network_scanning()
```

## 4. Network Security and Authentication

### Network Authentication Manager

```python
import win32security
import win32net
import win32netcon
import win32api
import win32con
from datetime import datetime, timedelta
import json

class NetworkAuthenticationManager:
    """Manage network authentication and security."""
    
    def __init__(self, domain=None):
        self.domain = domain
    
    def authenticate_user(self, username, password, domain=None):
        """Authenticate a user against the domain/local machine."""
        try:
            target_domain = domain or self.domain or "."
            
            # Try to log on the user
            handle = win32security.LogonUser(
                username,
                target_domain,
                password,
                win32con.LOGON32_LOGON_NETWORK,
                win32con.LOGON32_PROVIDER_DEFAULT
            )
            
            if handle:
                win32api.CloseHandle(handle)
                return {
                    'success': True,
                    'username': username,
                    'domain': target_domain,
                    'timestamp': datetime.now().isoformat()
                }
            
        except Exception as e:
            return {
                'success': False,
                'username': username,
                'domain': target_domain,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def get_user_groups(self, username, domain=None):
        """Get groups for a user."""
        try:
            target_domain = domain or self.domain
            
            groups = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetUserGetGroups(
                        target_domain, username, 0, resume_handle
                    )
                    
                    for group in data:
                        groups.append(group['name'])
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error getting user groups: {e}")
                    break
            
            return groups
            
        except Exception as e:
            print(f"Error in get_user_groups: {e}")
            return []
    
    def get_user_info(self, username, domain=None):
        """Get detailed user information."""
        try:
            target_domain = domain or self.domain
            
            user_info = win32net.NetUserGetInfo(target_domain, username, 3)
            
            detailed_info = {
                'username': user_info['name'],
                'full_name': user_info['full_name'],
                'comment': user_info['comment'],
                'user_comment': user_info['usr_comment'],
                'flags': user_info['flags'],
                'script_path': user_info['script_path'],
                'home_dir': user_info['home_dir'],
                'home_dir_drive': user_info['home_dir_drive'],
                'password_age': user_info['password_age'],
                'password_expired': user_info['password_expired'],
                'account_disabled': bool(user_info['flags'] & win32netcon.UF_ACCOUNTDISABLE),
                'password_required': bool(user_info['flags'] & win32netcon.UF_PASSWD_NOTREQD) == False,
                'last_logon': str(user_info['last_logon']) if user_info['last_logon'] else None,
                'last_logoff': str(user_info['last_logoff']) if user_info['last_logoff'] else None,
                'num_logons': user_info['num_logons'],
                'workstations': user_info['workstations'],
                'max_storage': user_info['max_storage'],
                'country_code': user_info['country_code'],
                'code_page': user_info['code_page'],
                'primary_group_id': user_info['primary_group_id'],
                'profile': user_info['profile'],
                'acct_expires': str(user_info['acct_expires']) if user_info['acct_expires'] else None,
            }
            
            # Get groups
            detailed_info['groups'] = self.get_user_groups(username, target_domain)
            
            return detailed_info
            
        except Exception as e:
            print(f"Error getting user info: {e}")
            return None
    
    def list_domain_users(self, domain=None):
        """List all users in the domain/local machine."""
        try:
            target_domain = domain or self.domain
            
            users = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetUserEnum(
                        target_domain, 0, win32netcon.FILTER_NORMAL_ACCOUNT, resume_handle
                    )
                    
                    for user in data:
                        users.append(user['name'])
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error listing users: {e}")
                    break
            
            return users
            
        except Exception as e:
            print(f"Error in list_domain_users: {e}")
            return []
    
    def list_domain_groups(self, domain=None):
        """List all groups in the domain/local machine."""
        try:
            target_domain = domain or self.domain
            
            groups = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetGroupEnum(
                        target_domain, 0, resume_handle
                    )
                    
                    for group in data:
                        group_info = {
                            'name': group['name'],
                            'comment': group['comment']
                        }
                        groups.append(group_info)
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error listing groups: {e}")
                    break
            
            return groups
            
        except Exception as e:
            print(f"Error in list_domain_groups: {e}")
            return []
    
    def get_group_members(self, group_name, domain=None):
        """Get members of a specific group."""
        try:
            target_domain = domain or self.domain
            
            members = []
            resume_handle = 0
            
            while True:
                try:
                    data, total, resume_handle = win32net.NetGroupGetUsers(
                        target_domain, group_name, 0, resume_handle
                    )
                    
                    for member in data:
                        members.append(member['name'])
                    
                    if resume_handle == 0:
                        break
                        
                except Exception as e:
                    print(f"Error getting group members: {e}")
                    break
            
            return members
            
        except Exception as e:
            print(f"Error in get_group_members: {e}")
            return []
    
    def check_user_permissions(self, username, resource_path, domain=None):
        """Check user permissions on a resource."""
        try:
            # This is a simplified version - real implementation would be more complex
            target_domain = domain or self.domain
            
            # Get user SID
            user_sid = win32security.LookupAccountName(target_domain, username)[0]
            
            # Get security descriptor for the resource
            sd = win32security.GetFileSecurity(
                resource_path, 
                win32security.DACL_SECURITY_INFORMATION
            )
            
            # Get DACL
            dacl = sd.GetSecurityDescriptorDacl()
            
            permissions = {
                'read': False,
                'write': False,
                'execute': False,
                'full_control': False
            }
            
            # Check each ACE in the DACL
            for i in range(dacl.GetAceCount()):
                ace = dacl.GetAce(i)
                ace_type, ace_flags, ace_mask, ace_sid = ace
                
                if ace_sid == user_sid:
                    # Check specific permissions
                    if ace_mask & win32con.GENERIC_READ:
                        permissions['read'] = True
                    if ace_mask & win32con.GENERIC_WRITE:
                        permissions['write'] = True
                    if ace_mask & win32con.GENERIC_EXECUTE:
                        permissions['execute'] = True
                    if ace_mask & win32con.GENERIC_ALL:
                        permissions['full_control'] = True
            
            return permissions
            
        except Exception as e:
            print(f"Error checking permissions: {e}")
            return None
    
    def generate_security_report(self, domain=None):
        """Generate a comprehensive security report."""
        target_domain = domain or self.domain or "."
        
        report = {
            'domain': target_domain,
            'generation_time': datetime.now().isoformat(),
            'users': [],
            'groups': [],
            'security_analysis': {}
        }
        
        print(f"Generating security report for {target_domain}...")
        
        # Get all users
        users = self.list_domain_users(target_domain)
        for username in users:
            user_info = self.get_user_info(username, target_domain)
            if user_info:
                report['users'].append(user_info)
        
        # Get all groups
        groups = self.list_domain_groups(target_domain)
        for group in groups:
            group_members = self.get_group_members(group['name'], target_domain)
            group['members'] = group_members
            group['member_count'] = len(group_members)
            report['groups'].append(group)
        
        # Security analysis
        disabled_users = [u for u in report['users'] if u['account_disabled']]
        users_no_password = [u for u in report['users'] if not u['password_required']]
        admin_users = []
        
        for user in report['users']:
            if 'Administrators' in user.get('groups', []):
                admin_users.append(user['username'])
        
        report['security_analysis'] = {
            'total_users': len(report['users']),
            'total_groups': len(report['groups']),
            'disabled_accounts': len(disabled_users),
            'accounts_no_password': len(users_no_password),
            'administrative_accounts': len(admin_users),
            'disabled_account_list': [u['username'] for u in disabled_users],
            'no_password_list': [u['username'] for u in users_no_password],
            'admin_account_list': admin_users
        }
        
        return report

# Example usage
def demo_network_authentication():
    """Demonstrate network authentication management."""
    auth_manager = NetworkAuthenticationManager()
    
    print("=== Network Authentication Manager Demo ===")
    
    # List users
    print("\nLocal users:")
    users = auth_manager.list_domain_users()
    for user in users[:5]:  # Show first 5 users
        print(f"  {user}")
    
    # List groups
    print("\nLocal groups:")
    groups = auth_manager.list_domain_groups()
    for group in groups[:5]:  # Show first 5 groups
        print(f"  {group['name']}: {group['comment']}")
    
    # Generate security report
    print("\nGenerating security report...")
    report = auth_manager.generate_security_report()
    
    print(f"Security Analysis:")
    print(f"  Total users: {report['security_analysis']['total_users']}")
    print(f"  Total groups: {report['security_analysis']['total_groups']}")
    print(f"  Disabled accounts: {report['security_analysis']['disabled_accounts']}")
    print(f"  Accounts without password requirement: {report['security_analysis']['accounts_no_password']}")
    print(f"  Administrative accounts: {report['security_analysis']['administrative_accounts']}")

if __name__ == "__main__":
    demo_network_authentication()
```

## 5. Practical Exercises

### Exercise 1: Network Share Monitor
Create a tool that monitors network share usage and generates alerts when shares become unavailable or when unusual access patterns are detected.

### Exercise 2: Internet Connectivity Dashboard
Build a real-time dashboard that monitors internet connectivity, DNS resolution times, and website response times.

### Exercise 3: Network Asset Discovery
Implement a network asset discovery tool that automatically scans and maintains an inventory of network devices and their services.

### Exercise 4: Bandwidth Monitor
Create a network bandwidth monitoring tool that tracks usage by application and generates reports.

### Exercise 5: Network Security Auditor
Build a comprehensive network security auditing tool that checks for common vulnerabilities and misconfigurations.

## 6. Best Practices

### Network Programming Best Practices
1. **Error Handling**: Always implement comprehensive error handling
2. **Timeouts**: Set appropriate timeouts for network operations
3. **Resource Cleanup**: Close network handles and connections properly
4. **Security**: Use secure authentication and encryption where possible
5. **Performance**: Implement connection pooling and efficient scanning
6. **Logging**: Log all network operations and errors
7. **Rate Limiting**: Implement rate limiting to avoid overwhelming network resources
8. **Monitoring**: Continuously monitor network health and performance

### Security Considerations
1. **Authentication**: Always authenticate network access
2. **Encryption**: Use encrypted connections when possible
3. **Access Control**: Implement proper access controls
4. **Audit Logging**: Log all security-related events
5. **Principle of Least Privilege**: Grant minimum necessary permissions
6. **Regular Updates**: Keep network security tools updated
7. **Vulnerability Scanning**: Regularly scan for security vulnerabilities

## 7. Common Pitfalls

### Network Programming Issues
- Not handling network timeouts properly
- Failing to clean up network resources
- Not implementing proper error handling
- Overwhelming targets with too many concurrent connections
- Ignoring security implications of network operations

### Authentication Problems
- Storing credentials insecurely
- Not handling authentication failures gracefully
- Failing to implement proper session management
- Not validating user permissions adequately

### Performance Issues
- Using blocking operations inappropriately
- Not implementing connection pooling
- Scanning networks too aggressively
- Not optimizing network discovery algorithms

## 8. Capstone Project: Network Management Suite

### Project Overview
Build a comprehensive network management suite with the following components:

### Requirements
1. **Network Discovery**
   - Automatic network scanning and device discovery
   - Service identification and port scanning
   - Network topology mapping
   - Asset inventory management

2. **Connectivity Monitoring**
   - Real-time internet connectivity monitoring
   - DNS resolution time tracking
   - Website/service availability monitoring
   - Network performance metrics

3. **Share Management**
   - Network share creation and management
   - Access monitoring and logging
   - Usage statistics and reporting
   - Security auditing

4. **Security Management**
   - User and group management
   - Permission auditing
   - Security vulnerability scanning
   - Compliance reporting

5. **Reporting and Alerting**
   - Real-time dashboard interface
   - Automated report generation
   - Email/SMS alerting system
   - Historical trend analysis

### Implementation Guidelines
1. Use modular design with separate components for each feature
2. Implement comprehensive error handling and logging
3. Follow network security best practices
4. Include configuration management system
5. Provide web-based management interface
6. Include automated installation and setup

### Evaluation Criteria
- **Functionality** (30%): All components work correctly
- **Performance** (25%): Efficient network operations
- **Security** (20%): Proper security implementation
- **Usability** (15%): User-friendly interface
- **Documentation** (10%): Comprehensive documentation

## Summary
This module covered advanced Windows network programming using pywin32, including network share management, internet operations, network discovery, and security management. You learned to build comprehensive network management solutions with monitoring, alerting, and reporting capabilities.

### Key Takeaways
1. Network programming requires careful error handling and resource management
2. Security should be built into all network operations
3. Performance monitoring and optimization are critical for network tools
4. Comprehensive logging and reporting improve network management
5. Automation reduces manual network administration overhead
6. Regular security auditing is essential for network health
7. User-friendly interfaces improve tool adoption and effectiveness

### Next Steps
- Explore advanced network protocols and services
- Learn about network automation frameworks
- Study network security best practices
- Practice with real-world network scenarios
- Contribute to open-source network management projects

---

**Estimated Time**: 12-15 hours
**Difficulty**: Advanced
**Prerequisites**: Network concepts, Windows administration, Python networking
**Next Module**: [4.3 Windows Service Development](./4.3%20Windows%20Service%20Development.md)
