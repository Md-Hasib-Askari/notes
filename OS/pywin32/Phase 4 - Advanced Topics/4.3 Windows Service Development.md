# 4.3 Windows Service Development

## Learning Objectives
By the end of this module, you will:
- Master Windows service architecture and development
- Create robust and scalable Windows services
- Implement service control, debugging, and recovery mechanisms
- Build service frameworks with dependency management
- Develop enterprise-grade monitoring and management services
- Create comprehensive service deployment and maintenance solutions

## Module Overview
Windows services are background applications that run without user interaction, providing essential system functionality. This module covers advanced service development using pywin32, including service architecture, lifecycle management, debugging, recovery mechanisms, and building scalable service frameworks.

### Key pywin32 Modules
- `win32service` - Core service control and management
- `win32serviceutil` - Service utilities and helpers
- `servicemanager` - Service manager integration
- `win32event` - Event handling for services
- `win32api` - System API functions
- `winerror` - Windows error handling

## 1. Service Architecture and Fundamentals

### Understanding Windows Services
Windows services are applications that run in the background and can start automatically when the system boots.

```python
import win32service
import win32serviceutil
import win32event
import win32api
import servicemanager
import logging
import threading
import time
import os
import sys
from datetime import datetime
import json
import configparser

class BaseWindowsService(win32serviceutil.ServiceFramework):
    """Base class for Windows services with common functionality."""
    
    # Service information - override in subclasses
    _svc_name_ = "BaseService"
    _svc_display_name_ = "Base Windows Service"
    _svc_description_ = "Base service framework for Windows applications"
    
    def __init__(self, args):
        """Initialize the service."""
        win32serviceutil.ServiceFramework.__init__(self, args)
        
        # Create event for service shutdown
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        
        # Service state
        self.is_running = False
        self.is_stopping = False
        
        # Configuration
        self.config = {}
        self.load_configuration()
        
        # Setup logging
        self.setup_logging()
        
        # Initialize service-specific components
        self.initialize_service()
    
    def load_configuration(self):
        """Load service configuration from file."""
        try:
            config_file = os.path.join(
                os.path.dirname(__file__), 
                f"{self._svc_name_.lower()}.ini"
            )
            
            if os.path.exists(config_file):
                config_parser = configparser.ConfigParser()
                config_parser.read(config_file)
                
                # Convert to dictionary
                for section in config_parser.sections():
                    self.config[section] = dict(config_parser.items(section))
            else:
                # Default configuration
                self.config = {
                    'service': {
                        'check_interval': '30',
                        'max_threads': '10',
                        'log_level': 'INFO'
                    }
                }
                self.save_configuration()
                
        except Exception as e:
            servicemanager.LogErrorMsg(f"Error loading configuration: {e}")
            self.config = {}
    
    def save_configuration(self):
        """Save current configuration to file."""
        try:
            config_file = os.path.join(
                os.path.dirname(__file__), 
                f"{self._svc_name_.lower()}.ini"
            )
            
            config_parser = configparser.ConfigParser()
            for section, options in self.config.items():
                config_parser.add_section(section)
                for key, value in options.items():
                    config_parser.set(section, key, str(value))
            
            with open(config_file, 'w') as f:
                config_parser.write(f)
                
        except Exception as e:
            servicemanager.LogErrorMsg(f"Error saving configuration: {e}")
    
    def setup_logging(self):
        """Setup service logging."""
        try:
            log_dir = os.path.join(os.path.dirname(__file__), 'logs')
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            
            log_file = os.path.join(log_dir, f"{self._svc_name_.lower()}.log")
            
            log_level = getattr(logging, self.config.get('service', {}).get('log_level', 'INFO'))
            
            logging.basicConfig(
                level=log_level,
                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(log_file),
                    logging.StreamHandler()
                ]
            )
            
            self.logger = logging.getLogger(self._svc_name_)
            self.logger.info(f"Service {self._svc_name_} logging initialized")
            
        except Exception as e:
            servicemanager.LogErrorMsg(f"Error setting up logging: {e}")
            self.logger = logging.getLogger(self._svc_name_)
    
    def initialize_service(self):
        """Initialize service-specific components. Override in subclasses."""
        pass
    
    def SvcStop(self):
        """Called when the service is requested to stop."""
        self.logger.info("Service stop requested")
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        
        self.is_stopping = True
        win32event.SetEvent(self.hWaitStop)
        
        self.cleanup_service()
    
    def SvcDoRun(self):
        """Main service execution method."""
        self.logger.info("Service starting")
        
        # Report service started
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STARTED,
            (self._svc_name_, '')
        )
        
        self.ReportServiceStatus(win32service.SERVICE_RUNNING)
        self.is_running = True
        
        try:
            self.main_service_loop()
        except Exception as e:
            self.logger.error(f"Service error: {e}")
            servicemanager.LogErrorMsg(f"Service error: {e}")
        finally:
            self.is_running = False
            self.logger.info("Service stopped")
            
            servicemanager.LogMsg(
                servicemanager.EVENTLOG_INFORMATION_TYPE,
                servicemanager.PYS_SERVICE_STOPPED,
                (self._svc_name_, '')
            )
    
    def main_service_loop(self):
        """Main service loop. Override in subclasses."""
        check_interval = int(self.config.get('service', {}).get('check_interval', 30))
        
        while True:
            # Wait for stop event with timeout
            result = win32event.WaitForSingleObject(self.hWaitStop, check_interval * 1000)
            
            if result == win32event.WAIT_OBJECT_0:
                # Stop event signaled
                break
            
            if self.is_stopping:
                break
            
            try:
                # Perform service work
                self.do_service_work()
            except Exception as e:
                self.logger.error(f"Error in service work: {e}")
    
    def do_service_work(self):
        """Perform the main service work. Override in subclasses."""
        self.logger.debug("Performing service work")
    
    def cleanup_service(self):
        """Cleanup service resources. Override in subclasses."""
        self.logger.info("Cleaning up service resources")

# Example implementation: System Monitor Service
class SystemMonitorService(BaseWindowsService):
    """System monitoring service example."""
    
    _svc_name_ = "SystemMonitorService"
    _svc_display_name_ = "System Monitor Service"
    _svc_description_ = "Monitors system performance and generates alerts"
    
    def initialize_service(self):
        """Initialize monitoring components."""
        self.performance_counters = {}
        self.alert_thresholds = {
            'cpu_usage': 80,
            'memory_usage': 85,
            'disk_usage': 90
        }
        self.alerts_sent = {}
        
        # Load thresholds from config
        if 'thresholds' in self.config:
            self.alert_thresholds.update(self.config['thresholds'])
    
    def do_service_work(self):
        """Monitor system performance."""
        try:
            # Get system metrics (simplified example)
            import psutil
            
            metrics = {
                'cpu_usage': psutil.cpu_percent(interval=1),
                'memory_usage': psutil.virtual_memory().percent,
                'disk_usage': psutil.disk_usage('C:').percent if os.path.exists('C:') else 0
            }
            
            self.logger.debug(f"System metrics: {metrics}")
            
            # Check thresholds and send alerts
            for metric, value in metrics.items():
                threshold = self.alert_thresholds.get(metric, 100)
                
                if value > threshold:
                    alert_key = f"{metric}_{int(time.time() // 300)}"  # 5-minute window
                    
                    if alert_key not in self.alerts_sent:
                        self.send_alert(metric, value, threshold)
                        self.alerts_sent[alert_key] = True
                        
                        # Clean old alerts
                        self.cleanup_old_alerts()
            
            # Save metrics to file/database
            self.save_metrics(metrics)
            
        except Exception as e:
            self.logger.error(f"Error monitoring system: {e}")
    
    def send_alert(self, metric, value, threshold):
        """Send alert for threshold violation."""
        message = f"ALERT: {metric} is {value}% (threshold: {threshold}%)"
        self.logger.warning(message)
        
        # Send to Windows Event Log
        servicemanager.LogWarningMsg(message)
        
        # Could also send email, SMS, or other notifications here
    
    def save_metrics(self, metrics):
        """Save metrics to file."""
        try:
            metrics_file = os.path.join(
                os.path.dirname(__file__), 
                'logs', 
                f"metrics_{datetime.now().strftime('%Y%m%d')}.json"
            )
            
            metric_entry = {
                'timestamp': datetime.now().isoformat(),
                'metrics': metrics
            }
            
            # Append to daily metrics file
            with open(metrics_file, 'a') as f:
                f.write(json.dumps(metric_entry) + '\n')
                
        except Exception as e:
            self.logger.error(f"Error saving metrics: {e}")
    
    def cleanup_old_alerts(self):
        """Clean up old alert entries."""
        current_time = int(time.time() // 300)
        cutoff_time = current_time - 12  # 1 hour worth of 5-minute windows
        
        keys_to_remove = [
            key for key in self.alerts_sent.keys()
            if int(key.split('_')[-1]) < cutoff_time
        ]
        
        for key in keys_to_remove:
            del self.alerts_sent[key]

# Service management utilities
class ServiceManager:
    """Utility class for managing Windows services."""
    
    @staticmethod
    def install_service(service_class, service_args=None):
        """Install a Windows service."""
        try:
            if service_args is None:
                service_args = []
            
            win32serviceutil.InstallService(
                service_class._svc_name_,
                service_class._svc_display_name_,
                startType=win32service.SERVICE_AUTO_START,
                description=service_class._svc_description_
            )
            
            print(f"Service '{service_class._svc_display_name_}' installed successfully")
            return True
            
        except Exception as e:
            print(f"Error installing service: {e}")
            return False
    
    @staticmethod
    def remove_service(service_name):
        """Remove a Windows service."""
        try:
            win32serviceutil.RemoveService(service_name)
            print(f"Service '{service_name}' removed successfully")
            return True
            
        except Exception as e:
            print(f"Error removing service: {e}")
            return False
    
    @staticmethod
    def start_service(service_name):
        """Start a Windows service."""
        try:
            win32serviceutil.StartService(service_name)
            print(f"Service '{service_name}' started successfully")
            return True
            
        except Exception as e:
            print(f"Error starting service: {e}")
            return False
    
    @staticmethod
    def stop_service(service_name):
        """Stop a Windows service."""
        try:
            win32serviceutil.StopService(service_name)
            print(f"Service '{service_name}' stopped successfully")
            return True
            
        except Exception as e:
            print(f"Error stopping service: {e}")
            return False
    
    @staticmethod
    def restart_service(service_name):
        """Restart a Windows service."""
        try:
            win32serviceutil.RestartService(service_name)
            print(f"Service '{service_name}' restarted successfully")
            return True
            
        except Exception as e:
            print(f"Error restarting service: {e}")
            return False
    
    @staticmethod
    def get_service_status(service_name):
        """Get the status of a Windows service."""
        try:
            status = win32serviceutil.QueryServiceStatus(service_name)
            status_names = {
                win32service.SERVICE_STOPPED: "Stopped",
                win32service.SERVICE_START_PENDING: "Start Pending",
                win32service.SERVICE_STOP_PENDING: "Stop Pending",
                win32service.SERVICE_RUNNING: "Running",
                win32service.SERVICE_CONTINUE_PENDING: "Continue Pending",
                win32service.SERVICE_PAUSE_PENDING: "Pause Pending",
                win32service.SERVICE_PAUSED: "Paused"
            }
            
            return {
                'service_name': service_name,
                'status_code': status[1],
                'status_name': status_names.get(status[1], "Unknown"),
                'controls_accepted': status[2],
                'service_specific_exit_code': status[3],
                'check_point': status[4],
                'wait_hint': status[5]
            }
            
        except Exception as e:
            return {
                'service_name': service_name,
                'error': str(e)
            }
    
    @staticmethod
    def list_services():
        """List all Windows services."""
        try:
            services = []
            
            # Open service control manager
            scm = win32service.OpenSCManager(None, None, win32service.SC_MANAGER_ALL_ACCESS)
            
            try:
                # Enumerate services
                service_list = win32service.EnumServicesStatus(scm)
                
                for service in service_list:
                    service_name = service[0]
                    display_name = service[1]
                    status = service[2]
                    
                    service_info = {
                        'service_name': service_name,
                        'display_name': display_name,
                        'status': status[1],
                        'status_name': ServiceManager._get_status_name(status[1])
                    }
                    services.append(service_info)
                    
            finally:
                win32service.CloseServiceHandle(scm)
            
            return services
            
        except Exception as e:
            print(f"Error listing services: {e}")
            return []
    
    @staticmethod
    def _get_status_name(status_code):
        """Convert status code to readable name."""
        status_names = {
            win32service.SERVICE_STOPPED: "Stopped",
            win32service.SERVICE_START_PENDING: "Start Pending",
            win32service.SERVICE_STOP_PENDING: "Stop Pending",
            win32service.SERVICE_RUNNING: "Running",
            win32service.SERVICE_CONTINUE_PENDING: "Continue Pending",
            win32service.SERVICE_PAUSE_PENDING: "Pause Pending",
            win32service.SERVICE_PAUSED: "Paused"
        }
        return status_names.get(status_code, "Unknown")

# Service command-line interface
def service_cli():
    """Command-line interface for service management."""
    if len(sys.argv) == 1:
        # No arguments - try to start as service
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(SystemMonitorService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        # Handle command-line arguments
        command = sys.argv[1].lower()
        
        if command == 'install':
            ServiceManager.install_service(SystemMonitorService)
        elif command == 'remove':
            ServiceManager.remove_service(SystemMonitorService._svc_name_)
        elif command == 'start':
            ServiceManager.start_service(SystemMonitorService._svc_name_)
        elif command == 'stop':
            ServiceManager.stop_service(SystemMonitorService._svc_name_)
        elif command == 'restart':
            ServiceManager.restart_service(SystemMonitorService._svc_name_)
        elif command == 'status':
            status = ServiceManager.get_service_status(SystemMonitorService._svc_name_)
            print(f"Service Status: {status}")
        elif command == 'debug':
            # Run service in debug mode
            win32serviceutil.HandleCommandLine(SystemMonitorService)
        else:
            print("Usage: service.py [install|remove|start|stop|restart|status|debug]")

if __name__ == "__main__":
    service_cli()
```

## 2. Advanced Service Features

### Service Dependency Management

```python
import win32service
import win32api
import time
import threading
from enum import Enum

class ServiceDependency:
    """Manage service dependencies."""
    
    def __init__(self, service_name):
        self.service_name = service_name
        self.dependencies = []
        self.dependents = []
    
    def add_dependency(self, dependency_service):
        """Add a service dependency."""
        if dependency_service not in self.dependencies:
            self.dependencies.append(dependency_service)
    
    def add_dependent(self, dependent_service):
        """Add a dependent service."""
        if dependent_service not in self.dependents:
            self.dependents.append(dependent_service)
    
    def get_dependencies(self):
        """Get list of service dependencies."""
        return self.dependencies.copy()
    
    def get_dependents(self):
        """Get list of dependent services."""
        return self.dependents.copy()

class ServiceState(Enum):
    """Service state enumeration."""
    UNKNOWN = 0
    STOPPED = 1
    STARTING = 2
    RUNNING = 3
    STOPPING = 4
    ERROR = 5

class ServiceOrchestrator:
    """Orchestrate multiple services with dependencies."""
    
    def __init__(self):
        self.services = {}
        self.dependencies = {}
        self.startup_order = []
        self.shutdown_order = []
    
    def register_service(self, service_name, dependencies=None):
        """Register a service with its dependencies."""
        if dependencies is None:
            dependencies = []
        
        service_dep = ServiceDependency(service_name)
        
        for dep in dependencies:
            service_dep.add_dependency(dep)
            
            # Add this service as a dependent to the dependency
            if dep in self.dependencies:
                self.dependencies[dep].add_dependent(service_name)
        
        self.dependencies[service_name] = service_dep
        self._calculate_startup_order()
    
    def _calculate_startup_order(self):
        """Calculate the correct startup order based on dependencies."""
        # Topological sort to determine startup order
        visited = set()
        temp_visited = set()
        startup_order = []
        
        def visit(service):
            if service in temp_visited:
                raise Exception(f"Circular dependency detected involving {service}")
            
            if service not in visited:
                temp_visited.add(service)
                
                # Visit dependencies first
                for dep in self.dependencies.get(service, ServiceDependency(service)).get_dependencies():
                    visit(dep)
                
                temp_visited.remove(service)
                visited.add(service)
                startup_order.append(service)
        
        for service in self.dependencies:
            if service not in visited:
                visit(service)
        
        self.startup_order = startup_order
        self.shutdown_order = startup_order[::-1]  # Reverse for shutdown
    
    def start_services(self, timeout_per_service=30):
        """Start all services in correct order."""
        for service_name in self.startup_order:
            print(f"Starting service: {service_name}")
            
            try:
                # Check if all dependencies are running
                deps = self.dependencies.get(service_name, ServiceDependency(service_name)).get_dependencies()
                
                for dep in deps:
                    if not self._is_service_running(dep):
                        raise Exception(f"Dependency {dep} is not running")
                
                # Start the service
                if not self._is_service_running(service_name):
                    ServiceManager.start_service(service_name)
                    
                    # Wait for service to start
                    start_time = time.time()
                    while time.time() - start_time < timeout_per_service:
                        if self._is_service_running(service_name):
                            break
                        time.sleep(1)
                    else:
                        raise Exception(f"Service {service_name} failed to start within timeout")
                
                print(f"Service {service_name} started successfully")
                
            except Exception as e:
                print(f"Error starting service {service_name}: {e}")
                return False
        
        return True
    
    def stop_services(self, timeout_per_service=30):
        """Stop all services in correct order."""
        for service_name in self.shutdown_order:
            print(f"Stopping service: {service_name}")
            
            try:
                if self._is_service_running(service_name):
                    ServiceManager.stop_service(service_name)
                    
                    # Wait for service to stop
                    start_time = time.time()
                    while time.time() - start_time < timeout_per_service:
                        if not self._is_service_running(service_name):
                            break
                        time.sleep(1)
                    else:
                        print(f"Warning: Service {service_name} did not stop within timeout")
                
                print(f"Service {service_name} stopped")
                
            except Exception as e:
                print(f"Error stopping service {service_name}: {e}")
    
    def get_service_status_all(self):
        """Get status of all registered services."""
        status_info = {}
        
        for service_name in self.dependencies:
            status = ServiceManager.get_service_status(service_name)
            status_info[service_name] = status
        
        return status_info
    
    def _is_service_running(self, service_name):
        """Check if a service is running."""
        try:
            status = ServiceManager.get_service_status(service_name)
            return status.get('status_code') == win32service.SERVICE_RUNNING
        except:
            return False

# Example usage
def demo_service_orchestration():
    """Demonstrate service orchestration."""
    orchestrator = ServiceOrchestrator()
    
    # Register services with dependencies
    orchestrator.register_service("ServiceA")  # No dependencies
    orchestrator.register_service("ServiceB", ["ServiceA"])  # Depends on A
    orchestrator.register_service("ServiceC", ["ServiceA", "ServiceB"])  # Depends on A and B
    
    print("Startup order:", orchestrator.startup_order)
    print("Shutdown order:", orchestrator.shutdown_order)
    
    # Get status of all services
    status_all = orchestrator.get_service_status_all()
    for service, status in status_all.items():
        print(f"{service}: {status}")
```

### Service Recovery and Monitoring

```python
import win32service
import win32serviceutil
import win32event
import win32api
import psutil
import threading
import time
from datetime import datetime, timedelta
import smtplib
from email.mime.text import MIMEText

class ServiceRecoveryManager:
    """Manage service recovery and health monitoring."""
    
    def __init__(self):
        self.monitored_services = {}
        self.recovery_actions = {}
        self.monitoring_thread = None
        self.is_monitoring = False
        self.check_interval = 30  # seconds
    
    def add_monitored_service(self, service_name, recovery_config=None):
        """Add a service to monitoring."""
        if recovery_config is None:
            recovery_config = {
                'restart_attempts': 3,
                'restart_delay': 60,
                'reset_period': 3600,
                'notify_on_failure': True,
                'check_memory_usage': True,
                'max_memory_mb': 500,
                'check_cpu_usage': True,
                'max_cpu_percent': 80
            }
        
        self.monitored_services[service_name] = {
            'config': recovery_config,
            'restart_count': 0,
            'last_restart': None,
            'last_check': None,
            'status_history': []
        }
        
        print(f"Added service {service_name} to monitoring")
    
    def start_monitoring(self):
        """Start service monitoring."""
        if self.is_monitoring:
            return
        
        self.is_monitoring = True
        self.monitoring_thread = threading.Thread(target=self._monitoring_loop)
        self.monitoring_thread.daemon = True
        self.monitoring_thread.start()
        
        print("Service monitoring started")
    
    def stop_monitoring(self):
        """Stop service monitoring."""
        self.is_monitoring = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=10)
        
        print("Service monitoring stopped")
    
    def _monitoring_loop(self):
        """Main monitoring loop."""
        while self.is_monitoring:
            try:
                for service_name in self.monitored_services:
                    self._check_service_health(service_name)
                
                time.sleep(self.check_interval)
                
            except Exception as e:
                print(f"Error in monitoring loop: {e}")
                time.sleep(self.check_interval)
    
    def _check_service_health(self, service_name):
        """Check health of a specific service."""
        try:
            service_info = self.monitored_services[service_name]
            config = service_info['config']
            
            # Get current service status
            status = ServiceManager.get_service_status(service_name)
            current_time = datetime.now()
            
            # Update last check time
            service_info['last_check'] = current_time
            
            # Add to status history
            service_info['status_history'].append({
                'timestamp': current_time,
                'status': status.get('status_name', 'Unknown')
            })
            
            # Keep only last 100 status entries
            if len(service_info['status_history']) > 100:
                service_info['status_history'] = service_info['status_history'][-100:]
            
            # Check if service is stopped
            if status.get('status_code') != win32service.SERVICE_RUNNING:
                self._handle_service_failure(service_name, "Service not running")
                return
            
            # Check resource usage if enabled
            if config.get('check_memory_usage') or config.get('check_cpu_usage'):
                self._check_resource_usage(service_name)
                
        except Exception as e:
            print(f"Error checking service {service_name}: {e}")
    
    def _check_resource_usage(self, service_name):
        """Check resource usage of a service."""
        try:
            service_info = self.monitored_services[service_name]
            config = service_info['config']
            
            # Find processes for this service
            service_processes = self._get_service_processes(service_name)
            
            total_memory_mb = 0
            total_cpu_percent = 0
            process_count = len(service_processes)
            
            for proc in service_processes:
                try:
                    # Memory usage
                    memory_info = proc.memory_info()
                    total_memory_mb += memory_info.rss / (1024 * 1024)
                    
                    # CPU usage
                    total_cpu_percent += proc.cpu_percent()
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    process_count -= 1
            
            # Check memory threshold
            if config.get('check_memory_usage') and total_memory_mb > config.get('max_memory_mb', 500):
                self._handle_service_failure(
                    service_name, 
                    f"Memory usage too high: {total_memory_mb:.1f}MB"
                )
            
            # Check CPU threshold
            if config.get('check_cpu_usage') and total_cpu_percent > config.get('max_cpu_percent', 80):
                self._handle_service_failure(
                    service_name, 
                    f"CPU usage too high: {total_cpu_percent:.1f}%"
                )
                
        except Exception as e:
            print(f"Error checking resource usage for {service_name}: {e}")
    
    def _get_service_processes(self, service_name):
        """Get processes associated with a service."""
        try:
            # This is a simplified approach - in practice, you'd need to
            # query the service to get its process ID(s)
            processes = []
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    # Check if process name or command line contains service name
                    if (service_name.lower() in proc.info['name'].lower() or
                        any(service_name.lower() in arg.lower() for arg in proc.info['cmdline'] or [])):
                        processes.append(psutil.Process(proc.info['pid']))
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return processes
            
        except Exception as e:
            print(f"Error getting processes for service {service_name}: {e}")
            return []
    
    def _handle_service_failure(self, service_name, reason):
        """Handle service failure."""
        try:
            service_info = self.monitored_services[service_name]
            config = service_info['config']
            current_time = datetime.now()
            
            print(f"Service failure detected: {service_name} - {reason}")
            
            # Check if we need to reset restart count
            reset_period = config.get('reset_period', 3600)
            if (service_info['last_restart'] and 
                current_time - service_info['last_restart'] > timedelta(seconds=reset_period)):
                service_info['restart_count'] = 0
            
            # Check if we can attempt restart
            max_attempts = config.get('restart_attempts', 3)
            if service_info['restart_count'] < max_attempts:
                self._restart_service(service_name)
            else:
                print(f"Maximum restart attempts reached for {service_name}")
                
                if config.get('notify_on_failure'):
                    self._send_failure_notification(service_name, reason)
                
        except Exception as e:
            print(f"Error handling service failure for {service_name}: {e}")
    
    def _restart_service(self, service_name):
        """Restart a failed service."""
        try:
            service_info = self.monitored_services[service_name]
            config = service_info['config']
            
            print(f"Attempting to restart service: {service_name}")
            
            # Stop service first
            try:
                ServiceManager.stop_service(service_name)
                time.sleep(5)  # Wait for clean shutdown
            except:
                pass
            
            # Wait for restart delay
            restart_delay = config.get('restart_delay', 60)
            time.sleep(restart_delay)
            
            # Start service
            if ServiceManager.start_service(service_name):
                service_info['restart_count'] += 1
                service_info['last_restart'] = datetime.now()
                print(f"Service {service_name} restarted successfully")
            else:
                print(f"Failed to restart service {service_name}")
                
        except Exception as e:
            print(f"Error restarting service {service_name}: {e}")
    
    def _send_failure_notification(self, service_name, reason):
        """Send notification about service failure."""
        try:
            # This is a placeholder - implement actual notification system
            message = f"""
            Service Failure Alert
            
            Service: {service_name}
            Reason: {reason}
            Time: {datetime.now()}
            
            Please investigate the issue.
            """
            
            print(f"NOTIFICATION: {message}")
            
            # Could implement email, SMS, or other notification methods here
            
        except Exception as e:
            print(f"Error sending notification: {e}")
    
    def get_monitoring_report(self):
        """Generate monitoring report."""
        report = {
            'generation_time': datetime.now().isoformat(),
            'monitored_services': len(self.monitored_services),
            'services': {}
        }
        
        for service_name, service_info in self.monitored_services.items():
            status = ServiceManager.get_service_status(service_name)
            
            service_report = {
                'current_status': status.get('status_name', 'Unknown'),
                'restart_count': service_info['restart_count'],
                'last_restart': service_info['last_restart'].isoformat() if service_info['last_restart'] else None,
                'last_check': service_info['last_check'].isoformat() if service_info['last_check'] else None,
                'status_history_count': len(service_info['status_history']),
                'configuration': service_info['config']
            }
            
            report['services'][service_name] = service_report
        
        return report

# Example usage
def demo_service_recovery():
    """Demonstrate service recovery management."""
    recovery_manager = ServiceRecoveryManager()
    
    # Add services to monitor
    recovery_manager.add_monitored_service("SystemMonitorService", {
        'restart_attempts': 5,
        'restart_delay': 30,
        'check_memory_usage': True,
        'max_memory_mb': 100
    })
    
    # Start monitoring
    recovery_manager.start_monitoring()
    
    try:
        # Let it monitor for a while
        time.sleep(60)
        
        # Generate report
        report = recovery_manager.get_monitoring_report()
        print("Monitoring Report:")
        for service, info in report['services'].items():
            print(f"  {service}: {info['current_status']}")
            
    finally:
        recovery_manager.stop_monitoring()
```

## 3. Service Communication and IPC

### Inter-Service Communication

```python
import win32pipe
import win32file
import win32event
import win32api
import threading
import json
import queue
import uuid
from datetime import datetime

class ServiceIPCServer:
    """Inter-process communication server for services."""
    
    def __init__(self, pipe_name="ServiceIPC"):
        self.pipe_name = f"\\\\.\\pipe\\{pipe_name}"
        self.is_running = False
        self.server_thread = None
        self.message_handlers = {}
        self.client_connections = {}
    
    def add_message_handler(self, message_type, handler_func):
        """Add a message handler for a specific message type."""
        self.message_handlers[message_type] = handler_func
    
    def start_server(self):
        """Start the IPC server."""
        if self.is_running:
            return
        
        self.is_running = True
        self.server_thread = threading.Thread(target=self._server_loop)
        self.server_thread.daemon = True
        self.server_thread.start()
        
        print(f"IPC Server started on {self.pipe_name}")
    
    def stop_server(self):
        """Stop the IPC server."""
        self.is_running = False
        if self.server_thread:
            self.server_thread.join(timeout=5)
        
        print("IPC Server stopped")
    
    def _server_loop(self):
        """Main server loop."""
        while self.is_running:
            try:
                # Create named pipe
                pipe_handle = win32pipe.CreateNamedPipe(
                    self.pipe_name,
                    win32pipe.PIPE_ACCESS_DUPLEX,
                    win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_READMODE_MESSAGE | win32pipe.PIPE_WAIT,
                    win32pipe.PIPE_UNLIMITED_INSTANCES,
                    65536,  # output buffer size
                    65536,  # input buffer size
                    0,      # default timeout
                    None    # security attributes
                )
                
                # Wait for client connection
                win32pipe.ConnectNamedPipe(pipe_handle, None)
                
                # Handle client in separate thread
                client_id = str(uuid.uuid4())
                client_thread = threading.Thread(
                    target=self._handle_client,
                    args=(pipe_handle, client_id)
                )
                client_thread.daemon = True
                client_thread.start()
                
            except Exception as e:
                print(f"Error in server loop: {e}")
                time.sleep(1)
    
    def _handle_client(self, pipe_handle, client_id):
        """Handle individual client connection."""
        try:
            self.client_connections[client_id] = pipe_handle
            print(f"Client {client_id} connected")
            
            while self.is_running:
                try:
                    # Read message from client
                    result, data = win32file.ReadFile(pipe_handle, 65536)
                    
                    if data:
                        message = json.loads(data.decode('utf-8'))
                        response = self._process_message(message, client_id)
                        
                        # Send response
                        if response:
                            response_data = json.dumps(response).encode('utf-8')
                            win32file.WriteFile(pipe_handle, response_data)
                    
                except Exception as e:
                    print(f"Error handling client {client_id}: {e}")
                    break
                    
        finally:
            try:
                win32file.CloseHandle(pipe_handle)
                if client_id in self.client_connections:
                    del self.client_connections[client_id]
                print(f"Client {client_id} disconnected")
            except:
                pass
    
    def _process_message(self, message, client_id):
        """Process incoming message."""
        try:
            message_type = message.get('type')
            message_data = message.get('data', {})
            
            # Add client info to message
            message_data['client_id'] = client_id
            message_data['timestamp'] = datetime.now().isoformat()
            
            # Find handler
            handler = self.message_handlers.get(message_type)
            
            if handler:
                response = handler(message_data)
                
                return {
                    'status': 'success',
                    'response': response,
                    'timestamp': datetime.now().isoformat()
                }
            else:
                return {
                    'status': 'error',
                    'error': f'Unknown message type: {message_type}',
                    'timestamp': datetime.now().isoformat()
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def broadcast_message(self, message):
        """Broadcast message to all connected clients."""
        message_data = json.dumps(message).encode('utf-8')
        
        disconnected_clients = []
        
        for client_id, pipe_handle in self.client_connections.items():
            try:
                win32file.WriteFile(pipe_handle, message_data)
            except Exception as e:
                print(f"Error broadcasting to client {client_id}: {e}")
                disconnected_clients.append(client_id)
        
        # Clean up disconnected clients
        for client_id in disconnected_clients:
            if client_id in self.client_connections:
                del self.client_connections[client_id]

class ServiceIPCClient:
    """IPC client for communicating with services."""
    
    def __init__(self, pipe_name="ServiceIPC"):
        self.pipe_name = f"\\\\.\\pipe\\{pipe_name}"
        self.pipe_handle = None
        self.is_connected = False
    
    def connect(self, timeout=5000):
        """Connect to IPC server."""
        try:
            # Wait for pipe to become available
            win32pipe.WaitNamedPipe(self.pipe_name, timeout)
            
            # Open pipe
            self.pipe_handle = win32file.CreateFile(
                self.pipe_name,
                win32file.GENERIC_READ | win32file.GENERIC_WRITE,
                0,
                None,
                win32file.OPEN_EXISTING,
                0,
                None
            )
            
            # Set pipe mode
            win32pipe.SetNamedPipeHandleState(
                self.pipe_handle,
                win32pipe.PIPE_READMODE_MESSAGE,
                None,
                None
            )
            
            self.is_connected = True
            print(f"Connected to IPC server: {self.pipe_name}")
            return True
            
        except Exception as e:
            print(f"Error connecting to IPC server: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from IPC server."""
        try:
            if self.pipe_handle:
                win32file.CloseHandle(self.pipe_handle)
                self.pipe_handle = None
            
            self.is_connected = False
            print("Disconnected from IPC server")
            
        except Exception as e:
            print(f"Error disconnecting: {e}")
    
    def send_message(self, message_type, data=None, timeout=5000):
        """Send message to IPC server."""
        if not self.is_connected:
            raise Exception("Not connected to IPC server")
        
        try:
            message = {
                'type': message_type,
                'data': data or {},
                'timestamp': datetime.now().isoformat()
            }
            
            message_data = json.dumps(message).encode('utf-8')
            
            # Send message
            win32file.WriteFile(self.pipe_handle, message_data)
            
            # Read response
            result, response_data = win32file.ReadFile(self.pipe_handle, 65536)
            
            if response_data:
                response = json.loads(response_data.decode('utf-8'))
                return response
            
            return None
            
        except Exception as e:
            print(f"Error sending message: {e}")
            return {
                'status': 'error',
                'error': str(e)
            }

# Example service with IPC integration
class IPCEnabledService(BaseWindowsService):
    """Service with IPC capabilities."""
    
    _svc_name_ = "IPCEnabledService"
    _svc_display_name_ = "IPC Enabled Service"
    _svc_description_ = "Service with inter-process communication"
    
    def initialize_service(self):
        """Initialize IPC server."""
        self.ipc_server = ServiceIPCServer("IPCEnabledService")
        
        # Add message handlers
        self.ipc_server.add_message_handler('get_status', self.handle_get_status)
        self.ipc_server.add_message_handler('get_config', self.handle_get_config)
        self.ipc_server.add_message_handler('set_config', self.handle_set_config)
        self.ipc_server.add_message_handler('restart', self.handle_restart)
        
        # Start IPC server
        self.ipc_server.start_server()
    
    def handle_get_status(self, data):
        """Handle status request."""
        return {
            'service_name': self._svc_name_,
            'status': 'running',
            'uptime': time.time() - self.start_time if hasattr(self, 'start_time') else 0,
            'config': self.config
        }
    
    def handle_get_config(self, data):
        """Handle configuration request."""
        return self.config
    
    def handle_set_config(self, data):
        """Handle configuration update."""
        try:
            new_config = data.get('config', {})
            
            # Update configuration
            for section, options in new_config.items():
                if section not in self.config:
                    self.config[section] = {}
                self.config[section].update(options)
            
            # Save configuration
            self.save_configuration()
            
            return {'success': True, 'message': 'Configuration updated'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def handle_restart(self, data):
        """Handle restart request."""
        try:
            # Schedule restart
            threading.Timer(2.0, self.SvcStop).start()
            return {'success': True, 'message': 'Restart scheduled'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def SvcDoRun(self):
        """Override to add start time tracking."""
        self.start_time = time.time()
        super().SvcDoRun()
    
    def cleanup_service(self):
        """Cleanup IPC server."""
        if hasattr(self, 'ipc_server'):
            self.ipc_server.stop_server()
        super().cleanup_service()

# Example client application
def demo_ipc_client():
    """Demonstrate IPC client usage."""
    client = ServiceIPCClient("IPCEnabledService")
    
    try:
        if client.connect():
            # Get service status
            response = client.send_message('get_status')
            print(f"Status response: {response}")
            
            # Get configuration
            response = client.send_message('get_config')
            print(f"Config response: {response}")
            
            # Update configuration
            new_config = {
                'service': {
                    'check_interval': '45'
                }
            }
            response = client.send_message('set_config', {'config': new_config})
            print(f"Set config response: {response}")
            
    finally:
        client.disconnect()

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == 'client':
        demo_ipc_client()
    else:
        # Run as service
        service_cli()
```

## 4. Practical Exercises

### Exercise 1: Log Monitoring Service
Create a Windows service that monitors log files for specific patterns and sends alerts when critical events are detected.

### Exercise 2: Backup Service
Build a service that performs automated backups of specified directories with scheduling and retention policies.

### Exercise 3: Health Check Service
Implement a service that monitors other services and applications, restarting them if they fail health checks.

### Exercise 4: Configuration Management Service
Create a service that manages configuration files across multiple applications with versioning and rollback capabilities.

### Exercise 5: Multi-Service Framework
Build a framework that can host multiple logical services within a single Windows service process.

## 5. Best Practices

### Service Development Best Practices
1. **Service Design**: Keep services focused on specific tasks
2. **Error Handling**: Implement comprehensive error handling and logging
3. **Resource Management**: Properly manage system resources and handles
4. **Configuration**: Use external configuration files for flexibility
5. **Security**: Run with minimal required privileges
6. **Monitoring**: Include health checks and monitoring capabilities
7. **Recovery**: Implement automatic recovery mechanisms
8. **Dependencies**: Minimize and manage service dependencies carefully

### Performance Considerations
1. **Startup Time**: Optimize service startup performance
2. **Memory Usage**: Monitor and control memory consumption
3. **Threading**: Use appropriate threading models
4. **I/O Operations**: Implement efficient I/O patterns
5. **Resource Pooling**: Use connection and object pooling
6. **Batch Processing**: Process items in batches when possible

### Security Best Practices
1. **Principle of Least Privilege**: Run with minimal required permissions
2. **Input Validation**: Validate all inputs and configuration
3. **Secure Communication**: Use encrypted communication channels
4. **Audit Logging**: Log all security-relevant events
5. **Access Control**: Implement proper access controls for service APIs

## 6. Common Pitfalls

### Service Development Issues
- Not handling service stop requests properly
- Blocking in service initialization
- Poor error handling and recovery
- Memory leaks and resource management
- Not implementing proper logging

### Performance Problems
- Heavy processing in main service thread
- Inefficient polling mechanisms
- Not implementing proper backoff strategies
- Resource contention issues

### Deployment and Management
- Not providing proper installation scripts
- Poor configuration management
- Inadequate monitoring and alerting
- Not implementing proper upgrade procedures

## 7. Capstone Project: Custom Monitoring Service

### Project Overview
Build a comprehensive monitoring service that demonstrates all the concepts learned in this module.

### Requirements
1. **Core Service Framework**
   - Robust Windows service implementation
   - Configuration management system
   - Comprehensive logging and error handling
   - IPC interface for management

2. **Monitoring Capabilities**
   - System performance monitoring
   - Application health checking
   - Log file monitoring
   - Custom metric collection

3. **Recovery and Management**
   - Automatic service recovery
   - Dependency management
   - Health check mechanisms
   - Performance optimization

4. **Communication and Control**
   - IPC server for management
   - Web API for remote control
   - Event notification system
   - Report generation

5. **Deployment and Maintenance**
   - Installation and setup scripts
   - Configuration management tools
   - Update and maintenance procedures
   - Documentation and help system

### Implementation Guidelines
1. Use the service framework patterns shown in this module
2. Implement comprehensive error handling and recovery
3. Follow Windows service best practices
4. Include thorough testing and validation
5. Provide complete documentation and deployment guides

### Evaluation Criteria
- **Functionality** (30%): All features implemented correctly
- **Reliability** (25%): Robust error handling and recovery
- **Performance** (20%): Efficient resource usage
- **Security** (15%): Proper security implementation
- **Documentation** (10%): Complete documentation and guides

## Summary
This module covered advanced Windows service development using pywin32, including service architecture, lifecycle management, recovery mechanisms, inter-service communication, and building enterprise-grade service frameworks. You learned to create robust, scalable, and maintainable Windows services with comprehensive monitoring and management capabilities.

### Key Takeaways
1. Proper service architecture is crucial for reliability and maintainability
2. Comprehensive error handling and recovery mechanisms are essential
3. Configuration management enables flexible service deployment
4. IPC enables powerful service communication and management
5. Monitoring and health checks improve service reliability
6. Proper resource management is critical for service performance
7. Security considerations must be built into service design

### Next Steps
- Explore advanced service frameworks and patterns
- Learn about containerization and cloud service deployment
- Study microservice architectures and service mesh patterns
- Practice with real-world service scenarios
- Contribute to open-source service projects

---

**Estimated Time**: 12-15 hours
**Difficulty**: Advanced
**Prerequisites**: Strong Python knowledge, Windows administration
**Next Module**: [4.4 Shell Integration](./4.4%20Shell%20Integration.md)
