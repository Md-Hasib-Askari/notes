# 4.4 Shell Integration

## Learning Objectives
By the end of this module, you will:
- Master Windows shell programming and integration
- Create system tray applications and taskbar integrations
- Implement shell notifications and context menu extensions
- Build shell extensions and file association handlers
- Develop comprehensive desktop integration solutions
- Create user-friendly system administration tools

## Module Overview
Windows shell integration allows applications to seamlessly integrate with the Windows desktop environment. This module covers advanced shell programming using pywin32, including system tray applications, taskbar manipulation, shell notifications, context menus, and building comprehensive desktop integration solutions.

### Key pywin32 Modules
- `win32gui` - Window and GUI manipulation
- `win32shell` - Shell operations and integration
- `win32api` - System API functions
- `win32con` - Windows constants
- `commctrl` - Common controls
- `win32clipboard` - Clipboard operations

## 1. System Tray Applications

### Creating System Tray Icons

```python
import win32gui
import win32con
import win32api
import win32shell
import threading
import time
import os
import sys
from datetime import datetime
import json
import subprocess

class SystemTrayIcon:
    """System tray icon with menu and notifications."""
    
    def __init__(self, icon_path=None, tooltip="System Tray Application"):
        self.tooltip = tooltip
        self.icon_path = icon_path or self._get_default_icon()
        self.menu_items = []
        self.hwnd = None
        self.message_map = {}
        self.notify_id = None
        self.is_running = False
        
        # Windows messages
        self.WM_TASKBARCREATED = win32gui.RegisterWindowMessage("TaskbarCreated")
        self.WM_USER = win32con.WM_USER
        self.WM_TRAYICON = self.WM_USER + 1
        
        # Initialize window class
        self._register_window_class()
        self._create_window()
        self._add_tray_icon()
    
    def _get_default_icon(self):
        """Get default system icon."""
        return win32api.GetModuleFileName(0)  # Use executable icon
    
    def _register_window_class(self):
        """Register window class for tray icon."""
        self.window_class = "SystemTrayIcon"
        
        wndclass = win32gui.WNDCLASS()
        wndclass.hInstance = win32api.GetModuleHandle(None)
        wndclass.lpszClassName = self.window_class
        wndclass.style = win32con.CS_VREDRAW | win32con.CS_HREDRAW
        wndclass.hCursor = win32gui.LoadCursor(0, win32con.IDC_ARROW)
        wndclass.hbrBackground = win32con.COLOR_WINDOW
        wndclass.lpfnWndProc = self._wnd_proc
        
        try:
            win32gui.RegisterClass(wndclass)
        except Exception as e:
            # Class might already be registered
            pass
    
    def _create_window(self):
        """Create hidden window for message handling."""
        self.hwnd = win32gui.CreateWindow(
            self.window_class,
            "System Tray Window",
            0,  # No visible window
            0, 0, 0, 0,
            0, 0,
            win32api.GetModuleHandle(None),
            None
        )
        
        # Setup message handlers
        self.message_map = {
            self.WM_TRAYICON: self._handle_tray_message,
            self.WM_TASKBARCREATED: self._handle_taskbar_created,
            win32con.WM_DESTROY: self._handle_destroy,
            win32con.WM_COMMAND: self._handle_command
        }
    
    def _wnd_proc(self, hwnd, msg, wparam, lparam):
        """Window procedure for message handling."""
        if msg in self.message_map:
            return self.message_map[msg](hwnd, msg, wparam, lparam)
        else:
            return win32gui.DefWindowProc(hwnd, msg, wparam, lparam)
    
    def _add_tray_icon(self):
        """Add icon to system tray."""
        try:
            # Load icon
            if os.path.isfile(self.icon_path):
                hicon = win32gui.LoadImage(
                    0, self.icon_path, win32con.IMAGE_ICON,
                    0, 0, win32con.LR_LOADFROMFILE | win32con.LR_DEFAULTSIZE
                )
            else:
                hicon = win32gui.LoadIcon(0, win32con.IDI_APPLICATION)
            
            # Add to tray
            flags = win32shell.NIF_ICON | win32shell.NIF_MESSAGE | win32shell.NIF_TIP
            
            self.notify_id = (
                self.hwnd,
                0,
                flags,
                self.WM_TRAYICON,
                hicon,
                self.tooltip
            )
            
            win32shell.Shell_NotifyIcon(win32shell.NIM_ADD, self.notify_id)
            self.is_running = True
            
        except Exception as e:
            print(f"Error adding tray icon: {e}")
    
    def _remove_tray_icon(self):
        """Remove icon from system tray."""
        if self.notify_id:
            try:
                win32shell.Shell_NotifyIcon(win32shell.NIM_DELETE, self.notify_id)
            except Exception as e:
                print(f"Error removing tray icon: {e}")
    
    def _handle_tray_message(self, hwnd, msg, wparam, lparam):
        """Handle tray icon messages."""
        if lparam == win32con.WM_LBUTTONDBLCLK:
            self.on_double_click()
        elif lparam == win32con.WM_RBUTTONUP:
            self.show_context_menu()
        elif lparam == win32con.WM_LBUTTONUP:
            self.on_left_click()
        
        return 0
    
    def _handle_taskbar_created(self, hwnd, msg, wparam, lparam):
        """Handle taskbar recreation (e.g., Explorer restart)."""
        self._add_tray_icon()
        return 0
    
    def _handle_destroy(self, hwnd, msg, wparam, lparam):
        """Handle window destruction."""
        self._remove_tray_icon()
        win32gui.PostQuitMessage(0)
        return 0
    
    def _handle_command(self, hwnd, msg, wparam, lparam):
        """Handle menu command messages."""
        command_id = win32api.LOWORD(wparam)
        
        # Find menu item by ID
        for item in self.menu_items:
            if item.get('id') == command_id:
                if item.get('callback'):
                    item['callback']()
                break
        
        return 0
    
    def add_menu_item(self, text, callback=None, enabled=True, checked=False):
        """Add item to context menu."""
        item_id = len(self.menu_items) + 1000
        
        menu_item = {
            'id': item_id,
            'text': text,
            'callback': callback,
            'enabled': enabled,
            'checked': checked
        }
        
        self.menu_items.append(menu_item)
        return item_id
    
    def add_menu_separator(self):
        """Add separator to context menu."""
        self.menu_items.append({'separator': True})
    
    def show_context_menu(self):
        """Show context menu at cursor position."""
        if not self.menu_items:
            return
        
        try:
            # Create popup menu
            hmenu = win32gui.CreatePopupMenu()
            
            # Add menu items
            for item in self.menu_items:
                if item.get('separator'):
                    win32gui.AppendMenu(hmenu, win32con.MF_SEPARATOR, 0, "")
                else:
                    flags = win32con.MF_STRING
                    if not item.get('enabled', True):
                        flags |= win32con.MF_GRAYED
                    if item.get('checked', False):
                        flags |= win32con.MF_CHECKED
                    
                    win32gui.AppendMenu(hmenu, flags, item['id'], item['text'])
            
            # Get cursor position
            pos = win32gui.GetCursorPos()
            
            # Set foreground window to receive menu messages
            win32gui.SetForegroundWindow(self.hwnd)
            
            # Show menu
            win32gui.TrackPopupMenu(
                hmenu,
                win32con.TPM_LEFTALIGN | win32con.TPM_BOTTOMALIGN,
                pos[0], pos[1],
                0,
                self.hwnd,
                None
            )
            
            # Clean up
            win32gui.DestroyMenu(hmenu)
            
        except Exception as e:
            print(f"Error showing context menu: {e}")
    
    def show_balloon_tip(self, title, message, timeout=5000, icon_type=win32shell.NIIF_INFO):
        """Show balloon tip notification."""
        if not self.notify_id:
            return
        
        try:
            # Update notification with balloon tip
            flags = (win32shell.NIF_ICON | win32shell.NIF_MESSAGE | 
                    win32shell.NIF_TIP | win32shell.NIF_INFO)
            
            notify_data = (
                self.hwnd,
                0,
                flags,
                self.WM_TRAYICON,
                self.notify_id[4],  # hicon
                self.tooltip,
                message[:255],  # Balloon text (max 255 chars)
                timeout,
                title[:63],     # Balloon title (max 63 chars)
                icon_type
            )
            
            win32shell.Shell_NotifyIcon(win32shell.NIM_MODIFY, notify_data)
            
        except Exception as e:
            print(f"Error showing balloon tip: {e}")
    
    def update_icon(self, icon_path):
        """Update tray icon."""
        try:
            if os.path.isfile(icon_path):
                hicon = win32gui.LoadImage(
                    0, icon_path, win32con.IMAGE_ICON,
                    0, 0, win32con.LR_LOADFROMFILE | win32con.LR_DEFAULTSIZE
                )
            else:
                hicon = win32gui.LoadIcon(0, win32con.IDI_APPLICATION)
            
            # Update icon
            flags = win32shell.NIF_ICON
            notify_data = (
                self.hwnd,
                0,
                flags,
                self.WM_TRAYICON,
                hicon,
                self.tooltip
            )
            
            win32shell.Shell_NotifyIcon(win32shell.NIM_MODIFY, notify_data)
            self.icon_path = icon_path
            
        except Exception as e:
            print(f"Error updating icon: {e}")
    
    def update_tooltip(self, tooltip):
        """Update tooltip text."""
        try:
            self.tooltip = tooltip
            
            flags = win32shell.NIF_TIP
            notify_data = (
                self.hwnd,
                0,
                flags,
                self.WM_TRAYICON,
                self.notify_id[4],  # hicon
                tooltip
            )
            
            win32shell.Shell_NotifyIcon(win32shell.NIM_MODIFY, notify_data)
            
        except Exception as e:
            print(f"Error updating tooltip: {e}")
    
    def on_left_click(self):
        """Handle left click event. Override in subclasses."""
        pass
    
    def on_double_click(self):
        """Handle double click event. Override in subclasses."""
        pass
    
    def run(self):
        """Run message loop."""
        try:
            win32gui.PumpMessages()
        except KeyboardInterrupt:
            pass
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Cleanup resources."""
        self._remove_tray_icon()
        if self.hwnd:
            win32gui.DestroyWindow(self.hwnd)

# Example system monitor tray application
class SystemMonitorTray(SystemTrayIcon):
    """System monitor with tray icon."""
    
    def __init__(self):
        super().__init__(tooltip="System Monitor")
        
        # Add menu items
        self.add_menu_item("Show Status", self.show_status)
        self.add_menu_item("Performance", self.show_performance)
        self.add_menu_separator()
        self.add_menu_item("Settings", self.show_settings)
        self.add_menu_separator()
        self.add_menu_item("Exit", self.exit_application)
        
        # Start monitoring thread
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_system)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
    
    def _monitor_system(self):
        """Monitor system performance."""
        try:
            import psutil
            
            while self.monitoring:
                try:
                    # Get system metrics
                    cpu_percent = psutil.cpu_percent(interval=1)
                    memory = psutil.virtual_memory()
                    
                    # Update tooltip with current stats
                    tooltip = f"CPU: {cpu_percent:.1f}% | Memory: {memory.percent:.1f}%"
                    self.update_tooltip(tooltip)
                    
                    # Check for alerts
                    if cpu_percent > 90:
                        self.show_balloon_tip(
                            "High CPU Usage",
                            f"CPU usage is {cpu_percent:.1f}%",
                            icon_type=win32shell.NIIF_WARNING
                        )
                    
                    if memory.percent > 90:
                        self.show_balloon_tip(
                            "High Memory Usage",
                            f"Memory usage is {memory.percent:.1f}%",
                            icon_type=win32shell.NIIF_WARNING
                        )
                    
                    time.sleep(5)
                    
                except Exception as e:
                    print(f"Error monitoring system: {e}")
                    time.sleep(5)
                    
        except ImportError:
            self.show_balloon_tip(
                "Error", 
                "psutil module required for monitoring",
                icon_type=win32shell.NIIF_ERROR
            )
    
    def show_status(self):
        """Show system status."""
        try:
            import psutil
            
            # Get system information
            cpu_percent = psutil.cpu_percent()
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('C:')
            
            status_text = f"""System Status:
            
CPU Usage: {cpu_percent:.1f}%
Memory: {memory.percent:.1f}% ({memory.used // (1024**3):.1f}GB / {memory.total // (1024**3):.1f}GB)
Disk C:: {disk.percent:.1f}% ({disk.used // (1024**3):.1f}GB / {disk.total // (1024**3):.1f}GB)
            """
            
            win32api.MessageBox(0, status_text, "System Status", win32con.MB_OK | win32con.MB_ICONINFORMATION)
            
        except ImportError:
            win32api.MessageBox(0, "psutil module required", "Error", win32con.MB_OK | win32con.MB_ICONERROR)
        except Exception as e:
            win32api.MessageBox(0, f"Error getting status: {e}", "Error", win32con.MB_OK | win32con.MB_ICONERROR)
    
    def show_performance(self):
        """Show performance details."""
        # This could open a performance dashboard or detailed window
        self.show_balloon_tip("Performance", "Performance details would be shown here")
    
    def show_settings(self):
        """Show settings dialog."""
        # This could open a settings window
        self.show_balloon_tip("Settings", "Settings dialog would be shown here")
    
    def on_double_click(self):
        """Handle double click - show status."""
        self.show_status()
    
    def exit_application(self):
        """Exit the application."""
        self.monitoring = False
        win32gui.PostMessage(self.hwnd, win32con.WM_CLOSE, 0, 0)

# Example usage
def demo_system_tray():
    """Demonstrate system tray application."""
    print("Starting system tray application...")
    print("Look for the icon in your system tray.")
    print("Right-click for menu, double-click for status.")
    print("Press Ctrl+C to exit.")
    
    tray_app = SystemMonitorTray()
    
    try:
        tray_app.run()
    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        tray_app.cleanup()

if __name__ == "__main__":
    demo_system_tray()
```

## 2. Taskbar Integration

### Taskbar Progress and Overlays

```python
import win32gui
import win32con
import win32api
import win32shell
import comtypes
from comtypes import GUID
import time
import threading

# Taskbar interfaces
class ITaskbarList3:
    """Interface for Windows 7+ taskbar features."""
    
    def __init__(self):
        self.taskbar = None
        self._initialize_taskbar()
    
    def _initialize_taskbar(self):
        """Initialize taskbar interface."""
        try:
            import comtypes.client
            
            # Create TaskbarList object
            self.taskbar = comtypes.client.CreateObject("Microsoft.Windows.TaskbarList")
            
            # Initialize
            self.taskbar.HrInit()
            
        except Exception as e:
            print(f"Error initializing taskbar interface: {e}")
            self.taskbar = None
    
    def set_progress_value(self, hwnd, completed, total):
        """Set taskbar progress value."""
        if self.taskbar:
            try:
                # Progress states
                TBPF_NOPROGRESS = 0x0
                TBPF_INDETERMINATE = 0x1
                TBPF_NORMAL = 0x2
                TBPF_ERROR = 0x4
                TBPF_PAUSED = 0x8
                
                if total == 0:
                    self.taskbar.SetProgressState(hwnd, TBPF_NOPROGRESS)
                else:
                    self.taskbar.SetProgressState(hwnd, TBPF_NORMAL)
                    self.taskbar.SetProgressValue(hwnd, completed, total)
                    
            except Exception as e:
                print(f"Error setting progress: {e}")
    
    def set_progress_state(self, hwnd, state):
        """Set taskbar progress state.
        
        States:
        0 - No progress
        1 - Indeterminate
        2 - Normal
        4 - Error
        8 - Paused
        """
        if self.taskbar:
            try:
                self.taskbar.SetProgressState(hwnd, state)
            except Exception as e:
                print(f"Error setting progress state: {e}")
    
    def set_overlay_icon(self, hwnd, icon_path, description):
        """Set overlay icon on taskbar button."""
        if self.taskbar:
            try:
                if icon_path and os.path.isfile(icon_path):
                    hicon = win32gui.LoadImage(
                        0, icon_path, win32con.IMAGE_ICON,
                        16, 16, win32con.LR_LOADFROMFILE
                    )
                    self.taskbar.SetOverlayIcon(hwnd, hicon, description)
                else:
                    # Remove overlay
                    self.taskbar.SetOverlayIcon(hwnd, 0, "")
                    
            except Exception as e:
                print(f"Error setting overlay icon: {e}")
    
    def add_thumbnail_toolbar(self, hwnd, buttons):
        """Add thumbnail toolbar buttons."""
        if self.taskbar:
            try:
                # This would require more complex COM interface setup
                # Simplified version for demonstration
                pass
            except Exception as e:
                print(f"Error adding thumbnail toolbar: {e}")

class TaskbarProgressWindow:
    """Window with taskbar progress integration."""
    
    def __init__(self, title="Progress Window"):
        self.title = title
        self.hwnd = None
        self.taskbar = ITaskbarList3()
        self.progress_value = 0
        self.progress_max = 100
        
        self._create_window()
    
    def _create_window(self):
        """Create a window for progress display."""
        try:
            # Register window class
            wndclass = win32gui.WNDCLASS()
            wndclass.hInstance = win32api.GetModuleHandle(None)
            wndclass.lpszClassName = "TaskbarProgressWindow"
            wndclass.style = win32con.CS_VREDRAW | win32con.CS_HREDRAW
            wndclass.hCursor = win32gui.LoadCursor(0, win32con.IDC_ARROW)
            wndclass.hbrBackground = win32con.COLOR_WINDOW
            wndclass.lpfnWndProc = self._wnd_proc
            
            try:
                win32gui.RegisterClass(wndclass)
            except:
                pass  # Class might already be registered
            
            # Create window
            self.hwnd = win32gui.CreateWindow(
                "TaskbarProgressWindow",
                self.title,
                win32con.WS_OVERLAPPEDWINDOW,
                100, 100, 400, 200,
                0, 0,
                win32api.GetModuleHandle(None),
                None
            )
            
            # Show window
            win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
            win32gui.UpdateWindow(self.hwnd)
            
        except Exception as e:
            print(f"Error creating window: {e}")
    
    def _wnd_proc(self, hwnd, msg, wparam, lparam):
        """Window procedure."""
        if msg == win32con.WM_DESTROY:
            win32gui.PostQuitMessage(0)
            return 0
        elif msg == win32con.WM_PAINT:
            self._on_paint()
            return 0
        
        return win32gui.DefWindowProc(hwnd, msg, wparam, lparam)
    
    def _on_paint(self):
        """Handle window paint."""
        try:
            hdc, ps = win32gui.BeginPaint(self.hwnd)
            
            # Draw progress information
            rect = win32gui.GetClientRect(self.hwnd)
            
            # Draw progress text
            progress_text = f"Progress: {self.progress_value}/{self.progress_max} ({self.progress_value/self.progress_max*100:.1f}%)"
            
            win32gui.DrawText(
                hdc, progress_text, -1, (10, 10, rect[2]-10, 30),
                win32con.DT_LEFT | win32con.DT_TOP
            )
            
            # Draw progress bar
            bar_rect = (10, 50, rect[2]-10, 80)
            
            # Background
            win32gui.FillRect(hdc, bar_rect, win32gui.GetStockObject(win32con.LTGRAY_BRUSH))
            
            # Progress fill
            if self.progress_max > 0:
                fill_width = int((bar_rect[2] - bar_rect[0]) * (self.progress_value / self.progress_max))
                fill_rect = (bar_rect[0], bar_rect[1], bar_rect[0] + fill_width, bar_rect[3])
                win32gui.FillRect(hdc, fill_rect, win32gui.GetStockObject(win32con.DKGRAY_BRUSH))
            
            win32gui.EndPaint(self.hwnd, ps)
            
        except Exception as e:
            print(f"Error painting window: {e}")
    
    def set_progress(self, value, maximum=None):
        """Set progress value."""
        if maximum is not None:
            self.progress_max = maximum
        
        self.progress_value = min(value, self.progress_max)
        
        # Update taskbar progress
        self.taskbar.set_progress_value(self.hwnd, self.progress_value, self.progress_max)
        
        # Redraw window
        if self.hwnd:
            win32gui.InvalidateRect(self.hwnd, None, True)
    
    def set_progress_state(self, state):
        """Set progress state (0=none, 1=indeterminate, 2=normal, 4=error, 8=paused)."""
        self.taskbar.set_progress_state(self.hwnd, state)
    
    def set_overlay_icon(self, icon_path, description=""):
        """Set overlay icon."""
        self.taskbar.set_overlay_icon(self.hwnd, icon_path, description)
    
    def simulate_progress(self, duration=10):
        """Simulate progress over time."""
        def progress_worker():
            steps = 100
            delay = duration / steps
            
            for i in range(steps + 1):
                self.set_progress(i, steps)
                time.sleep(delay)
            
            # Show completion
            time.sleep(1)
            self.set_progress_state(0)  # No progress
        
        thread = threading.Thread(target=progress_worker)
        thread.daemon = True
        thread.start()
    
    def run(self):
        """Run message loop."""
        try:
            while True:
                msg = win32gui.GetMessage(None, 0, 0)
                if msg[1] == win32con.WM_QUIT:
                    break
                win32gui.TranslateMessage(msg)
                win32gui.DispatchMessage(msg)
        except Exception as e:
            print(f"Error in message loop: {e}")

# Example usage
def demo_taskbar_progress():
    """Demonstrate taskbar progress integration."""
    print("Creating progress window with taskbar integration...")
    
    window = TaskbarProgressWindow("Taskbar Progress Demo")
    
    # Start simulated progress
    window.simulate_progress(15)
    
    print("Watch the taskbar button for progress indication")
    print("Close the window to exit")
    
    window.run()

if __name__ == "__main__":
    demo_taskbar_progress()
```

## 3. Shell Notifications and Jump Lists

### Advanced Notification System

```python
import win32gui
import win32con
import win32api
import win32shell
import win32clipboard
import time
import os
import json
from datetime import datetime, timedelta
from enum import Enum

class NotificationType(Enum):
    """Notification types."""
    INFO = win32shell.NIIF_INFO
    WARNING = win32shell.NIIF_WARNING
    ERROR = win32shell.NIIF_ERROR
    NONE = win32shell.NIIF_NONE

class NotificationManager:
    """Advanced notification management system."""
    
    def __init__(self):
        self.notifications = []
        self.notification_history = []
        self.max_history = 100
        self.default_timeout = 5000
    
    def show_notification(self, title, message, notification_type=NotificationType.INFO, 
                         timeout=None, callback=None, actions=None):
        """Show a notification with optional actions."""
        
        notification = {
            'id': len(self.notifications),
            'title': title[:63],  # Windows limit
            'message': message[:255],  # Windows limit
            'type': notification_type,
            'timeout': timeout or self.default_timeout,
            'timestamp': datetime.now(),
            'callback': callback,
            'actions': actions or []
        }
        
        self.notifications.append(notification)
        
        # For now, use simple balloon tip
        # In a full implementation, you'd create custom notification windows
        self._show_balloon_tip(notification)
        
        # Add to history
        self._add_to_history(notification)
        
        return notification['id']
    
    def _show_balloon_tip(self, notification):
        """Show Windows balloon tip notification."""
        try:
            # This would typically be called from a tray icon
            # For demonstration, we'll print the notification
            print(f"NOTIFICATION: {notification['title']}")
            print(f"  {notification['message']}")
            print(f"  Type: {notification['type'].name}")
            print(f"  Time: {notification['timestamp']}")
            
        except Exception as e:
            print(f"Error showing notification: {e}")
    
    def _add_to_history(self, notification):
        """Add notification to history."""
        # Remove callback to make it JSON serializable
        history_item = notification.copy()
        history_item['callback'] = None
        history_item['type'] = notification['type'].name
        history_item['timestamp'] = notification['timestamp'].isoformat()
        
        self.notification_history.append(history_item)
        
        # Maintain history size
        if len(self.notification_history) > self.max_history:
            self.notification_history = self.notification_history[-self.max_history:]
    
    def get_notification_history(self, hours=24):
        """Get notification history for specified hours."""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        recent_notifications = []
        for notification in self.notification_history:
            timestamp = datetime.fromisoformat(notification['timestamp'])
            if timestamp >= cutoff_time:
                recent_notifications.append(notification)
        
        return recent_notifications
    
    def clear_notifications(self):
        """Clear all active notifications."""
        self.notifications.clear()
    
    def save_history(self, file_path):
        """Save notification history to file."""
        try:
            with open(file_path, 'w') as f:
                json.dump(self.notification_history, f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
    
    def load_history(self, file_path):
        """Load notification history from file."""
        try:
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    self.notification_history = json.load(f)
        except Exception as e:
            print(f"Error loading history: {e}")

class ToastNotification:
    """Windows 10 style toast notifications."""
    
    def __init__(self):
        self.app_id = "PyWin32.ToastNotification"
        self._register_app_id()
    
    def _register_app_id(self):
        """Register application ID for toast notifications."""
        try:
            # This requires Windows 10 and proper registration
            # For demonstration purposes, we'll use a simple approach
            pass
        except Exception as e:
            print(f"Error registering app ID: {e}")
    
    def show_toast(self, title, message, image_path=None, actions=None):
        """Show Windows 10 toast notification."""
        try:
            # This would require Windows 10 Toast Notification APIs
            # For demonstration, we'll create a custom notification window
            self._show_custom_toast(title, message, image_path, actions)
            
        except Exception as e:
            print(f"Error showing toast: {e}")
    
    def _show_custom_toast(self, title, message, image_path, actions):
        """Show custom toast-like notification."""
        
        class ToastWindow:
            def __init__(self, title, message):
                self.title = title
                self.message = message
                self.hwnd = None
                self._create_window()
            
            def _create_window(self):
                """Create toast notification window."""
                try:
                    # Register window class
                    wndclass = win32gui.WNDCLASS()
                    wndclass.hInstance = win32api.GetModuleHandle(None)
                    wndclass.lpszClassName = "ToastNotification"
                    wndclass.style = win32con.CS_VREDRAW | win32con.CS_HREDRAW
                    wndclass.hCursor = win32gui.LoadCursor(0, win32con.IDC_ARROW)
                    wndclass.hbrBackground = win32con.COLOR_WINDOW
                    wndclass.lpfnWndProc = self._wnd_proc
                    
                    try:
                        win32gui.RegisterClass(wndclass)
                    except:
                        pass
                    
                    # Get screen dimensions
                    screen_width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
                    screen_height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)
                    
                    # Position in bottom-right corner
                    width, height = 300, 100
                    x = screen_width - width - 20
                    y = screen_height - height - 60
                    
                    # Create window
                    self.hwnd = win32gui.CreateWindow(
                        "ToastNotification",
                        self.title,
                        win32con.WS_POPUP | win32con.WS_BORDER,
                        x, y, width, height,
                        0, 0,
                        win32api.GetModuleHandle(None),
                        None
                    )
                    
                    # Show window
                    win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
                    win32gui.UpdateWindow(self.hwnd)
                    
                    # Auto-hide after 5 seconds
                    def auto_hide():
                        time.sleep(5)
                        if self.hwnd:
                            win32gui.PostMessage(self.hwnd, win32con.WM_CLOSE, 0, 0)
                    
                    import threading
                    threading.Thread(target=auto_hide, daemon=True).start()
                    
                except Exception as e:
                    print(f"Error creating toast window: {e}")
            
            def _wnd_proc(self, hwnd, msg, wparam, lparam):
                """Window procedure."""
                if msg == win32con.WM_DESTROY:
                    return 0
                elif msg == win32con.WM_PAINT:
                    self._on_paint()
                    return 0
                elif msg == win32con.WM_LBUTTONDOWN:
                    # Close on click
                    win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
                    return 0
                
                return win32gui.DefWindowProc(hwnd, msg, wparam, lparam)
            
            def _on_paint(self):
                """Paint notification content."""
                try:
                    hdc, ps = win32gui.BeginPaint(self.hwnd)
                    rect = win32gui.GetClientRect(self.hwnd)
                    
                    # Fill background
                    win32gui.FillRect(hdc, rect, win32gui.GetStockObject(win32con.WHITE_BRUSH))
                    
                    # Draw title
                    title_rect = (10, 10, rect[2]-10, 30)
                    win32gui.DrawText(
                        hdc, self.title, -1, title_rect,
                        win32con.DT_LEFT | win32con.DT_TOP
                    )
                    
                    # Draw message
                    message_rect = (10, 35, rect[2]-10, rect[3]-10)
                    win32gui.DrawText(
                        hdc, self.message, -1, message_rect,
                        win32con.DT_LEFT | win32con.DT_TOP | win32con.DT_WORDBREAK
                    )
                    
                    win32gui.EndPaint(self.hwnd, ps)
                    
                except Exception as e:
                    print(f"Error painting toast: {e}")
        
        # Create and show toast window
        toast = ToastWindow(title, message)

# Example usage
def demo_notifications():
    """Demonstrate notification system."""
    print("Testing notification system...")
    
    # Initialize notification manager
    notif_manager = NotificationManager()
    
    # Show various notifications
    notif_manager.show_notification(
        "Welcome",
        "Application started successfully",
        NotificationType.INFO
    )
    
    time.sleep(2)
    
    notif_manager.show_notification(
        "Warning",
        "System resources are running low",
        NotificationType.WARNING
    )
    
    time.sleep(2)
    
    notif_manager.show_notification(
        "Error",
        "Failed to connect to remote server",
        NotificationType.ERROR
    )
    
    # Show toast notification
    toast = ToastNotification()
    toast.show_toast(
        "Custom Toast",
        "This is a custom toast notification",
        actions=["OK", "Cancel"]
    )
    
    # Get notification history
    history = notif_manager.get_notification_history()
    print(f"\nNotification history ({len(history)} items):")
    for item in history:
        print(f"  {item['timestamp']}: {item['title']} - {item['message']}")

if __name__ == "__main__":
    demo_notifications()
```

## 4. Context Menus and File Associations

### Shell Context Menu Extensions

```python
import win32gui
import win32con
import win32api
import win32shell
import win32clipboard
import os
import subprocess
import tempfile
import shutil
from pathlib import Path

class ContextMenuManager:
    """Manage shell context menu extensions."""
    
    def __init__(self):
        self.menu_items = []
        self.temp_files = []
    
    def add_file_menu_item(self, text, command, file_types=None, icon_path=None):
        """Add context menu item for files.
        
        Args:
            text: Menu item text
            command: Command to execute (%1 will be replaced with file path)
            file_types: List of file extensions (e.g., ['.txt', '.py'])
            icon_path: Path to icon file
        """
        menu_item = {
            'text': text,
            'command': command,
            'file_types': file_types or ['*'],
            'icon_path': icon_path,
            'type': 'file'
        }
        self.menu_items.append(menu_item)
    
    def add_folder_menu_item(self, text, command, icon_path=None):
        """Add context menu item for folders."""
        menu_item = {
            'text': text,
            'command': command,
            'icon_path': icon_path,
            'type': 'folder'
        }
        self.menu_items.append(menu_item)
    
    def show_context_menu(self, file_paths, position=None):
        """Show custom context menu for files/folders."""
        if not file_paths:
            return
        
        try:
            # Get cursor position if not provided
            if position is None:
                position = win32gui.GetCursorPos()
            
            # Create popup menu
            hmenu = win32gui.CreatePopupMenu()
            menu_id = 1000
            
            # Add applicable menu items
            for item in self.menu_items:
                if self._is_item_applicable(item, file_paths):
                    win32gui.AppendMenu(
                        hmenu,
                        win32con.MF_STRING,
                        menu_id,
                        item['text']
                    )
                    item['menu_id'] = menu_id
                    menu_id += 1
            
            if menu_id == 1000:
                # No applicable items
                win32gui.DestroyMenu(hmenu)
                return
            
            # Create hidden window for menu messages
            hwnd = self._create_menu_window()
            
            # Show menu
            win32gui.SetForegroundWindow(hwnd)
            selected_id = win32gui.TrackPopupMenu(
                hmenu,
                win32con.TPM_LEFTALIGN | win32con.TPM_RETURNCMD,
                position[0], position[1],
                0,
                hwnd,
                None
            )
            
            # Execute selected command
            if selected_id:
                self._execute_menu_command(selected_id, file_paths)
            
            # Cleanup
            win32gui.DestroyMenu(hmenu)
            win32gui.DestroyWindow(hwnd)
            
        except Exception as e:
            print(f"Error showing context menu: {e}")
    
    def _is_item_applicable(self, item, file_paths):
        """Check if menu item is applicable to the selected files."""
        for file_path in file_paths:
            if os.path.isfile(file_path) and item['type'] == 'file':
                # Check file type
                if '*' in item['file_types']:
                    return True
                
                file_ext = os.path.splitext(file_path)[1].lower()
                if file_ext in item['file_types']:
                    return True
            
            elif os.path.isdir(file_path) and item['type'] == 'folder':
                return True
        
        return False
    
    def _create_menu_window(self):
        """Create hidden window for menu message handling."""
        try:
            wndclass = win32gui.WNDCLASS()
            wndclass.hInstance = win32api.GetModuleHandle(None)
            wndclass.lpszClassName = "ContextMenuWindow"
            wndclass.lpfnWndProc = win32gui.DefWindowProc
            
            try:
                win32gui.RegisterClass(wndclass)
            except:
                pass
            
            hwnd = win32gui.CreateWindow(
                "ContextMenuWindow",
                "",
                0,  # No style
                0, 0, 0, 0,
                0, 0,
                win32api.GetModuleHandle(None),
                None
            )
            
            return hwnd
            
        except Exception as e:
            print(f"Error creating menu window: {e}")
            return 0
    
    def _execute_menu_command(self, menu_id, file_paths):
        """Execute the selected menu command."""
        try:
            # Find menu item by ID
            selected_item = None
            for item in self.menu_items:
                if item.get('menu_id') == menu_id:
                    selected_item = item
                    break
            
            if not selected_item:
                return
            
            # Execute command for each file
            for file_path in file_paths:
                command = selected_item['command'].replace('%1', f'"{file_path}"')
                
                try:
                    subprocess.run(command, shell=True, check=False)
                except Exception as e:
                    print(f"Error executing command '{command}': {e}")
                    
        except Exception as e:
            print(f"Error executing menu command: {e}")

class ClipboardManager:
    """Enhanced clipboard operations."""
    
    @staticmethod
    def copy_text(text):
        """Copy text to clipboard."""
        try:
            win32clipboard.OpenClipboard()
            win32clipboard.EmptyClipboard()
            win32clipboard.SetClipboardText(text)
            win32clipboard.CloseClipboard()
            return True
        except Exception as e:
            print(f"Error copying to clipboard: {e}")
            return False
    
    @staticmethod
    def get_text():
        """Get text from clipboard."""
        try:
            win32clipboard.OpenClipboard()
            data = win32clipboard.GetClipboardData()
            win32clipboard.CloseClipboard()
            return data
        except Exception as e:
            print(f"Error getting clipboard text: {e}")
            return None
    
    @staticmethod
    def copy_files(file_paths):
        """Copy files to clipboard."""
        try:
            import win32con
            
            # Format file list for clipboard
            file_list = '\0'.join(file_paths) + '\0\0'
            
            win32clipboard.OpenClipboard()
            win32clipboard.EmptyClipboard()
            
            # Set as file drop list
            win32clipboard.SetClipboardData(win32con.CF_HDROP, file_list.encode())
            win32clipboard.CloseClipboard()
            return True
            
        except Exception as e:
            print(f"Error copying files to clipboard: {e}")
            return False
    
    @staticmethod
    def get_files():
        """Get file list from clipboard."""
        try:
            win32clipboard.OpenClipboard()
            
            # Check if clipboard has files
            if win32clipboard.IsClipboardFormatAvailable(win32con.CF_HDROP):
                data = win32clipboard.GetClipboardData(win32con.CF_HDROP)
                files = data.decode().rstrip('\0').split('\0')
                win32clipboard.CloseClipboard()
                return files
            
            win32clipboard.CloseClipboard()
            return []
            
        except Exception as e:
            print(f"Error getting files from clipboard: {e}")
            return []

class FileOperationsMenu:
    """File operations context menu."""
    
    def __init__(self):
        self.context_menu = ContextMenuManager()
        self.clipboard = ClipboardManager()
        self._setup_menu_items()
    
    def _setup_menu_items(self):
        """Setup default menu items."""
        
        # Text file operations
        self.context_menu.add_file_menu_item(
            "Open with Notepad",
            "notepad.exe %1",
            ['.txt', '.py', '.js', '.html', '.css', '.xml', '.json']
        )
        
        self.context_menu.add_file_menu_item(
            "Copy Path to Clipboard",
            "python -c \"import win32clipboard; win32clipboard.OpenClipboard(); win32clipboard.EmptyClipboard(); win32clipboard.SetClipboardText('%1'); win32clipboard.CloseClipboard()\"",
            ['*']
        )
        
        self.context_menu.add_file_menu_item(
            "Open Command Prompt Here",
            "cmd.exe /k cd /d \"%~dp1\"",
            ['*']
        )
        
        # Folder operations
        self.context_menu.add_folder_menu_item(
            "Open Command Prompt Here",
            "cmd.exe /k cd /d %1"
        )
        
        self.context_menu.add_folder_menu_item(
            "Copy Folder Path",
            "python -c \"import win32clipboard; win32clipboard.OpenClipboard(); win32clipboard.EmptyClipboard(); win32clipboard.SetClipboardText('%1'); win32clipboard.CloseClipboard()\""
        )
    
    def show_menu_for_files(self, file_paths):
        """Show context menu for selected files."""
        self.context_menu.show_context_menu(file_paths)
    
    def copy_file_info(self, file_path):
        """Copy detailed file information to clipboard."""
        try:
            if not os.path.exists(file_path):
                return False
            
            stat = os.stat(file_path)
            info = f"""File Information:
Name: {os.path.basename(file_path)}
Path: {file_path}
Size: {stat.st_size:,} bytes
Modified: {datetime.fromtimestamp(stat.st_mtime)}
Created: {datetime.fromtimestamp(stat.st_ctime)}
"""
            
            return self.clipboard.copy_text(info)
            
        except Exception as e:
            print(f"Error copying file info: {e}")
            return False

# Example integrated shell application
class ShellIntegrationDemo:
    """Demonstration of shell integration features."""
    
    def __init__(self):
        self.file_ops = FileOperationsMenu()
        self.tray_icon = None
    
    def setup_tray_integration(self):
        """Setup system tray integration."""
        class ShellTrayIcon(SystemTrayIcon):
            def __init__(self, parent):
                super().__init__(tooltip="Shell Integration Demo")
                self.parent = parent
                self._setup_menu()
            
            def _setup_menu(self):
                self.add_menu_item("Show File Menu", self.show_file_menu)
                self.add_menu_item("Clipboard Operations", self.clipboard_operations)
                self.add_menu_separator()
                self.add_menu_item("Exit", self.exit_app)
            
            def show_file_menu(self):
                """Show file operations menu."""
                # Get current selection or use desktop
                file_paths = [os.path.expanduser("~\\Desktop")]
                self.parent.file_ops.show_menu_for_files(file_paths)
            
            def clipboard_operations(self):
                """Show clipboard operations."""
                text = self.parent.file_ops.clipboard.get_text()
                if text:
                    self.show_balloon_tip("Clipboard", f"Current text: {text[:50]}...")
                else:
                    self.show_balloon_tip("Clipboard", "No text in clipboard")
            
            def exit_app(self):
                win32gui.PostMessage(self.hwnd, win32con.WM_CLOSE, 0, 0)
        
        self.tray_icon = ShellTrayIcon(self)
        return self.tray_icon
    
    def run(self):
        """Run the shell integration demo."""
        print("Starting Shell Integration Demo...")
        print("Features:")
        print("- System tray icon with context menu")
        print("- File operations menu")
        print("- Clipboard operations")
        print("- Custom context menus")
        
        tray = self.setup_tray_integration()
        
        try:
            tray.run()
        except KeyboardInterrupt:
            print("\nShutting down...")
        finally:
            if tray:
                tray.cleanup()

# Example usage
def demo_shell_integration():
    """Demonstrate shell integration features."""
    demo = ShellIntegrationDemo()
    demo.run()

if __name__ == "__main__":
    demo_shell_integration()
```

## 5. Practical Exercises

### Exercise 1: System Monitor Tray
Create a comprehensive system monitor that lives in the system tray with real-time performance indicators and detailed context menus.

### Exercise 2: File Manager Extension
Build a file manager extension that adds useful context menu items and file operations.

### Exercise 3: Notification Center
Implement a notification center that collects and manages all system notifications with history and filtering.

### Exercise 4: Desktop Widget Framework
Create a framework for desktop widgets that can display information and interact with the shell.

### Exercise 5: Shell Automation Tool
Build a tool that automates common shell operations with a user-friendly interface.

## 6. Best Practices

### Shell Integration Best Practices
1. **User Experience**: Create intuitive and non-intrusive interfaces
2. **Performance**: Minimize resource usage and startup time
3. **Compatibility**: Ensure compatibility across Windows versions
4. **Error Handling**: Handle shell API errors gracefully
5. **Resource Management**: Properly clean up handles and resources
6. **Security**: Validate all user inputs and file operations
7. **Accessibility**: Follow Windows accessibility guidelines
8. **Visual Consistency**: Match Windows UI conventions

### System Tray Guidelines
1. **Purpose**: Only use tray icons for background services
2. **Icon Design**: Use clear, recognizable icons
3. **Tooltip Information**: Provide useful status information
4. **Menu Organization**: Keep context menus simple and organized
5. **Notifications**: Use notifications sparingly and meaningfully

### Performance Considerations
1. **Startup Impact**: Minimize impact on system startup
2. **Memory Usage**: Keep memory footprint small
3. **CPU Usage**: Avoid continuous high CPU usage
4. **I/O Operations**: Minimize disk and network I/O
5. **Threading**: Use background threads for heavy operations

## 7. Common Pitfalls

### Shell Integration Issues
- Not handling Explorer restarts properly
- Poor error handling with shell APIs
- Creating memory leaks with GUI resources
- Not following Windows UI guidelines
- Interfering with normal shell operations

### System Tray Problems
- Not cleaning up tray icons properly
- Creating too many notification bubbles
- Poor context menu organization
- Not handling DPI scaling correctly

### Performance Issues
- Blocking the UI thread with heavy operations
- Not optimizing for low-resource systems
- Creating too many background processes
- Poor resource management and cleanup

## 8. Capstone Project: System Tray Application

### Project Overview
Build a comprehensive system tray application that demonstrates all shell integration concepts.

### Requirements
1. **System Tray Integration**
   - Professional system tray icon with dynamic status
   - Comprehensive context menu with organized options
   - Real-time status updates and notifications
   - Proper cleanup and resource management

2. **Shell Integration Features**
   - File context menu extensions
   - Clipboard operation enhancements
   - Shell notifications system
   - Taskbar progress integration

3. **User Interface**
   - Settings and configuration dialog
   - Status and monitoring windows
   - Help and documentation system
   - About dialog with version information

4. **Functionality**
   - System monitoring and alerting
   - File operation utilities
   - Network connectivity monitoring
   - Custom automation scripts

5. **Advanced Features**
   - Plugin architecture for extensions
   - Configuration backup and restore
   - Remote management capabilities
   - Integration with external tools

### Implementation Guidelines
1. Use the shell integration patterns shown in this module
2. Implement comprehensive error handling and logging
3. Follow Windows UI/UX guidelines and conventions
4. Include thorough testing on different Windows versions
5. Provide complete documentation and user guides
6. Support multiple languages and accessibility features

### Evaluation Criteria
- **Functionality** (25%): All features work correctly
- **User Experience** (25%): Intuitive and polished interface
- **Performance** (20%): Efficient resource usage
- **Integration** (15%): Proper shell integration
- **Code Quality** (15%): Clean, maintainable code

## Summary
This module covered advanced Windows shell integration using pywin32, including system tray applications, taskbar integration, shell notifications, context menus, and comprehensive desktop integration solutions. You learned to create professional, user-friendly applications that seamlessly integrate with the Windows desktop environment.

### Key Takeaways
1. Shell integration requires careful attention to user experience and performance
2. System tray applications should provide real value without being intrusive
3. Proper resource management is critical for shell extensions
4. Following Windows UI conventions improves user acceptance
5. Comprehensive error handling prevents system instability
6. Performance optimization is essential for desktop integration
7. Professional polish distinguishes quality shell applications

### Next Steps
- Explore Windows Runtime (WinRT) APIs for modern shell integration
- Learn about Windows 11 shell enhancements and new APIs
- Study advanced notification systems and toast notifications
- Practice with accessibility features and screen readers
- Contribute to open-source shell integration projects
- Explore cross-platform shell integration solutions

---

**Estimated Time**: 12-15 hours
**Difficulty**: Advanced
**Prerequisites**: Windows shell concepts, GUI programming experience
**Next Phase**: [Phase 5 - Expert Level](../Phase%205%20-%20Expert%20Level/)
