# 2.3 Registry Operations

## Module Overview
Master comprehensive Windows Registry manipulation using pywin32. Learn to safely read, write, monitor, and manage registry data with proper error handling and security considerations.

**Duration**: 1 week  
**Focus**: Comprehensive registry manipulation  
**Key Topics**: Registry hives, data types, monitoring, backup/restore  
**Project**: Registry backup and configuration tool

## Learning Objectives
By completing this module, you will:
- Understand Windows Registry structure and organization
- Perform safe registry read/write operations
- Implement registry monitoring and change detection
- Create registry backup and restore utilities
- Handle different registry data types properly
- Manage registry permissions and security

## Registry Fundamentals

### Understanding Registry Structure

```python
import win32api
import win32con
import winreg
import json
from datetime import datetime

# Registry Hive Constants
HIVES = {
    'HKEY_CLASSES_ROOT': winreg.HKEY_CLASSES_ROOT,
    'HKEY_CURRENT_USER': winreg.HKEY_CURRENT_USER,
    'HKEY_LOCAL_MACHINE': winreg.HKEY_LOCAL_MACHINE,
    'HKEY_USERS': winreg.HKEY_USERS,
    'HKEY_CURRENT_CONFIG': winreg.HKEY_CURRENT_CONFIG
}

class RegistryExplorer:
    """Registry structure exploration utility"""
    
    def __init__(self):
        self.hives = HIVES
    
    def list_subkeys(self, hive, subkey_path=""):
        """List all subkeys under a registry path"""
        try:
            with winreg.OpenKey(hive, subkey_path) as key:
                subkeys = []
                index = 0
                while True:
                    try:
                        subkey_name = winreg.EnumKey(key, index)
                        subkeys.append(subkey_name)
                        index += 1
                    except OSError:
                        break
                return subkeys
        except Exception as e:
            print(f"Error accessing {subkey_path}: {e}")
            return []
    
    def list_values(self, hive, subkey_path):
        """List all values under a registry key"""
        try:
            with winreg.OpenKey(hive, subkey_path) as key:
                values = []
                index = 0
                while True:
                    try:
                        value_name, value_data, value_type = winreg.EnumValue(key, index)
                        values.append({
                            'name': value_name,
                            'data': value_data,
                            'type': value_type
                        })
                        index += 1
                    except OSError:
                        break
                return values
        except Exception as e:
            print(f"Error reading values from {subkey_path}: {e}")
            return []
    
    def get_key_info(self, hive, subkey_path):
        """Get detailed information about a registry key"""
        try:
            with winreg.OpenKey(hive, subkey_path) as key:
                num_subkeys, num_values, last_modified = winreg.QueryInfoKey(key)
                return {
                    'subkeys_count': num_subkeys,
                    'values_count': num_values,
                    'last_modified': datetime.fromtimestamp(last_modified / 10000000 - 11644473600)
                }
        except Exception as e:
            print(f"Error getting key info for {subkey_path}: {e}")
            return None

# Example usage
explorer = RegistryExplorer()
software_keys = explorer.list_subkeys(winreg.HKEY_CURRENT_USER, "Software")
print(f"Found {len(software_keys)} software entries")
```

## Registry Data Types

### Understanding Registry Value Types

```python
import winreg
from typing import Any, Dict, List

class RegistryDataHandler:
    """Handle different registry data types"""
    
    DATA_TYPES = {
        winreg.REG_NONE: "REG_NONE",
        winreg.REG_SZ: "REG_SZ",
        winreg.REG_EXPAND_SZ: "REG_EXPAND_SZ",
        winreg.REG_BINARY: "REG_BINARY",
        winreg.REG_DWORD: "REG_DWORD",
        winreg.REG_DWORD_BIG_ENDIAN: "REG_DWORD_BIG_ENDIAN",
        winreg.REG_LINK: "REG_LINK",
        winreg.REG_MULTI_SZ: "REG_MULTI_SZ",
        winreg.REG_RESOURCE_LIST: "REG_RESOURCE_LIST",
        winreg.REG_QWORD: "REG_QWORD"
    }
    
    def read_value(self, hive: int, key_path: str, value_name: str) -> Dict[str, Any]:
        """Read a registry value with type information"""
        try:
            with winreg.OpenKey(hive, key_path) as key:
                value_data, value_type = winreg.QueryValueEx(key, value_name)
                return {
                    'data': value_data,
                    'type': value_type,
                    'type_name': self.DATA_TYPES.get(value_type, "UNKNOWN"),
                    'formatted_data': self._format_data(value_data, value_type)
                }
        except FileNotFoundError:
            return None
        except Exception as e:
            print(f"Error reading value {value_name}: {e}")
            return None
    
    def write_value(self, hive: int, key_path: str, value_name: str, 
                   value_data: Any, value_type: int) -> bool:
        """Write a registry value with proper type handling"""
        try:
            with winreg.CreateKey(hive, key_path) as key:
                winreg.SetValueEx(key, value_name, 0, value_type, value_data)
                return True
        except Exception as e:
            print(f"Error writing value {value_name}: {e}")
            return False
    
    def _format_data(self, data: Any, data_type: int) -> str:
        """Format registry data for display"""
        if data_type == winreg.REG_BINARY:
            return ' '.join(f'{b:02X}' for b in data)
        elif data_type == winreg.REG_MULTI_SZ:
            return '\n'.join(data)
        elif data_type == winreg.REG_DWORD:
            return f"0x{data:08X} ({data})"
        elif data_type == winreg.REG_QWORD:
            return f"0x{data:016X} ({data})"
        else:
            return str(data)

# Example: Working with different data types
handler = RegistryDataHandler()

# Read string value
result = handler.read_value(
    winreg.HKEY_CURRENT_USER,
    r"Control Panel\Desktop",
    "Wallpaper"
)
if result:
    print(f"Wallpaper: {result['formatted_data']}")

# Write DWORD value
success = handler.write_value(
    winreg.HKEY_CURRENT_USER,
    r"Software\MyApp",
    "Settings",
    12345,
    winreg.REG_DWORD
)
```

## Registry Operations

### Safe Registry Read/Write Operations

```python
import winreg
import os
from contextlib import contextmanager
from typing import Optional, Any, Dict

class SafeRegistryManager:
    """Thread-safe registry operations with proper error handling"""
    
    def __init__(self):
        self.backup_data = {}
    
    @contextmanager
    def open_key(self, hive: int, key_path: str, access: int = winreg.KEY_READ):
        """Context manager for safe key operations"""
        key = None
        try:
            key = winreg.OpenKey(hive, key_path, 0, access)
            yield key
        except FileNotFoundError:
            print(f"Registry key not found: {key_path}")
            yield None
        except PermissionError:
            print(f"Permission denied accessing: {key_path}")
            yield None
        except Exception as e:
            print(f"Error opening registry key {key_path}: {e}")
            yield None
        finally:
            if key:
                winreg.CloseKey(key)
    
    def read_registry_tree(self, hive: int, key_path: str) -> Dict:
        """Recursively read entire registry tree"""
        tree = {'values': {}, 'subkeys': {}}
        
        with self.open_key(hive, key_path) as key:
            if key is None:
                return tree
            
            # Read values
            try:
                index = 0
                while True:
                    try:
                        name, data, data_type = winreg.EnumValue(key, index)
                        tree['values'][name] = {
                            'data': data,
                            'type': data_type
                        }
                        index += 1
                    except OSError:
                        break
            except Exception as e:
                print(f"Error reading values: {e}")
            
            # Read subkeys
            try:
                index = 0
                while True:
                    try:
                        subkey_name = winreg.EnumKey(key, index)
                        subkey_path = f"{key_path}\\{subkey_name}" if key_path else subkey_name
                        tree['subkeys'][subkey_name] = self.read_registry_tree(hive, subkey_path)
                        index += 1
                    except OSError:
                        break
            except Exception as e:
                print(f"Error reading subkeys: {e}")
        
        return tree
    
    def write_registry_tree(self, hive: int, key_path: str, tree: Dict) -> bool:
        """Write registry tree with rollback capability"""
        try:
            # Backup existing data
            existing_tree = self.read_registry_tree(hive, key_path)
            backup_key = f"{hive}\\{key_path}"
            self.backup_data[backup_key] = existing_tree
            
            # Write values
            if 'values' in tree:
                for name, value_info in tree['values'].items():
                    with winreg.CreateKey(hive, key_path) as key:
                        winreg.SetValueEx(
                            key, name, 0, 
                            value_info['type'], 
                            value_info['data']
                        )
            
            # Write subkeys recursively
            if 'subkeys' in tree:
                for subkey_name, subtree in tree['subkeys'].items():
                    subkey_path = f"{key_path}\\{subkey_name}" if key_path else subkey_name
                    self.write_registry_tree(hive, subkey_path, subtree)
            
            return True
            
        except Exception as e:
            print(f"Error writing registry tree: {e}")
            self.rollback_changes(hive, key_path)
            return False
    
    def rollback_changes(self, hive: int, key_path: str) -> bool:
        """Rollback registry changes"""
        backup_key = f"{hive}\\{key_path}"
        if backup_key in self.backup_data:
            try:
                self.delete_key_tree(hive, key_path)
                self.write_registry_tree(hive, key_path, self.backup_data[backup_key])
                del self.backup_data[backup_key]
                return True
            except Exception as e:
                print(f"Error during rollback: {e}")
        return False
    
    def delete_key_tree(self, hive: int, key_path: str) -> bool:
        """Recursively delete registry key and all subkeys"""
        try:
            with self.open_key(hive, key_path, winreg.KEY_ALL_ACCESS) as key:
                if key is None:
                    return True
                
                # Delete all subkeys first
                subkeys = []
                index = 0
                while True:
                    try:
                        subkey_name = winreg.EnumKey(key, index)
                        subkeys.append(subkey_name)
                        index += 1
                    except OSError:
                        break
                
                for subkey_name in subkeys:
                    subkey_path = f"{key_path}\\{subkey_name}"
                    self.delete_key_tree(hive, subkey_path)
            
            # Delete the key itself
            winreg.DeleteKey(hive, key_path)
            return True
            
        except Exception as e:
            print(f"Error deleting key tree {key_path}: {e}")
            return False
```

## Registry Monitoring

### Real-time Registry Change Detection

```python
import win32api
import win32con
import win32event
import threading
import time
from typing import Callable, Optional

class RegistryMonitor:
    """Monitor registry changes in real-time"""
    
    def __init__(self):
        self.monitoring = False
        self.monitor_threads = []
        self.callbacks = {}
    
    def start_monitoring(self, hive: int, key_path: str, 
                        callback: Callable, recursive: bool = True):
        """Start monitoring registry changes"""
        monitor_id = f"{hive}\\{key_path}"
        
        if monitor_id in self.callbacks:
            print(f"Already monitoring {key_path}")
            return False
        
        self.callbacks[monitor_id] = callback
        
        # Create monitoring thread
        thread = threading.Thread(
            target=self._monitor_key,
            args=(hive, key_path, callback, recursive, monitor_id),
            daemon=True
        )
        thread.start()
        self.monitor_threads.append(thread)
        
        print(f"Started monitoring: {key_path}")
        return True
    
    def stop_monitoring(self, hive: int, key_path: str):
        """Stop monitoring specific registry key"""
        monitor_id = f"{hive}\\{key_path}"
        if monitor_id in self.callbacks:
            del self.callbacks[monitor_id]
            print(f"Stopped monitoring: {key_path}")
    
    def stop_all_monitoring(self):
        """Stop all registry monitoring"""
        self.monitoring = False
        self.callbacks.clear()
        print("Stopped all registry monitoring")
    
    def _monitor_key(self, hive: int, key_path: str, callback: Callable,
                    recursive: bool, monitor_id: str):
        """Internal monitoring implementation"""
        try:
            # Open registry key for monitoring
            key = win32api.RegOpenKeyEx(
                hive, key_path, 0, 
                win32con.KEY_NOTIFY | win32con.KEY_READ
            )
            
            # Create event for notification
            event = win32event.CreateEvent(None, False, False, None)
            
            while monitor_id in self.callbacks:
                try:
                    # Wait for registry change
                    filter_flags = (
                        win32api.REG_NOTIFY_CHANGE_NAME |
                        win32api.REG_NOTIFY_CHANGE_ATTRIBUTES |
                        win32api.REG_NOTIFY_CHANGE_LAST_SET |
                        win32api.REG_NOTIFY_CHANGE_SECURITY
                    )
                    
                    win32api.RegNotifyChangeKeyValue(
                        key, recursive, filter_flags, event, True
                    )
                    
                    # Wait for change event
                    result = win32event.WaitForSingleObject(event, 5000)  # 5 second timeout
                    
                    if result == win32event.WAIT_OBJECT_0:
                        # Registry change detected
                        change_info = {
                            'hive': hive,
                            'key_path': key_path,
                            'timestamp': time.time(),
                            'recursive': recursive
                        }
                        callback(change_info)
                    
                except Exception as e:
                    print(f"Error monitoring registry: {e}")
                    break
            
        except Exception as e:
            print(f"Error setting up registry monitoring: {e}")
        finally:
            try:
                win32api.RegCloseKey(key)
                win32event.CloseHandle(event)
            except:
                pass

# Example usage
def on_registry_change(change_info):
    """Callback for registry changes"""
    print(f"Registry change detected:")
    print(f"  Key: {change_info['key_path']}")
    print(f"  Time: {time.ctime(change_info['timestamp'])}")
    print(f"  Recursive: {change_info['recursive']}")

monitor = RegistryMonitor()

# Monitor software installations
monitor.start_monitoring(
    winreg.HKEY_LOCAL_MACHINE,
    r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
    on_registry_change
)

# Monitor user preferences
monitor.start_monitoring(
    winreg.HKEY_CURRENT_USER,
    r"Software",
    on_registry_change,
    recursive=True
)
```

## Registry Backup and Restore

### Complete Backup Solution

```python
import winreg
import json
import os
import gzip
import hashlib
from datetime import datetime
from typing import Dict, List, Optional

class RegistryBackupManager:
    """Comprehensive registry backup and restore utility"""
    
    def __init__(self, backup_dir: str = "registry_backups"):
        self.backup_dir = backup_dir
        os.makedirs(backup_dir, exist_ok=True)
    
    def create_backup(self, hive: int, key_path: str, 
                     backup_name: Optional[str] = None) -> str:
        """Create compressed registry backup"""
        if backup_name is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"backup_{timestamp}"
        
        backup_file = os.path.join(self.backup_dir, f"{backup_name}.json.gz")
        
        try:
            # Read registry tree
            print(f"Reading registry tree: {key_path}")
            registry_data = self._read_registry_tree_safe(hive, key_path)
            
            # Create backup metadata
            backup_metadata = {
                'backup_name': backup_name,
                'timestamp': datetime.now().isoformat(),
                'hive': hive,
                'key_path': key_path,
                'version': '1.0',
                'checksum': '',
                'data': registry_data
            }
            
            # Calculate checksum
            data_str = json.dumps(registry_data, sort_keys=True)
            backup_metadata['checksum'] = hashlib.sha256(data_str.encode()).hexdigest()
            
            # Save compressed backup
            with gzip.open(backup_file, 'wt', encoding='utf-8') as f:
                json.dump(backup_metadata, f, indent=2, default=str)
            
            print(f"Backup created: {backup_file}")
            return backup_file
            
        except Exception as e:
            print(f"Error creating backup: {e}")
            return None
    
    def restore_backup(self, backup_file: str, verify_checksum: bool = True) -> bool:
        """Restore registry from backup file"""
        try:
            # Load backup
            with gzip.open(backup_file, 'rt', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            # Verify backup integrity
            if verify_checksum:
                data_str = json.dumps(backup_data['data'], sort_keys=True)
                calculated_checksum = hashlib.sha256(data_str.encode()).hexdigest()
                if calculated_checksum != backup_data['checksum']:
                    print("Backup checksum verification failed!")
                    return False
            
            # Create current backup before restore
            current_backup = self.create_backup(
                backup_data['hive'],
                backup_data['key_path'],
                f"pre_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            )
            
            if current_backup:
                print(f"Current state backed up to: {current_backup}")
            
            # Restore registry data
            success = self._write_registry_tree_safe(
                backup_data['hive'],
                backup_data['key_path'],
                backup_data['data']
            )
            
            if success:
                print(f"Registry restored from: {backup_file}")
            else:
                print("Registry restore failed!")
            
            return success
            
        except Exception as e:
            print(f"Error restoring backup: {e}")
            return False
    
    def list_backups(self) -> List[Dict]:
        """List all available backups"""
        backups = []
        
        for filename in os.listdir(self.backup_dir):
            if filename.endswith('.json.gz'):
                filepath = os.path.join(self.backup_dir, filename)
                try:
                    with gzip.open(filepath, 'rt', encoding='utf-8') as f:
                        backup_data = json.load(f)
                    
                    backups.append({
                        'filename': filename,
                        'filepath': filepath,
                        'backup_name': backup_data.get('backup_name', 'Unknown'),
                        'timestamp': backup_data.get('timestamp', 'Unknown'),
                        'key_path': backup_data.get('key_path', 'Unknown'),
                        'size': os.path.getsize(filepath)
                    })
                except Exception as e:
                    print(f"Error reading backup {filename}: {e}")
        
        return sorted(backups, key=lambda x: x['timestamp'], reverse=True)
    
    def compare_backups(self, backup1: str, backup2: str) -> Dict:
        """Compare two backup files"""
        try:
            # Load both backups
            with gzip.open(backup1, 'rt', encoding='utf-8') as f:
                data1 = json.load(f)
            
            with gzip.open(backup2, 'rt', encoding='utf-8') as f:
                data2 = json.load(f)
            
            # Compare data
            differences = self._compare_registry_trees(
                data1['data'], data2['data']
            )
            
            return {
                'backup1': backup1,
                'backup2': backup2,
                'timestamp1': data1.get('timestamp'),
                'timestamp2': data2.get('timestamp'),
                'differences': differences
            }
            
        except Exception as e:
            print(f"Error comparing backups: {e}")
            return {}
    
    def _read_registry_tree_safe(self, hive: int, key_path: str) -> Dict:
        """Safely read registry tree with error handling"""
        tree = {'values': {}, 'subkeys': {}}
        
        try:
            with winreg.OpenKey(hive, key_path) as key:
                # Read values
                index = 0
                while True:
                    try:
                        name, data, data_type = winreg.EnumValue(key, index)
                        # Convert binary data to base64 for JSON serialization
                        if data_type == winreg.REG_BINARY:
                            import base64
                            data = base64.b64encode(data).decode('ascii')
                        tree['values'][name] = {
                            'data': data,
                            'type': data_type
                        }
                        index += 1
                    except OSError:
                        break
                
                # Read subkeys
                index = 0
                while True:
                    try:
                        subkey_name = winreg.EnumKey(key, index)
                        subkey_path = f"{key_path}\\{subkey_name}" if key_path else subkey_name
                        tree['subkeys'][subkey_name] = self._read_registry_tree_safe(hive, subkey_path)
                        index += 1
                    except OSError:
                        break
                    except Exception as e:
                        print(f"Error reading subkey {subkey_name}: {e}")
                        
        except Exception as e:
            print(f"Error reading registry key {key_path}: {e}")
        
        return tree
    
    def _write_registry_tree_safe(self, hive: int, key_path: str, tree: Dict) -> bool:
        """Safely write registry tree"""
        try:
            # Write values
            if 'values' in tree:
                for name, value_info in tree['values'].items():
                    try:
                        data = value_info['data']
                        data_type = value_info['type']
                        
                        # Convert base64 back to binary
                        if data_type == winreg.REG_BINARY and isinstance(data, str):
                            import base64
                            data = base64.b64decode(data.encode('ascii'))
                        
                        with winreg.CreateKey(hive, key_path) as key:
                            winreg.SetValueEx(key, name, 0, data_type, data)
                    except Exception as e:
                        print(f"Error writing value {name}: {e}")
            
            # Write subkeys
            if 'subkeys' in tree:
                for subkey_name, subtree in tree['subkeys'].items():
                    subkey_path = f"{key_path}\\{subkey_name}" if key_path else subkey_name
                    self._write_registry_tree_safe(hive, subkey_path, subtree)
            
            return True
            
        except Exception as e:
            print(f"Error writing registry tree: {e}")
            return False
    
    def _compare_registry_trees(self, tree1: Dict, tree2: Dict) -> Dict:
        """Compare two registry trees"""
        differences = {
            'added_values': {},
            'removed_values': {},
            'modified_values': {},
            'added_keys': {},
            'removed_keys': {}
        }
        
        # Compare values
        values1 = tree1.get('values', {})
        values2 = tree2.get('values', {})
        
        for name in values1:
            if name not in values2:
                differences['removed_values'][name] = values1[name]
            elif values1[name] != values2[name]:
                differences['modified_values'][name] = {
                    'old': values1[name],
                    'new': values2[name]
                }
        
        for name in values2:
            if name not in values1:
                differences['added_values'][name] = values2[name]
        
        # Compare subkeys
        subkeys1 = tree1.get('subkeys', {})
        subkeys2 = tree2.get('subkeys', {})
        
        for name in subkeys1:
            if name not in subkeys2:
                differences['removed_keys'][name] = True
        
        for name in subkeys2:
            if name not in subkeys1:
                differences['added_keys'][name] = True
        
        return differences

# Example usage
backup_manager = RegistryBackupManager()

# Create backup
backup_file = backup_manager.create_backup(
    winreg.HKEY_CURRENT_USER,
    r"Software\MyApp",
    "myapp_config_backup"
)

# List backups
backups = backup_manager.list_backups()
for backup in backups:
    print(f"Backup: {backup['backup_name']} - {backup['timestamp']}")

# Restore backup
if backup_file:
    success = backup_manager.restore_backup(backup_file)
    print(f"Restore successful: {success}")
```

## Practical Project: Registry Configuration Tool

### Complete Registry Management Application

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import winreg
import threading
from datetime import datetime

class RegistryConfigTool:
    """Complete registry configuration and backup tool"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Registry Configuration Tool")
        self.root.geometry("800x600")
        
        self.backup_manager = RegistryBackupManager()
        self.registry_monitor = RegistryMonitor()
        
        self.setup_ui()
        self.current_hive = winreg.HKEY_CURRENT_USER
        self.current_path = ""
    
    def setup_ui(self):
        """Setup the user interface"""
        # Create main frames
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Navigation frame
        nav_frame = ttk.LabelFrame(main_frame, text="Navigation")
        nav_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Hive selection
        ttk.Label(nav_frame, text="Hive:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.hive_var = tk.StringVar(value="HKEY_CURRENT_USER")
        hive_combo = ttk.Combobox(nav_frame, textvariable=self.hive_var, values=[
            "HKEY_CURRENT_USER", "HKEY_LOCAL_MACHINE", "HKEY_CLASSES_ROOT",
            "HKEY_USERS", "HKEY_CURRENT_CONFIG"
        ])
        hive_combo.grid(row=0, column=1, padx=5, pady=5)
        hive_combo.bind('<<ComboboxSelected>>', self.on_hive_changed)
        
        # Path entry
        ttk.Label(nav_frame, text="Path:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)
        self.path_var = tk.StringVar()
        path_entry = ttk.Entry(nav_frame, textvariable=self.path_var, width=40)
        path_entry.grid(row=0, column=3, padx=5, pady=5, sticky=tk.EW)
        path_entry.bind('<Return>', self.navigate_to_path)
        
        # Navigate button
        ttk.Button(nav_frame, text="Navigate", command=self.navigate_to_path).grid(
            row=0, column=4, padx=5, pady=5)
        
        nav_frame.columnconfigure(3, weight=1)
        
        # Content frame with tabs
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Registry browser tab
        self.setup_browser_tab(notebook)
        
        # Backup manager tab
        self.setup_backup_tab(notebook)
        
        # Monitor tab
        self.setup_monitor_tab(notebook)
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(fill=tk.X, pady=(10, 0))
    
    def setup_browser_tab(self, notebook):
        """Setup registry browser tab"""
        browser_frame = ttk.Frame(notebook)
        notebook.add(browser_frame, text="Registry Browser")
        
        # Tree view for registry structure
        tree_frame = ttk.Frame(browser_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.tree = ttk.Treeview(tree_frame)
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=tree_scroll.set)
        
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.tree.bind('<<TreeviewSelect>>', self.on_tree_select)
        
        # Values listbox
        values_frame = ttk.LabelFrame(browser_frame, text="Values")
        values_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Values treeview
        self.values_tree = ttk.Treeview(values_frame, columns=('Value', 'Type', 'Data'), show='headings')
        self.values_tree.heading('Value', text='Name')
        self.values_tree.heading('Type', text='Type')
        self.values_tree.heading('Data', text='Data')
        
        values_scroll = ttk.Scrollbar(values_frame, orient=tk.VERTICAL, command=self.values_tree.yview)
        self.values_tree.configure(yscrollcommand=values_scroll.set)
        
        self.values_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        values_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Action buttons
        button_frame = ttk.Frame(browser_frame)
        button_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(button_frame, text="Refresh", command=self.refresh_view).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export Key", command=self.export_key).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Import Key", command=self.import_key).pack(side=tk.LEFT, padx=5)
    
    def setup_backup_tab(self, notebook):
        """Setup backup manager tab"""
        backup_frame = ttk.Frame(notebook)
        notebook.add(backup_frame, text="Backup Manager")
        
        # Backup list
        list_frame = ttk.LabelFrame(backup_frame, text="Available Backups")
        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.backup_listbox = tk.Listbox(list_frame)
        backup_scroll = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.backup_listbox.yview)
        self.backup_listbox.configure(yscrollcommand=backup_scroll.set)
        
        self.backup_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        backup_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Backup controls
        controls_frame = ttk.Frame(backup_frame)
        controls_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(controls_frame, text="Create Backup", command=self.create_backup).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Restore Backup", command=self.restore_backup).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Delete Backup", command=self.delete_backup).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Refresh List", command=self.refresh_backup_list).pack(side=tk.LEFT, padx=5)
        
        self.refresh_backup_list()
    
    def setup_monitor_tab(self, notebook):
        """Setup registry monitor tab"""
        monitor_frame = ttk.Frame(notebook)
        notebook.add(monitor_frame, text="Registry Monitor")
        
        # Monitor controls
        controls_frame = ttk.Frame(monitor_frame)
        controls_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(controls_frame, text="Start Monitoring", command=self.start_monitoring).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Stop Monitoring", command=self.stop_monitoring).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Clear Log", command=self.clear_monitor_log).pack(side=tk.LEFT, padx=5)
        
        # Monitor log
        log_frame = ttk.LabelFrame(monitor_frame, text="Change Log")
        log_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.monitor_text = tk.Text(log_frame, wrap=tk.WORD)
        monitor_scroll = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.monitor_text.yview)
        self.monitor_text.configure(yscrollcommand=monitor_scroll.set)
        
        self.monitor_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        monitor_scroll.pack(side=tk.RIGHT, fill=tk.Y)
    
    def on_hive_changed(self, event=None):
        """Handle hive selection change"""
        hive_name = self.hive_var.get()
        self.current_hive = {
            "HKEY_CURRENT_USER": winreg.HKEY_CURRENT_USER,
            "HKEY_LOCAL_MACHINE": winreg.HKEY_LOCAL_MACHINE,
            "HKEY_CLASSES_ROOT": winreg.HKEY_CLASSES_ROOT,
            "HKEY_USERS": winreg.HKEY_USERS,
            "HKEY_CURRENT_CONFIG": winreg.HKEY_CURRENT_CONFIG
        }.get(hive_name, winreg.HKEY_CURRENT_USER)
        
        self.refresh_view()
    
    def navigate_to_path(self, event=None):
        """Navigate to specified registry path"""
        self.current_path = self.path_var.get()
        self.refresh_view()
    
    def refresh_view(self):
        """Refresh the registry view"""
        def refresh_thread():
            try:
                self.status_var.set("Loading...")
                
                # Clear existing items
                self.tree.delete(*self.tree.get_children())
                self.values_tree.delete(*self.values_tree.get_children())
                
                # Load registry structure
                explorer = RegistryExplorer()
                subkeys = explorer.list_subkeys(self.current_hive, self.current_path)
                
                for subkey in subkeys:
                    self.tree.insert('', 'end', text=subkey, values=(subkey,))
                
                # Load values
                values = explorer.list_values(self.current_hive, self.current_path)
                for value in values:
                    self.values_tree.insert('', 'end', values=(
                        value['name'],
                        RegistryDataHandler.DATA_TYPES.get(value['type'], 'UNKNOWN'),
                        str(value['data'])[:100]  # Truncate long values
                    ))
                
                self.status_var.set(f"Loaded {len(subkeys)} keys, {len(values)} values")
                
            except Exception as e:
                self.status_var.set(f"Error: {e}")
        
        threading.Thread(target=refresh_thread, daemon=True).start()
    
    def create_backup(self):
        """Create registry backup"""
        if not self.current_path:
            messagebox.showwarning("Warning", "Please select a registry path to backup")
            return
        
        backup_name = tk.simpledialog.askstring("Backup Name", "Enter backup name:")
        if backup_name:
            def backup_thread():
                backup_file = self.backup_manager.create_backup(
                    self.current_hive, self.current_path, backup_name
                )
                if backup_file:
                    self.root.after(0, lambda: messagebox.showinfo("Success", f"Backup created: {backup_file}"))
                    self.root.after(0, self.refresh_backup_list)
                else:
                    self.root.after(0, lambda: messagebox.showerror("Error", "Failed to create backup"))
            
            threading.Thread(target=backup_thread, daemon=True).start()
    
    def restore_backup(self):
        """Restore selected backup"""
        selection = self.backup_listbox.curselection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a backup to restore")
            return
        
        backup_info = self.backup_list[selection[0]]
        
        if messagebox.askyesno("Confirm Restore", 
                              f"Are you sure you want to restore backup '{backup_info['backup_name']}'?"):
            def restore_thread():
                success = self.backup_manager.restore_backup(backup_info['filepath'])
                if success:
                    self.root.after(0, lambda: messagebox.showinfo("Success", "Backup restored successfully"))
                    self.root.after(0, self.refresh_view)
                else:
                    self.root.after(0, lambda: messagebox.showerror("Error", "Failed to restore backup"))
            
            threading.Thread(target=restore_thread, daemon=True).start()
    
    def refresh_backup_list(self):
        """Refresh backup list"""
        self.backup_listbox.delete(0, tk.END)
        self.backup_list = self.backup_manager.list_backups()
        
        for backup in self.backup_list:
            display_text = f"{backup['backup_name']} - {backup['timestamp']} - {backup['key_path']}"
            self.backup_listbox.insert(tk.END, display_text)
    
    def start_monitoring(self):
        """Start registry monitoring"""
        if not self.current_path:
            messagebox.showwarning("Warning", "Please select a registry path to monitor")
            return
        
        def on_change(change_info):
            timestamp = datetime.fromtimestamp(change_info['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
            message = f"[{timestamp}] Change detected in: {change_info['key_path']}\n"
            
            self.root.after(0, lambda: self.monitor_text.insert(tk.END, message))
            self.root.after(0, lambda: self.monitor_text.see(tk.END))
        
        success = self.registry_monitor.start_monitoring(
            self.current_hive, self.current_path, on_change
        )
        
        if success:
            self.status_var.set("Registry monitoring started")
        else:
            messagebox.showerror("Error", "Failed to start monitoring")
    
    def stop_monitoring(self):
        """Stop registry monitoring"""
        self.registry_monitor.stop_all_monitoring()
        self.status_var.set("Registry monitoring stopped")
    
    def clear_monitor_log(self):
        """Clear monitor log"""
        self.monitor_text.delete(1.0, tk.END)
    
    def run(self):
        """Run the application"""
        self.root.mainloop()

# Run the application
if __name__ == "__main__":
    app = RegistryConfigTool()
    app.run()
```

## Best Practices and Security

### Registry Security Guidelines

```python
import win32security
import win32api
import win32con
import ntsecuritycon

class RegistrySecurity:
    """Registry security management utilities"""
    
    def check_key_permissions(self, hive: int, key_path: str) -> Dict:
        """Check current user permissions on registry key"""
        try:
            # Open key with READ_CONTROL access
            key = win32api.RegOpenKeyEx(
                hive, key_path, 0, 
                win32con.KEY_READ | win32con.READ_CONTROL
            )
            
            # Get security descriptor
            sd = win32api.RegGetKeySecurity(key, win32security.DACL_SECURITY_INFORMATION)
            
            # Get DACL
            dacl = sd.GetSecurityDescriptorDacl()
            
            permissions = {
                'can_read': False,
                'can_write': False,
                'can_delete': False,
                'is_owner': False
            }
            
            # Check current user permissions
            # This is a simplified check - full implementation would be more complex
            try:
                win32api.RegOpenKeyEx(hive, key_path, 0, win32con.KEY_READ)
                permissions['can_read'] = True
            except:
                pass
            
            try:
                win32api.RegOpenKeyEx(hive, key_path, 0, win32con.KEY_WRITE)
                permissions['can_write'] = True
            except:
                pass
            
            try:
                win32api.RegOpenKeyEx(hive, key_path, 0, win32con.DELETE)
                permissions['can_delete'] = True
            except:
                pass
            
            win32api.RegCloseKey(key)
            return permissions
            
        except Exception as e:
            print(f"Error checking permissions: {e}")
            return {}
    
    def secure_registry_operation(self, operation_func, *args, **kwargs):
        """Wrapper for secure registry operations"""
        try:
            # Check if running with appropriate privileges
            if not self.has_admin_privileges():
                print("Warning: Operation may require administrator privileges")
            
            # Perform operation with error handling
            return operation_func(*args, **kwargs)
            
        except PermissionError:
            print("Permission denied. Try running as administrator.")
            return None
        except Exception as e:
            print(f"Registry operation failed: {e}")
            return None
    
    def has_admin_privileges(self) -> bool:
        """Check if current process has administrator privileges"""
        try:
            return win32security.CheckTokenMembership(
                None, win32security.CreateWellKnownSid(win32security.WinBuiltinAdministratorsSid)
            )
        except:
            return False

# Security best practices example
security = RegistrySecurity()

def safe_registry_write(hive, key_path, value_name, value_data, value_type):
    """Safely write to registry with security checks"""
    
    # Check permissions first
    permissions = security.check_key_permissions(hive, key_path)
    if not permissions.get('can_write', False):
        print("Insufficient permissions to write to registry key")
        return False
    
    # Create backup before modification
    backup_manager = RegistryBackupManager()
    backup_file = backup_manager.create_backup(
        hive, key_path, f"auto_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    )
    
    # Perform secure write operation
    def write_operation():
        with winreg.CreateKey(hive, key_path) as key:
            winreg.SetValueEx(key, value_name, 0, value_type, value_data)
        return True
    
    result = security.secure_registry_operation(write_operation)
    
    if result:
        print(f"Registry value written successfully. Backup: {backup_file}")
    else:
        print("Failed to write registry value")
    
    return result is not None
```

## Common Challenges and Solutions

### Handling Registry Virtualization

```python
import os
import sys

def detect_registry_virtualization():
    """Detect if registry virtualization is active"""
    try:
        # Check if running in virtualization-aware mode
        if hasattr(sys, 'winver') and sys.winver >= (6, 0):
            # Vista and later support registry virtualization
            test_key = r"SOFTWARE\Classes\.test"
            
            # Try to write to a virtualized location
            try:
                with winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, test_key) as key:
                    winreg.SetValueEx(key, "test", 0, winreg.REG_SZ, "test")
                
                # If successful, check if it was virtualized
                virtual_path = os.path.join(
                    os.environ.get('USERPROFILE', ''),
                    r'AppData\Local\VirtualStore\MACHINE\SOFTWARE\Classes\.test'
                )
                
                if os.path.exists(virtual_path):
                    print("Registry virtualization is active")
                    return True
                    
            except Exception:
                pass
            
            # Clean up test key
            try:
                winreg.DeleteKey(winreg.HKEY_LOCAL_MACHINE, test_key)
            except:
                pass
    
    except Exception as e:
        print(f"Error detecting virtualization: {e}")
    
    return False

# Handle 32-bit/64-bit registry redirection
def access_64bit_registry():
    """Access 64-bit registry from 32-bit process"""
    try:
        # Use KEY_WOW64_64KEY flag to access 64-bit registry
        with winreg.OpenKey(
            winreg.HKEY_LOCAL_MACHINE,
            r"SOFTWARE\Microsoft\Windows\CurrentVersion",
            0,
            winreg.KEY_READ | winreg.KEY_WOW64_64KEY
        ) as key:
            value, _ = winreg.QueryValueEx(key, "ProgramFilesDir")
            print(f"64-bit Program Files: {value}")
            return value
    except Exception as e:
        print(f"Error accessing 64-bit registry: {e}")
        return None
```

## Module Summary

### Key Concepts Mastered
- Registry structure and hives
- Safe read/write operations
- Registry data types and handling
- Real-time change monitoring
- Backup and restore operations
- Security considerations
- Registry virtualization

### Practical Skills Gained
- Building registry management tools
- Creating backup systems
- Implementing change monitoring
- Handling permissions and security
- Error recovery and rollback
- Performance optimization

### Common Use Cases
- Configuration management
- System monitoring
- Application settings
- Security auditing
- Data migration
- Troubleshooting

## Next Steps

### Preparation for 2.4 Window Management
- Review window concepts
- Understand message handling
- Practice with GUI automation
- Study multi-monitor support

### Advanced Topics to Explore
- Registry performance optimization
- Custom registry data types
- Registry-based communication
- Distributed configuration management

---

**Module Complete!** 
**Estimated Completion Time**: 1 week (8-12 hours)  
**Next Module**: [2.4 Window Management](./2.4%20Window%20Management.md)  
**Project Status**: Registry backup and configuration tool ready for deployment
