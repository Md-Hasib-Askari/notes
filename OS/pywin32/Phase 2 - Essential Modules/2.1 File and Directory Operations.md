# 2.1 File and Directory Operations

## Learning Objectives
By the end of this section, you will:
- Master advanced file operations with win32file
- Understand Windows file security and permissions
- Implement file monitoring and change detection
- Handle file I/O operations efficiently
- Build robust file management utilities

## Win32file Module Overview

### Core Concepts
The `win32file` module provides direct access to Windows file system APIs, offering more control and functionality than Python's built-in file operations.

### Key Advantages
- Direct Windows API access
- Advanced file attributes and permissions
- Asynchronous I/O operations
- File locking mechanisms
- Change notification support

## Advanced File Operations

### File Creation and Access
```python
import win32file
import win32con
import pywintypes

class AdvancedFileManager:
    """Advanced file operations using win32file"""
    
    @staticmethod
    def create_file_with_attributes(filename, content="", attributes=None):
        """Create file with specific attributes"""
        try:
            # Create file handle
            handle = win32file.CreateFile(
                filename,
                win32con.GENERIC_WRITE,
                0,  # No sharing
                None,  # Default security
                win32con.CREATE_ALWAYS,
                win32con.FILE_ATTRIBUTE_NORMAL,
                None
            )
            
            # Write content if provided
            if content:
                win32file.WriteFile(handle, content.encode('utf-8'))
            
            # Close handle
            win32file.CloseHandle(handle)
            
            # Set custom attributes if provided
            if attributes:
                current_attrs = win32file.GetFileAttributes(filename)
                for attr in attributes:
                    current_attrs |= attr
                win32file.SetFileAttributes(filename, current_attrs)
            
            return True
            
        except pywintypes.error as e:
            print(f"Error creating file: {e}")
            return False
    
    @staticmethod
    def read_file_with_handle(filename, buffer_size=4096):
        """Read file using win32file handle"""
        handle = None
        try:
            # Open file for reading
            handle = win32file.CreateFile(
                filename,
                win32con.GENERIC_READ,
                win32con.FILE_SHARE_READ,
                None,
                win32con.OPEN_EXISTING,
                0,
                None
            )
            
            # Get file size
            file_size = win32file.GetFileSize(handle)
            print(f"File size: {file_size} bytes")
            
            # Read file content
            content = b""
            bytes_read = 0
            
            while bytes_read < file_size:
                result, data = win32file.ReadFile(handle, buffer_size)
                content += data
                bytes_read += len(data)
                
                # Show progress
                progress = (bytes_read / file_size) * 100
                print(f"\rReading: {progress:.1f}%", end="", flush=True)
            
            print()  # New line after progress
            return content.decode('utf-8', errors='ignore')
            
        except pywintypes.error as e:
            print(f"Error reading file: {e}")
            return None
        finally:
            if handle:
                win32file.CloseHandle(handle)

# Example usage
def file_operations_demo():
    """Demonstrate advanced file operations"""
    manager = AdvancedFileManager()
    
    # Create file with hidden and readonly attributes
    filename = "test_advanced.txt"
    content = "This is a test file with advanced attributes"
    attributes = [win32con.FILE_ATTRIBUTE_HIDDEN, win32con.FILE_ATTRIBUTE_READONLY]
    
    if manager.create_file_with_attributes(filename, content, attributes):
        print(f"Created {filename} with special attributes")
        
        # Remove readonly to allow reading
        current_attrs = win32file.GetFileAttributes(filename)
        current_attrs &= ~win32con.FILE_ATTRIBUTE_READONLY
        win32file.SetFileAttributes(filename, current_attrs)
        
        # Read the file
        read_content = manager.read_file_with_handle(filename)
        print(f"Read content: {read_content}")

# Run the demo
file_operations_demo()
```

### File Attributes and Properties
```python
import win32file
import win32con
import time

class FileAttributeManager:
    """Manage file attributes and properties"""
    
    def __init__(self):
        self.attribute_names = {
            win32con.FILE_ATTRIBUTE_ARCHIVE: "Archive",
            win32con.FILE_ATTRIBUTE_COMPRESSED: "Compressed",
            win32con.FILE_ATTRIBUTE_DIRECTORY: "Directory",
            win32con.FILE_ATTRIBUTE_ENCRYPTED: "Encrypted",
            win32con.FILE_ATTRIBUTE_HIDDEN: "Hidden",
            win32con.FILE_ATTRIBUTE_NORMAL: "Normal",
            win32con.FILE_ATTRIBUTE_READONLY: "Read-only",
            win32con.FILE_ATTRIBUTE_SYSTEM: "System",
            win32con.FILE_ATTRIBUTE_TEMPORARY: "Temporary"
        }
    
    def get_file_attributes(self, filename):
        """Get detailed file attributes"""
        try:
            attrs = win32file.GetFileAttributes(filename)
            active_attributes = []
            
            for attr_value, attr_name in self.attribute_names.items():
                if attrs & attr_value:
                    active_attributes.append(attr_name)
            
            return {
                'raw_attributes': attrs,
                'active_attributes': active_attributes,
                'is_directory': bool(attrs & win32con.FILE_ATTRIBUTE_DIRECTORY),
                'is_hidden': bool(attrs & win32con.FILE_ATTRIBUTE_HIDDEN),
                'is_readonly': bool(attrs & win32con.FILE_ATTRIBUTE_READONLY),
                'is_compressed': bool(attrs & win32con.FILE_ATTRIBUTE_COMPRESSED),
                'is_encrypted': bool(attrs & win32con.FILE_ATTRIBUTE_ENCRYPTED)
            }
        except Exception as e:
            print(f"Error getting attributes: {e}")
            return None
    
    def set_file_attributes(self, filename, **kwargs):
        """Set file attributes using keyword arguments"""
        try:
            current_attrs = win32file.GetFileAttributes(filename)
            new_attrs = current_attrs
            
            # Handle each attribute
            if 'hidden' in kwargs:
                if kwargs['hidden']:
                    new_attrs |= win32con.FILE_ATTRIBUTE_HIDDEN
                else:
                    new_attrs &= ~win32con.FILE_ATTRIBUTE_HIDDEN
            
            if 'readonly' in kwargs:
                if kwargs['readonly']:
                    new_attrs |= win32con.FILE_ATTRIBUTE_READONLY
                else:
                    new_attrs &= ~win32con.FILE_ATTRIBUTE_READONLY
            
            if 'archive' in kwargs:
                if kwargs['archive']:
                    new_attrs |= win32con.FILE_ATTRIBUTE_ARCHIVE
                else:
                    new_attrs &= ~win32con.FILE_ATTRIBUTE_ARCHIVE
            
            # Set the new attributes
            win32file.SetFileAttributes(filename, new_attrs)
            return True
            
        except Exception as e:
            print(f"Error setting attributes: {e}")
            return False
    
    def get_file_times(self, filename):
        """Get file creation, access, and modification times"""
        handle = None
        try:
            handle = win32file.CreateFile(
                filename,
                win32con.GENERIC_READ,
                win32con.FILE_SHARE_READ,
                None,
                win32con.OPEN_EXISTING,
                0,
                None
            )
            
            creation_time, access_time, write_time = win32file.GetFileTime(handle)
            
            return {
                'creation_time': creation_time,
                'access_time': access_time,
                'write_time': write_time,
                'creation_time_str': creation_time.Format(),
                'access_time_str': access_time.Format(),
                'write_time_str': write_time.Format()
            }
            
        except Exception as e:
            print(f"Error getting file times: {e}")
            return None
        finally:
            if handle:
                win32file.CloseHandle(handle)

# Example usage
def attribute_demo():
    """Demonstrate file attribute management"""
    manager = FileAttributeManager()
    
    # Create a test file
    test_file = "attribute_test.txt"
    with open(test_file, 'w') as f:
        f.write("Testing file attributes")
    
    print("=== INITIAL ATTRIBUTES ===")
    attrs = manager.get_file_attributes(test_file)
    if attrs:
        print(f"Active attributes: {', '.join(attrs['active_attributes'])}")
        print(f"Is hidden: {attrs['is_hidden']}")
        print(f"Is readonly: {attrs['is_readonly']}")
    
    print("\n=== SETTING ATTRIBUTES ===")
    # Make file hidden and readonly
    if manager.set_file_attributes(test_file, hidden=True, readonly=True):
        print("Set file to hidden and readonly")
    
    # Check attributes again
    attrs = manager.get_file_attributes(test_file)
    if attrs:
        print(f"New attributes: {', '.join(attrs['active_attributes'])}")
    
    print("\n=== FILE TIMES ===")
    times = manager.get_file_times(test_file)
    if times:
        print(f"Created: {times['creation_time_str']}")
        print(f"Modified: {times['write_time_str']}")
        print(f"Accessed: {times['access_time_str']}")
    
    # Cleanup
    manager.set_file_attributes(test_file, hidden=False, readonly=False)
    import os
    os.remove(test_file)

# Run the demo
attribute_demo()
```

## File Monitoring and Change Detection

### Directory Monitoring
```python
import win32file
import win32con
import threading
import time

class DirectoryMonitor:
    """Monitor directory changes using Windows API"""
    
    def __init__(self, directory_path):
        self.directory_path = directory_path
        self.monitoring = False
        self.monitor_thread = None
        self.change_callbacks = []
    
    def add_change_callback(self, callback):
        """Add callback function for change notifications"""
        self.change_callbacks.append(callback)
    
    def start_monitoring(self):
        """Start monitoring directory changes"""
        if self.monitoring:
            print("Already monitoring")
            return
        
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
        print(f"Started monitoring: {self.directory_path}")
    
    def stop_monitoring(self):
        """Stop monitoring directory changes"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=2)
        print("Stopped monitoring")
    
    def _monitor_loop(self):
        """Main monitoring loop"""
        try:
            # Open directory handle
            handle = win32file.CreateFile(
                self.directory_path,
                win32con.GENERIC_READ,
                win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE | win32con.FILE_SHARE_DELETE,
                None,
                win32con.OPEN_EXISTING,
                win32con.FILE_FLAG_BACKUP_SEMANTICS,
                None
            )
            
            while self.monitoring:
                try:
                    # Wait for changes
                    results = win32file.ReadDirectoryChangesW(
                        handle,
                        1024,  # Buffer size
                        True,  # Watch subtree
                        win32con.FILE_NOTIFY_CHANGE_FILE_NAME |
                        win32con.FILE_NOTIFY_CHANGE_DIR_NAME |
                        win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |
                        win32con.FILE_NOTIFY_CHANGE_SIZE |
                        win32con.FILE_NOTIFY_CHANGE_LAST_WRITE,
                        None,
                        None
                    )
                    
                    # Process changes
                    for action, filename in results:
                        change_info = {
                            'action': self._get_action_name(action),
                            'filename': filename,
                            'full_path': f"{self.directory_path}\\{filename}",
                            'timestamp': time.time()
                        }
                        
                        # Notify callbacks
                        for callback in self.change_callbacks:
                            try:
                                callback(change_info)
                            except Exception as e:
                                print(f"Error in callback: {e}")
                
                except Exception as e:
                    if self.monitoring:  # Only log if we're still supposed to be monitoring
                        print(f"Monitor error: {e}")
                    break
            
            win32file.CloseHandle(handle)
            
        except Exception as e:
            print(f"Failed to start monitoring: {e}")
    
    def _get_action_name(self, action):
        """Convert action code to readable name"""
        actions = {
            1: "FILE_CREATED",
            2: "FILE_DELETED", 
            3: "FILE_MODIFIED",
            4: "FILE_RENAMED_OLD",
            5: "FILE_RENAMED_NEW"
        }
        return actions.get(action, f"UNKNOWN_ACTION_{action}")

# Change logging callback
def log_change(change_info):
    """Log directory changes"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(change_info['timestamp']))
    print(f"[{timestamp}] {change_info['action']}: {change_info['filename']}")

# Example usage
def monitoring_demo():
    """Demonstrate directory monitoring"""
    import os
    import tempfile
    
    # Create a temporary directory for testing
    test_dir = tempfile.mkdtemp()
    print(f"Monitoring directory: {test_dir}")
    
    # Create monitor
    monitor = DirectoryMonitor(test_dir)
    monitor.add_change_callback(log_change)
    
    # Start monitoring
    monitor.start_monitoring()
    
    try:
        # Simulate file operations
        print("\nSimulating file operations...")
        time.sleep(1)
        
        # Create a file
        test_file = os.path.join(test_dir, "test_file.txt")
        with open(test_file, 'w') as f:
            f.write("Hello, world!")
        time.sleep(0.5)
        
        # Modify the file
        with open(test_file, 'a') as f:
            f.write("\nModified content")
        time.sleep(0.5)
        
        # Rename the file
        new_name = os.path.join(test_dir, "renamed_file.txt")
        os.rename(test_file, new_name)
        time.sleep(0.5)
        
        # Delete the file
        os.remove(new_name)
        time.sleep(0.5)
        
        print("\nFile operations completed. Monitoring for 3 more seconds...")
        time.sleep(3)
        
    finally:
        # Stop monitoring and cleanup
        monitor.stop_monitoring()
        import shutil
        shutil.rmtree(test_dir)

# Run the demo
monitoring_demo()
```

## File Security and Permissions

### Security Descriptors and ACLs
```python
import win32security
import win32file
import win32con
import win32api

class FileSecurityManager:
    """Manage file security and permissions"""
    
    def get_file_security(self, filename):
        """Get file security information"""
        try:
            # Get security descriptor
            security_desc = win32security.GetFileSecurity(
                filename,
                win32security.OWNER_SECURITY_INFORMATION |
                win32security.GROUP_SECURITY_INFORMATION |
                win32security.DACL_SECURITY_INFORMATION
            )
            
            # Get owner
            owner_sid = security_desc.GetSecurityDescriptorOwner()
            owner_name = win32security.LookupAccountSid(None, owner_sid)
            
            # Get group
            group_sid = security_desc.GetSecurityDescriptorGroup()
            group_name = win32security.LookupAccountSid(None, group_sid)
            
            # Get DACL (Discretionary Access Control List)
            dacl = security_desc.GetSecurityDescriptorDacl()
            
            security_info = {
                'owner': f"{owner_name[1]}\\{owner_name[0]}",
                'group': f"{group_name[1]}\\{group_name[0]}",
                'owner_sid': owner_sid,
                'group_sid': group_sid,
                'dacl_present': dacl is not None,
                'ace_count': dacl.GetAceCount() if dacl else 0
            }
            
            # Get ACE (Access Control Entry) information
            if dacl:
                aces = []
                for i in range(dacl.GetAceCount()):
                    ace = dacl.GetAce(i)
                    ace_type, ace_flags, permissions, sid = ace
                    
                    try:
                        account_name = win32security.LookupAccountSid(None, sid)
                        account = f"{account_name[1]}\\{account_name[0]}"
                    except:
                        account = str(sid)
                    
                    aces.append({
                        'account': account,
                        'type': self._get_ace_type_name(ace_type),
                        'permissions': permissions,
                        'permissions_desc': self._describe_permissions(permissions)
                    })
                
                security_info['aces'] = aces
            
            return security_info
            
        except Exception as e:
            print(f"Error getting file security: {e}")
            return None
    
    def set_file_permissions(self, filename, username, permissions, grant=True):
        """Set file permissions for a user"""
        try:
            # Get current security descriptor
            security_desc = win32security.GetFileSecurity(
                filename,
                win32security.DACL_SECURITY_INFORMATION
            )
            
            # Get current DACL
            dacl = security_desc.GetSecurityDescriptorDacl()
            
            # Get user SID
            user_sid = win32security.LookupAccountName(None, username)[0]
            
            # Create new ACE
            ace_type = win32security.ACCESS_ALLOWED_ACE_TYPE if grant else win32security.ACCESS_DENIED_ACE_TYPE
            
            # Add ACE to DACL
            dacl.AddAccessAllowedAce(win32security.ACL_REVISION, permissions, user_sid)
            
            # Set new DACL
            security_desc.SetSecurityDescriptorDacl(1, dacl, 0)
            
            # Apply to file
            win32security.SetFileSecurity(
                filename,
                win32security.DACL_SECURITY_INFORMATION,
                security_desc
            )
            
            return True
            
        except Exception as e:
            print(f"Error setting file permissions: {e}")
            return False
    
    def _get_ace_type_name(self, ace_type):
        """Get ACE type name"""
        types = {
            win32security.ACCESS_ALLOWED_ACE_TYPE: "ALLOW",
            win32security.ACCESS_DENIED_ACE_TYPE: "DENY",
            win32security.SYSTEM_AUDIT_ACE_TYPE: "AUDIT"
        }
        return types.get(ace_type, f"UNKNOWN_{ace_type}")
    
    def _describe_permissions(self, permissions):
        """Describe permission bits"""
        permission_names = []
        
        permission_map = {
            win32con.GENERIC_READ: "READ",
            win32con.GENERIC_WRITE: "WRITE",
            win32con.GENERIC_EXECUTE: "EXECUTE",
            win32con.GENERIC_ALL: "FULL_CONTROL",
            win32con.DELETE: "DELETE",
            win32file.FILE_READ_DATA: "READ_DATA",
            win32file.FILE_WRITE_DATA: "WRITE_DATA",
            win32file.FILE_APPEND_DATA: "APPEND_DATA",
            win32file.FILE_READ_EA: "READ_EA",
            win32file.FILE_WRITE_EA: "WRITE_EA",
            win32file.FILE_EXECUTE: "EXECUTE",
            win32file.FILE_READ_ATTRIBUTES: "READ_ATTR",
            win32file.FILE_WRITE_ATTRIBUTES: "WRITE_ATTR"
        }
        
        for permission_bit, name in permission_map.items():
            if permissions & permission_bit:
                permission_names.append(name)
        
        return permission_names if permission_names else ["NONE"]

# Example usage
def security_demo():
    """Demonstrate file security operations"""
    import os
    
    # Create a test file
    test_file = "security_test.txt"
    with open(test_file, 'w') as f:
        f.write("Testing file security")
    
    manager = FileSecurityManager()
    
    print("=== FILE SECURITY INFORMATION ===")
    security_info = manager.get_file_security(test_file)
    
    if security_info:
        print(f"Owner: {security_info['owner']}")
        print(f"Group: {security_info['group']}")
        print(f"DACL present: {security_info['dacl_present']}")
        print(f"ACE count: {security_info['ace_count']}")
        
        if 'aces' in security_info:
            print("\nAccess Control Entries:")
            for i, ace in enumerate(security_info['aces']):
                print(f"  {i+1}. {ace['account']}")
                print(f"     Type: {ace['type']}")
                print(f"     Permissions: {', '.join(ace['permissions_desc'])}")
    
    # Cleanup
    os.remove(test_file)

# Run the demo
security_demo()
```

## File I/O Operations

### Asynchronous File Operations
```python
import win32file
import win32con
import win32event
import threading
import time

class AsyncFileManager:
    """Asynchronous file operations using Windows APIs"""
    
    def __init__(self):
        self.operations = {}
        self.operation_id = 0
    
    def async_copy_file(self, source, destination, callback=None):
        """Copy file asynchronously with progress callback"""
        operation_id = self._get_next_operation_id()
        
        def copy_worker():
            try:
                # Define progress callback function
                def progress_callback(total_file_size, total_bytes_transferred,
                                    stream_size, stream_bytes_transferred,
                                    stream_number, callback_reason,
                                    source_file, destination_file, data):
                    
                    if total_file_size > 0:
                        percent = (total_bytes_transferred / total_file_size) * 100
                        progress_info = {
                            'operation_id': operation_id,
                            'percent': percent,
                            'bytes_transferred': total_bytes_transferred,
                            'total_bytes': total_file_size,
                            'source': source_file,
                            'destination': destination_file
                        }
                        
                        if callback:
                            callback(progress_info)
                    
                    return win32con.PROGRESS_CONTINUE
                
                # Perform the copy
                result = win32file.CopyFileEx(
                    source,
                    destination,
                    progress_callback,
                    None,  # Data for callback
                    False,  # Cancel flag
                    0  # Copy flags
                )
                
                # Update operation status
                self.operations[operation_id]['status'] = 'completed' if result else 'failed'
                self.operations[operation_id]['result'] = result
                
            except Exception as e:
                self.operations[operation_id]['status'] = 'error'
                self.operations[operation_id]['error'] = str(e)
        
        # Initialize operation tracking
        self.operations[operation_id] = {
            'status': 'running',
            'thread': threading.Thread(target=copy_worker),
            'source': source,
            'destination': destination
        }
        
        # Start the operation
        self.operations[operation_id]['thread'].start()
        
        return operation_id
    
    def get_operation_status(self, operation_id):
        """Get status of async operation"""
        return self.operations.get(operation_id, {}).get('status', 'unknown')
    
    def wait_for_operation(self, operation_id, timeout=None):
        """Wait for operation to complete"""
        operation = self.operations.get(operation_id)
        if operation and 'thread' in operation:
            operation['thread'].join(timeout)
            return self.get_operation_status(operation_id)
        return 'not_found'
    
    def _get_next_operation_id(self):
        """Get next operation ID"""
        self.operation_id += 1
        return self.operation_id

# Progress callback for demonstrations
def copy_progress_callback(progress_info):
    """Display copy progress"""
    print(f"\rOperation {progress_info['operation_id']}: "
          f"{progress_info['percent']:.1f}% "
          f"({progress_info['bytes_transferred']:,}/{progress_info['total_bytes']:,} bytes)",
          end="", flush=True)

# Example usage
def async_file_demo():
    """Demonstrate asynchronous file operations"""
    import os
    import tempfile
    
    # Create a test file with some content
    test_content = "This is test content for async file operations.\n" * 10000
    source_file = "async_source.txt"
    destination_file = "async_destination.txt"
    
    with open(source_file, 'w') as f:
        f.write(test_content)
    
    print(f"Created source file: {source_file}")
    print(f"File size: {os.path.getsize(source_file):,} bytes")
    
    # Start async copy
    manager = AsyncFileManager()
    operation_id = manager.async_copy_file(
        source_file,
        destination_file,
        copy_progress_callback
    )
    
    print(f"\nStarted async copy operation: {operation_id}")
    
    # Wait for completion
    status = manager.wait_for_operation(operation_id, timeout=10)
    print(f"\nOperation completed with status: {status}")
    
    # Verify copy
    if os.path.exists(destination_file):
        source_size = os.path.getsize(source_file)
        dest_size = os.path.getsize(destination_file)
        print(f"Copy verification: {source_size == dest_size}")
    
    # Cleanup
    for file in [source_file, destination_file]:
        if os.path.exists(file):
            os.remove(file)

# Run the demo
async_file_demo()
```

## Practical Project: File Synchronization Utility

### Complete File Sync Implementation
```python
import win32file
import win32con
import win32security
import os
import time
import hashlib
import json
import threading
from datetime import datetime

class FileSynchronizer:
    """Complete file synchronization utility"""
    
    def __init__(self, source_dir, target_dir, config=None):
        self.source_dir = os.path.abspath(source_dir)
        self.target_dir = os.path.abspath(target_dir)
        self.config = config or self._default_config()
        self.sync_log = []
        self.stats = {
            'files_copied': 0,
            'files_updated': 0,
            'files_deleted': 0,
            'bytes_transferred': 0,
            'errors': 0
        }
    
    def _default_config(self):
        """Default synchronization configuration"""
        return {
            'compare_method': 'timestamp',  # 'timestamp', 'size', 'hash'
            'preserve_attributes': True,
            'preserve_permissions': True,
            'delete_extra_files': False,
            'excluded_extensions': ['.tmp', '.log'],
            'excluded_directories': ['temp', 'cache'],
            'max_file_size': 100 * 1024 * 1024,  # 100MB
            'dry_run': False
        }
    
    def synchronize(self, progress_callback=None):
        """Perform synchronization"""
        print(f"Starting synchronization:")
        print(f"  Source: {self.source_dir}")
        print(f"  Target: {self.target_dir}")
        print(f"  Config: {self.config}")
        
        start_time = time.time()
        
        try:
            # Ensure target directory exists
            if not os.path.exists(self.target_dir):
                os.makedirs(self.target_dir)
            
            # Get file lists
            source_files = self._scan_directory(self.source_dir)
            target_files = self._scan_directory(self.target_dir)
            
            print(f"Found {len(source_files)} source files, {len(target_files)} target files")
            
            # Compare and sync
            self._sync_files(source_files, target_files, progress_callback)
            
            # Handle deletions if configured
            if self.config['delete_extra_files']:
                self._delete_extra_files(source_files, target_files)
            
            elapsed_time = time.time() - start_time
            
            # Print summary
            print(f"\nSynchronization completed in {elapsed_time:.2f} seconds")
            print(f"Statistics:")
            for key, value in self.stats.items():
                print(f"  {key}: {value}")
            
            return True
            
        except Exception as e:
            print(f"Synchronization failed: {e}")
            return False
    
    def _scan_directory(self, directory):
        """Scan directory and return file information"""
        files = {}
        
        for root, dirs, filenames in os.walk(directory):
            # Filter out excluded directories
            dirs[:] = [d for d in dirs if d not in self.config['excluded_directories']]
            
            for filename in filenames:
                # Filter out excluded extensions
                if any(filename.endswith(ext) for ext in self.config['excluded_extensions']):
                    continue
                
                full_path = os.path.join(root, filename)
                relative_path = os.path.relpath(full_path, directory)
                
                try:
                    stat_info = os.stat(full_path)
                    
                    # Skip files that are too large
                    if stat_info.st_size > self.config['max_file_size']:
                        continue
                    
                    file_info = {
                        'path': full_path,
                        'relative_path': relative_path,
                        'size': stat_info.st_size,
                        'mtime': stat_info.st_mtime,
                        'attributes': self._get_file_attributes(full_path)
                    }
                    
                    # Add hash if configured
                    if self.config['compare_method'] == 'hash':
                        file_info['hash'] = self._calculate_file_hash(full_path)
                    
                    files[relative_path] = file_info
                    
                except Exception as e:
                    print(f"Error scanning {full_path}: {e}")
                    self.stats['errors'] += 1
        
        return files
    
    def _sync_files(self, source_files, target_files, progress_callback):
        """Synchronize files between source and target"""
        total_files = len(source_files)
        processed_files = 0
        
        for relative_path, source_info in source_files.items():
            processed_files += 1
            
            if progress_callback:
                progress_callback(processed_files, total_files, relative_path)
            
            target_path = os.path.join(self.target_dir, relative_path)
            target_info = target_files.get(relative_path)
            
            # Determine if file needs to be copied
            needs_copy = False
            action = "skip"
            
            if not target_info:
                needs_copy = True
                action = "copy"
            elif self._files_differ(source_info, target_info):
                needs_copy = True
                action = "update"
            
            if needs_copy and not self.config['dry_run']:
                if self._copy_file(source_info['path'], target_path):
                    if action == "copy":
                        self.stats['files_copied'] += 1
                    else:
                        self.stats['files_updated'] += 1
                    
                    self.stats['bytes_transferred'] += source_info['size']
                    
                    # Preserve attributes if configured
                    if self.config['preserve_attributes']:
                        self._copy_file_attributes(source_info['path'], target_path)
            
            # Log the action
            self.sync_log.append({
                'timestamp': datetime.now().isoformat(),
                'action': action,
                'file': relative_path,
                'size': source_info['size']
            })
    
    def _files_differ(self, source_info, target_info):
        """Check if files differ based on configuration"""
        method = self.config['compare_method']
        
        if method == 'timestamp':
            return abs(source_info['mtime'] - target_info['mtime']) > 1
        elif method == 'size':
            return source_info['size'] != target_info['size']
        elif method == 'hash':
            return source_info.get('hash') != target_info.get('hash')
        
        return False
    
    def _copy_file(self, source_path, target_path):
        """Copy file using Windows API"""
        try:
            # Ensure target directory exists
            target_dir = os.path.dirname(target_path)
            if not os.path.exists(target_dir):
                os.makedirs(target_dir)
            
            # Copy the file
            win32file.CopyFile(source_path, target_path, False)
            return True
            
        except Exception as e:
            print(f"Error copying {source_path}: {e}")
            self.stats['errors'] += 1
            return False
    
    def _copy_file_attributes(self, source_path, target_path):
        """Copy file attributes and timestamps"""
        try:
            # Copy attributes
            source_attrs = win32file.GetFileAttributes(source_path)
            win32file.SetFileAttributes(target_path, source_attrs)
            
            # Copy timestamps
            source_handle = win32file.CreateFile(
                source_path, win32con.GENERIC_READ,
                win32con.FILE_SHARE_READ, None,
                win32con.OPEN_EXISTING, 0, None
            )
            
            target_handle = win32file.CreateFile(
                target_path, win32con.GENERIC_WRITE,
                0, None, win32con.OPEN_EXISTING, 0, None
            )
            
            creation_time, access_time, write_time = win32file.GetFileTime(source_handle)
            win32file.SetFileTime(target_handle, creation_time, access_time, write_time)
            
            win32file.CloseHandle(source_handle)
            win32file.CloseHandle(target_handle)
            
        except Exception as e:
            print(f"Error copying attributes for {target_path}: {e}")
    
    def _get_file_attributes(self, file_path):
        """Get file attributes"""
        try:
            return win32file.GetFileAttributes(file_path)
        except:
            return 0
    
    def _calculate_file_hash(self, file_path, chunk_size=8192):
        """Calculate MD5 hash of file"""
        hash_md5 = hashlib.md5()
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(chunk_size), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except:
            return None
    
    def _delete_extra_files(self, source_files, target_files):
        """Delete files in target that don't exist in source"""
        for relative_path in target_files:
            if relative_path not in source_files:
                target_path = os.path.join(self.target_dir, relative_path)
                try:
                    if not self.config['dry_run']:
                        os.remove(target_path)
                    self.stats['files_deleted'] += 1
                    
                    self.sync_log.append({
                        'timestamp': datetime.now().isoformat(),
                        'action': 'delete',
                        'file': relative_path,
                        'size': 0
                    })
                    
                except Exception as e:
                    print(f"Error deleting {target_path}: {e}")
                    self.stats['errors'] += 1
    
    def save_log(self, log_file):
        """Save synchronization log to file"""
        try:
            with open(log_file, 'w') as f:
                json.dump({
                    'timestamp': datetime.now().isoformat(),
                    'source_dir': self.source_dir,
                    'target_dir': self.target_dir,
                    'config': self.config,
                    'stats': self.stats,
                    'operations': self.sync_log
                }, f, indent=2)
            print(f"Log saved to: {log_file}")
        except Exception as e:
            print(f"Error saving log: {e}")

# Progress callback for sync operations
def sync_progress(processed, total, current_file):
    """Display sync progress"""
    percent = (processed / total) * 100
    print(f"\rProgress: {percent:.1f}% ({processed}/{total}) - {current_file[:50]}...",
          end="", flush=True)

# Example usage
def file_sync_demo():
    """Demonstrate file synchronization"""
    import tempfile
    import shutil
    
    # Create temporary directories for testing
    source_dir = tempfile.mkdtemp(prefix="sync_source_")
    target_dir = tempfile.mkdtemp(prefix="sync_target_")
    
    try:
        # Create some test files in source
        test_files = [
            ("file1.txt", "Content of file 1"),
            ("subdir/file2.txt", "Content of file 2"),
            ("subdir/file3.txt", "Content of file 3"),
            ("file4.txt", "Content of file 4")
        ]
        
        for rel_path, content in test_files:
            full_path = os.path.join(source_dir, rel_path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, 'w') as f:
                f.write(content)
        
        print(f"Created test files in: {source_dir}")
        
        # Configure synchronizer
        config = {
            'compare_method': 'timestamp',
            'preserve_attributes': True,
            'delete_extra_files': True,
            'dry_run': False
        }
        
        # Perform synchronization
        synchronizer = FileSynchronizer(source_dir, target_dir, config)
        synchronizer.synchronize(sync_progress)
        
        print(f"\nSynchronization completed")
        print(f"Check target directory: {target_dir}")
        
        # Save log
        log_file = "sync_log.json"
        synchronizer.save_log(log_file)
        
    finally:
        # Cleanup (uncomment to remove temp directories)
        # shutil.rmtree(source_dir)
        # shutil.rmtree(target_dir)
        print(f"\nTemp directories created:")
        print(f"  Source: {source_dir}")
        print(f"  Target: {target_dir}")

# Run the demo
file_sync_demo()
```

## Exercises

### Exercise 1: File Attribute Manager
Create a utility that:
- Lists files with specific attributes
- Bulk changes file attributes
- Preserves original timestamps
- Provides undo functionality

### Exercise 2: Directory Monitor
Build a monitoring service that:
- Watches multiple directories
- Logs all changes to a database
- Sends notifications for specific events
- Provides a web interface for viewing logs

### Exercise 3: File Backup System
Develop a backup system that:
- Performs incremental backups
- Compresses backup files
- Verifies backup integrity
- Supports scheduled operations

### Exercise 4: Secure File Manager
Create a file manager with:
- Permission management interface
- Encryption/decryption capabilities
- Secure file deletion
- Audit trail logging

## Best Practices

### Error Handling
- Always handle file access exceptions
- Provide meaningful error messages
- Implement retry mechanisms for transient failures
- Log errors for debugging

### Performance Optimization
- Use asynchronous operations for large files
- Implement proper buffering strategies
- Cache frequently accessed information
- Minimize API calls

### Security Considerations
- Validate all file paths
- Check permissions before operations
- Use secure temporary files
- Implement proper access controls

## Common Pitfalls

### File Locking Issues
- Files opened by other processes
- Insufficient permissions
- Network file access problems
- Antivirus interference

### Unicode and Path Issues
- Long path names (>260 characters)
- Unicode characters in filenames
- Reserved device names
- Case sensitivity considerations

### Performance Problems
- Synchronous operations blocking UI
- Inefficient directory traversal
- Memory usage with large files
- Network latency issues

## Next Steps

Congratulations on completing File and Directory Operations! You now have:
- Advanced file manipulation skills
- Understanding of Windows file security
- Experience with monitoring and asynchronous operations
- A complete file synchronization utility

**Next**: Move to [2.2 Process and Service Management](./2.2%20Process%20and%20Service%20Management.md) to learn about process control and Windows services.

---

**Estimated Time**: 8-12 hours
**Project**: File synchronization utility
**Next Module**: [2.2 Process and Service Management](./2.2%20Process%20and%20Service%20Management.md)
