# 2.4 Window Management

## Learning Objectives
By the end of this module, you will:
- Master window enumeration and manipulation techniques
- Understand window message handling and communication
- Implement GUI automation solutions
- Build practical window management utilities
- Handle multi-monitor environments effectively

## Module Overview

Window management is a crucial aspect of Windows programming that allows you to interact with and control GUI applications. The `win32gui` module provides comprehensive functionality for window operations, from basic enumeration to advanced message handling and automation.

This module covers everything from finding specific windows to creating sophisticated window management utilities that can organize your desktop workspace.

## Key Topics Covered

### 1. Window Enumeration and Discovery
### 2. Window Properties and Information
### 3. Window Manipulation Operations
### 4. Message Handling and Communication
### 5. GUI Automation Techniques
### 6. Multi-Monitor Support
### 7. Advanced Window Management

---

## 1. Window Enumeration and Discovery

### 1.1 Basic Window Enumeration

```python
import win32gui
import win32con
import win32process

def enum_windows_callback(hwnd, windows):
    """Callback function for EnumWindows"""
    if win32gui.IsWindowVisible(hwnd):
        window_text = win32gui.GetWindowText(hwnd)
        class_name = win32gui.GetClassName(hwnd)
        if window_text:  # Only include windows with titles
            windows.append({
                'hwnd': hwnd,
                'title': window_text,
                'class': class_name
            })
    return True

def get_all_windows():
    """Get all visible windows"""
    windows = []
    win32gui.EnumWindows(enum_windows_callback, windows)
    return windows

# Example usage
windows = get_all_windows()
for window in windows[:5]:  # Show first 5 windows
    print(f"Title: {window['title']}")
    print(f"Class: {window['class']}")
    print(f"Handle: {window['hwnd']}")
    print("-" * 40)
```

### 1.2 Finding Specific Windows

```python
def find_window_by_title(title, exact_match=False):
    """Find window by title (partial or exact match)"""
    def callback(hwnd, results):
        window_title = win32gui.GetWindowText(hwnd)
        if exact_match:
            if window_title == title:
                results.append(hwnd)
        else:
            if title.lower() in window_title.lower():
                results.append(hwnd)
        return True
    
    results = []
    win32gui.EnumWindows(callback, results)
    return results

def find_window_by_class(class_name):
    """Find window by class name"""
    return win32gui.FindWindow(class_name, None)

def find_window_by_process_name(process_name):
    """Find windows by process name"""
    windows = []
    
    def callback(hwnd, results):
        try:
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION, False, pid)
            exe_name = win32process.GetModuleFileNameEx(handle, 0)
            win32api.CloseHandle(handle)
            
            if process_name.lower() in exe_name.lower():
                results.append(hwnd)
        except:
            pass
        return True
    
    win32gui.EnumWindows(callback, windows)
    return windows

# Example usage
notepad_windows = find_window_by_title("Notepad")
calculator = find_window_by_class("CalcFrame")
chrome_windows = find_window_by_process_name("chrome.exe")
```

### 1.3 Child Window Enumeration

```python
def enum_child_windows(parent_hwnd):
    """Enumerate child windows of a parent window"""
    children = []
    
    def callback(hwnd, results):
        window_text = win32gui.GetWindowText(hwnd)
        class_name = win32gui.GetClassName(hwnd)
        results.append({
            'hwnd': hwnd,
            'title': window_text,
            'class': class_name,
            'rect': win32gui.GetWindowRect(hwnd)
        })
        return True
    
    win32gui.EnumChildWindows(parent_hwnd, callback, children)
    return children

# Example: Find all controls in a window
hwnd = win32gui.FindWindow(None, "Calculator")
if hwnd:
    children = enum_child_windows(hwnd)
    for child in children:
        print(f"Control: {child['class']} - {child['title']}")
```

---

## 2. Window Properties and Information

### 2.1 Getting Window Information

```python
def get_window_info(hwnd):
    """Get comprehensive window information"""
    try:
        info = {
            'handle': hwnd,
            'title': win32gui.GetWindowText(hwnd),
            'class': win32gui.GetClassName(hwnd),
            'rect': win32gui.GetWindowRect(hwnd),
            'client_rect': win32gui.GetClientRect(hwnd),
            'is_visible': win32gui.IsWindowVisible(hwnd),
            'is_enabled': win32gui.IsWindowEnabled(hwnd),
            'is_minimized': win32gui.IsIconic(hwnd),
            'is_maximized': win32gui.IsZoomed(hwnd),
            'parent': win32gui.GetParent(hwnd),
            'style': win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE),
            'ex_style': win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
        }
        
        # Get process information
        try:
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            info['process_id'] = pid
            
            handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION, False, pid)
            info['process_name'] = win32process.GetModuleFileNameEx(handle, 0)
            win32api.CloseHandle(handle)
        except:
            info['process_id'] = None
            info['process_name'] = None
        
        return info
    
    except Exception as e:
        return {'error': str(e)}

def print_window_info(hwnd):
    """Print formatted window information"""
    info = get_window_info(hwnd)
    
    print(f"Window Handle: {info['handle']}")
    print(f"Title: {info['title']}")
    print(f"Class: {info['class']}")
    print(f"Position: {info['rect']}")
    print(f"Visible: {info['is_visible']}")
    print(f"Enabled: {info['is_enabled']}")
    print(f"Process: {info['process_name']} (PID: {info['process_id']})")
```

### 2.2 Window Styles and Properties

```python
def analyze_window_style(hwnd):
    """Analyze window style flags"""
    style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
    ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
    
    style_flags = {
        'WS_BORDER': bool(style & win32con.WS_BORDER),
        'WS_CAPTION': bool(style & win32con.WS_CAPTION),
        'WS_CHILD': bool(style & win32con.WS_CHILD),
        'WS_CLIPCHILDREN': bool(style & win32con.WS_CLIPCHILDREN),
        'WS_CLIPSIBLINGS': bool(style & win32con.WS_CLIPSIBLINGS),
        'WS_DISABLED': bool(style & win32con.WS_DISABLED),
        'WS_DLGFRAME': bool(style & win32con.WS_DLGFRAME),
        'WS_GROUP': bool(style & win32con.WS_GROUP),
        'WS_HSCROLL': bool(style & win32con.WS_HSCROLL),
        'WS_MAXIMIZE': bool(style & win32con.WS_MAXIMIZE),
        'WS_MAXIMIZEBOX': bool(style & win32con.WS_MAXIMIZEBOX),
        'WS_MINIMIZE': bool(style & win32con.WS_MINIMIZE),
        'WS_MINIMIZEBOX': bool(style & win32con.WS_MINIMIZEBOX),
        'WS_OVERLAPPED': bool(style & win32con.WS_OVERLAPPED),
        'WS_POPUP': bool(style & win32con.WS_POPUP),
        'WS_SIZEBOX': bool(style & win32con.WS_SIZEBOX),
        'WS_SYSMENU': bool(style & win32con.WS_SYSMENU),
        'WS_TABSTOP': bool(style & win32con.WS_TABSTOP),
        'WS_THICKFRAME': bool(style & win32con.WS_THICKFRAME),
        'WS_VISIBLE': bool(style & win32con.WS_VISIBLE),
        'WS_VSCROLL': bool(style & win32con.WS_VSCROLL)
    }
    
    return style_flags, ex_style
```

---

## 3. Window Manipulation Operations

### 3.1 Basic Window Operations

```python
def move_window(hwnd, x, y, width, height, repaint=True):
    """Move and resize a window"""
    return win32gui.MoveWindow(hwnd, x, y, width, height, repaint)

def show_window(hwnd, cmd_show):
    """Show/hide window with various options"""
    # cmd_show options:
    # win32con.SW_HIDE - Hide window
    # win32con.SW_MAXIMIZE - Maximize window
    # win32con.SW_MINIMIZE - Minimize window
    # win32con.SW_RESTORE - Restore window
    # win32con.SW_SHOW - Show window
    # win32con.SW_SHOWMINIMIZED - Show minimized
    # win32con.SW_SHOWMAXIMIZED - Show maximized
    # win32con.SW_SHOWNOACTIVATE - Show without activating
    return win32gui.ShowWindow(hwnd, cmd_show)

def set_window_pos(hwnd, insert_after, x, y, cx, cy, flags):
    """Advanced window positioning"""
    # insert_after options:
    # win32con.HWND_TOP - Top of Z-order
    # win32con.HWND_BOTTOM - Bottom of Z-order
    # win32con.HWND_TOPMOST - Always on top
    # win32con.HWND_NOTOPMOST - Remove always on top
    
    # flags options:
    # win32con.SWP_NOSIZE - Ignore cx, cy
    # win32con.SWP_NOMOVE - Ignore x, y
    # win32con.SWP_NOZORDER - Ignore insert_after
    # win32con.SWP_NOACTIVATE - Don't activate window
    return win32gui.SetWindowPos(hwnd, insert_after, x, y, cx, cy, flags)

# Example usage
def organize_windows():
    """Example: Organize windows in a grid"""
    windows = get_all_windows()
    screen_width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
    screen_height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)
    
    # Calculate grid dimensions
    import math
    cols = math.ceil(math.sqrt(len(windows)))
    rows = math.ceil(len(windows) / cols)
    
    win_width = screen_width // cols
    win_height = screen_height // rows
    
    for i, window in enumerate(windows):
        row = i // cols
        col = i % cols
        x = col * win_width
        y = row * win_height
        
        move_window(window['hwnd'], x, y, win_width, win_height)
        show_window(window['hwnd'], win32con.SW_RESTORE)
```

### 3.2 Window Focus and Activation

```python
def bring_window_to_front(hwnd):
    """Bring window to front and activate it"""
    try:
        # First, restore if minimized
        if win32gui.IsIconic(hwnd):
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
        
        # Bring to foreground
        win32gui.SetForegroundWindow(hwnd)
        win32gui.BringWindowToTop(hwnd)
        win32gui.SetActiveWindow(hwnd)
        return True
    except Exception as e:
        print(f"Error bringing window to front: {e}")
        return False

def flash_window(hwnd, count=5):
    """Flash window to get user attention"""
    for _ in range(count):
        win32gui.FlashWindow(hwnd, True)
        time.sleep(0.5)

def set_window_always_on_top(hwnd, on_top=True):
    """Set window to always stay on top"""
    if on_top:
        insert_after = win32con.HWND_TOPMOST
    else:
        insert_after = win32con.HWND_NOTOPMOST
    
    return win32gui.SetWindowPos(
        hwnd, insert_after, 0, 0, 0, 0,
        win32con.SWP_NOMOVE | win32con.SWP_NOSIZE
    )
```

---

## 4. Message Handling and Communication

### 4.1 Sending Messages to Windows

```python
def send_message(hwnd, msg, wparam, lparam):
    """Send a message to a window"""
    return win32gui.SendMessage(hwnd, msg, wparam, lparam)

def post_message(hwnd, msg, wparam, lparam):
    """Post a message to a window (asynchronous)"""
    return win32gui.PostMessage(hwnd, msg, wparam, lparam)

def close_window(hwnd):
    """Close a window gracefully"""
    return win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)

def minimize_window(hwnd):
    """Minimize window using message"""
    return win32gui.PostMessage(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_MINIMIZE, 0)

def maximize_window(hwnd):
    """Maximize window using message"""
    return win32gui.PostMessage(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_MAXIMIZE, 0)

# Example: Send text to a window
def send_text_to_window(hwnd, text):
    """Send text to a window (like typing)"""
    for char in text:
        win32gui.PostMessage(hwnd, win32con.WM_CHAR, ord(char), 0)
```

### 4.2 Window Message Monitoring

```python
class WindowMessageMonitor:
    """Monitor window messages for a specific window"""
    
    def __init__(self, hwnd):
        self.hwnd = hwnd
        self.original_wndproc = None
        self.messages = []
        
    def start_monitoring(self):
        """Start monitoring window messages"""
        # This is a simplified example - real implementation would require
        # subclassing the window procedure
        pass
        
    def stop_monitoring(self):
        """Stop monitoring and restore original window procedure"""
        pass
        
    def get_messages(self):
        """Get captured messages"""
        return self.messages.copy()

# Example: Monitor window for specific messages
def wait_for_window_close(hwnd, timeout=30):
    """Wait for a window to close"""
    import time
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        if not win32gui.IsWindow(hwnd):
            return True
        time.sleep(0.1)
    
    return False
```

---

## 5. GUI Automation Techniques

### 5.1 Mouse and Keyboard Simulation

```python
import win32api
import win32con

def click_window_point(hwnd, x, y):
    """Click at a specific point within a window"""
    # Convert to screen coordinates
    rect = win32gui.GetWindowRect(hwnd)
    screen_x = rect[0] + x
    screen_y = rect[1] + y
    
    # Save current cursor position
    old_pos = win32gui.GetCursorPos()
    
    # Move cursor and click
    win32api.SetCursorPos((screen_x, screen_y))
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
    
    # Restore cursor position
    win32api.SetCursorPos(old_pos)

def send_keys_to_window(hwnd, keys):
    """Send keyboard input to a specific window"""
    # Bring window to front first
    bring_window_to_front(hwnd)
    
    # Send keys using Windows API
    for key in keys:
        if isinstance(key, str):
            # Character key
            win32api.keybd_event(ord(key.upper()), 0, 0, 0)
            win32api.keybd_event(ord(key.upper()), 0, win32con.KEYEVENTF_KEYUP, 0)
        else:
            # Special key (virtual key code)
            win32api.keybd_event(key, 0, 0, 0)
            win32api.keybd_event(key, 0, win32con.KEYEVENTF_KEYUP, 0)

# Special key constants
VK_ENTER = 0x0D
VK_TAB = 0x09
VK_ESCAPE = 0x1B
VK_SPACE = 0x20
VK_CONTROL = 0x11
VK_ALT = 0x12
VK_SHIFT = 0x10
```

### 5.2 Control Finding and Interaction

```python
def find_control_by_class_and_text(parent_hwnd, class_name, text=""):
    """Find a control by class name and optionally by text"""
    controls = []
    
    def callback(hwnd, results):
        if win32gui.GetClassName(hwnd) == class_name:
            if not text or win32gui.GetWindowText(hwnd) == text:
                results.append(hwnd)
        return True
    
    win32gui.EnumChildWindows(parent_hwnd, callback, controls)
    return controls

def click_button_by_text(parent_hwnd, button_text):
    """Click a button by its text"""
    buttons = find_control_by_class_and_text(parent_hwnd, "Button", button_text)
    if buttons:
        button_hwnd = buttons[0]
        # Send click message to button
        win32gui.SendMessage(button_hwnd, win32con.BM_CLICK, 0, 0)
        return True
    return False

def get_edit_control_text(edit_hwnd):
    """Get text from an edit control"""
    length = win32gui.SendMessage(edit_hwnd, win32con.WM_GETTEXTLENGTH, 0, 0)
    buffer = win32gui.PyMakeBuffer(length + 1)
    win32gui.SendMessage(edit_hwnd, win32con.WM_GETTEXT, length + 1, buffer)
    text = buffer[:length]
    return text.decode('utf-8') if isinstance(text, bytes) else text

def set_edit_control_text(edit_hwnd, text):
    """Set text in an edit control"""
    win32gui.SendMessage(edit_hwnd, win32con.WM_SETTEXT, 0, text)
```

---

## 6. Multi-Monitor Support

### 6.1 Monitor Information

```python
def get_monitor_info():
    """Get information about all monitors"""
    monitors = []
    
    def monitor_enum_proc(hMonitor, hdcMonitor, lprcMonitor, dwData):
        monitor_info = win32api.GetMonitorInfo(hMonitor)
        monitors.append({
            'handle': hMonitor,
            'device': monitor_info['Device'],
            'work_area': monitor_info['Work'],
            'monitor_area': monitor_info['Monitor'],
            'is_primary': bool(monitor_info['Flags'] & win32con.MONITORINFOF_PRIMARY)
        })
        return True
    
    win32api.EnumDisplayMonitors(None, None, monitor_enum_proc, None)
    return monitors

def get_primary_monitor():
    """Get primary monitor information"""
    monitors = get_monitor_info()
    for monitor in monitors:
        if monitor['is_primary']:
            return monitor
    return None

def get_window_monitor(hwnd):
    """Get monitor that contains the most of a window"""
    rect = win32gui.GetWindowRect(hwnd)
    hMonitor = win32api.MonitorFromRect(rect, win32con.MONITOR_DEFAULTTONEAREST)
    return win32api.GetMonitorInfo(hMonitor)
```

### 6.2 Multi-Monitor Window Management

```python
def move_window_to_monitor(hwnd, monitor_index=0):
    """Move window to specific monitor"""
    monitors = get_monitor_info()
    if monitor_index < len(monitors):
        monitor = monitors[monitor_index]
        work_area = monitor['work_area']
        
        # Move window to monitor's work area
        win32gui.SetWindowPos(
            hwnd, 0,
            work_area[0], work_area[1],
            work_area[2] - work_area[0],
            work_area[3] - work_area[1],
            win32con.SWP_NOZORDER
        )

def maximize_window_on_monitor(hwnd, monitor_index=0):
    """Maximize window on specific monitor"""
    monitors = get_monitor_info()
    if monitor_index < len(monitors):
        monitor = monitors[monitor_index]
        work_area = monitor['work_area']
        
        # Move and maximize on monitor
        win32gui.SetWindowPos(
            hwnd, 0,
            work_area[0], work_area[1],
            work_area[2] - work_area[0],
            work_area[3] - work_area[1],
            win32con.SWP_NOZORDER
        )
```

---

## 7. Advanced Window Management

### 7.1 Window Layout Management

```python
class WindowLayout:
    """Save and restore window layouts"""
    
    def __init__(self):
        self.layouts = {}
    
    def save_layout(self, name):
        """Save current window layout"""
        windows = get_all_windows()
        layout = {}
        
        for window in windows:
            hwnd = window['hwnd']
            if win32gui.IsWindowVisible(hwnd) and not win32gui.IsIconic(hwnd):
                layout[window['title']] = {
                    'rect': win32gui.GetWindowRect(hwnd),
                    'class': window['class'],
                    'maximized': win32gui.IsZoomed(hwnd),
                    'process': get_window_info(hwnd).get('process_name', '')
                }
        
        self.layouts[name] = layout
        return layout
    
    def restore_layout(self, name):
        """Restore a saved window layout"""
        if name not in self.layouts:
            return False
        
        layout = self.layouts[name]
        current_windows = get_all_windows()
        
        for window in current_windows:
            title = window['title']
            if title in layout:
                hwnd = window['hwnd']
                saved_window = layout[title]
                
                if saved_window['maximized']:
                    win32gui.ShowWindow(hwnd, win32con.SW_MAXIMIZE)
                else:
                    rect = saved_window['rect']
                    win32gui.SetWindowPos(
                        hwnd, 0, rect[0], rect[1],
                        rect[2] - rect[0], rect[3] - rect[1],
                        win32con.SWP_NOZORDER
                    )
        
        return True
    
    def list_layouts(self):
        """List all saved layouts"""
        return list(self.layouts.keys())

# Example usage
layout_manager = WindowLayout()
layout_manager.save_layout("coding_setup")
layout_manager.restore_layout("coding_setup")
```

### 7.2 Window Grouping and Management

```python
class WindowGroup:
    """Manage groups of related windows"""
    
    def __init__(self, name):
        self.name = name
        self.windows = []
    
    def add_window(self, hwnd):
        """Add window to group"""
        if hwnd not in self.windows:
            self.windows.append(hwnd)
    
    def remove_window(self, hwnd):
        """Remove window from group"""
        if hwnd in self.windows:
            self.windows.remove(hwnd)
    
    def minimize_all(self):
        """Minimize all windows in group"""
        for hwnd in self.windows:
            if win32gui.IsWindow(hwnd):
                win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)
    
    def restore_all(self):
        """Restore all windows in group"""
        for hwnd in self.windows:
            if win32gui.IsWindow(hwnd):
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
    
    def close_all(self):
        """Close all windows in group"""
        for hwnd in self.windows:
            if win32gui.IsWindow(hwnd):
                win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
    
    def tile_horizontally(self):
        """Tile windows horizontally"""
        valid_windows = [hwnd for hwnd in self.windows if win32gui.IsWindow(hwnd)]
        if not valid_windows:
            return
        
        screen_width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
        screen_height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)
        window_width = screen_width // len(valid_windows)
        
        for i, hwnd in enumerate(valid_windows):
            x = i * window_width
            win32gui.SetWindowPos(
                hwnd, 0, x, 0, window_width, screen_height,
                win32con.SWP_NOZORDER
            )
```

---

## Practical Exercises

### Exercise 1: Window Information Tool
Create a script that displays detailed information about a selected window.

```python
# Your implementation here
def window_inspector():
    """
    Create a tool that allows user to click on a window
    and displays all its properties and child controls
    """
    pass
```

### Exercise 2: Window Organizer
Build a utility that can organize windows in different patterns (grid, cascade, etc.).

```python
# Your implementation here
def window_organizer():
    """
    Create patterns:
    - Grid layout
    - Cascade layout
    - Side-by-side layout
    - Custom arrangements
    """
    pass
```

### Exercise 3: Application Automation
Create a script that automates interaction with a specific application.

```python
# Your implementation here
def automate_notepad():
    """
    Automate Notepad:
    - Open Notepad
    - Type some text
    - Save file
    - Close application
    """
    pass
```

### Exercise 4: Multi-Monitor Manager
Build a tool for managing windows across multiple monitors.

```python
# Your implementation here
def multi_monitor_manager():
    """
    Features:
    - Move windows between monitors
    - Maximize on specific monitor
    - Monitor-specific layouts
    """
    pass
```

---

## Best Practices

### 1. Handle Errors Gracefully
```python
def safe_window_operation(hwnd, operation):
    """Safely perform window operations with error handling"""
    try:
        if not win32gui.IsWindow(hwnd):
            raise ValueError("Invalid window handle")
        
        return operation(hwnd)
    
    except pywintypes.error as e:
        print(f"Windows API error: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None
```

### 2. Validate Window Handles
```python
def validate_window(hwnd):
    """Validate that a window handle is still valid"""
    return win32gui.IsWindow(hwnd) and hwnd != 0
```

### 3. Use Timeouts for Operations
```python
def wait_for_window_state(hwnd, state_check, timeout=5):
    """Wait for window to reach a specific state"""
    import time
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        if state_check(hwnd):
            return True
        time.sleep(0.1)
    
    return False

# Example usage
def wait_for_window_visible(hwnd, timeout=5):
    return wait_for_window_state(
        hwnd, 
        lambda h: win32gui.IsWindowVisible(h), 
        timeout
    )
```

### 4. Respect User Experience
```python
def gentle_window_operation(hwnd, operation):
    """Perform operations that don't interrupt user workflow"""
    # Check if window is currently in focus
    foreground = win32gui.GetForegroundWindow()
    
    if hwnd == foreground:
        # Window is active, be more careful
        print("Warning: Operating on active window")
    
    return operation(hwnd)
```

---

## Common Pitfalls and Solutions

### 1. Invalid Window Handles
**Problem**: Window handles become invalid when windows are closed.
**Solution**: Always validate handles before use.

```python
if win32gui.IsWindow(hwnd):
    # Safe to operate
    pass
```

### 2. Access Denied Errors
**Problem**: Some windows require elevated privileges.
**Solution**: Handle exceptions and provide fallback methods.

```python
try:
    # Privileged operation
    result = win32gui.SetWindowPos(hwnd, ...)
except pywintypes.error:
    # Fallback method
    win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
```

### 3. Timing Issues
**Problem**: Windows may not respond immediately to commands.
**Solution**: Use delays and state checking.

```python
win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
time.sleep(0.1)  # Allow time for window to respond
```

### 4. Multi-Threading Concerns
**Problem**: GUI operations should be performed on the main thread.
**Solution**: Use thread-safe patterns or queue operations.

---

## Capstone Project: Advanced Window Management Utility

### Project Overview
Build a comprehensive window management utility with the following features:

### Core Features
1. **Window Browser**: List all windows with filtering and search
2. **Layout Manager**: Save and restore window layouts
3. **Automation Scripts**: Create custom automation sequences
4. **Multi-Monitor Support**: Manage windows across multiple displays
5. **Hotkey Integration**: Keyboard shortcuts for common operations

### Technical Requirements

```python
class WindowManager:
    """Advanced window management utility"""
    
    def __init__(self):
        self.layout_manager = WindowLayout()
        self.window_groups = {}
        self.automation_scripts = {}
        self.hotkeys = {}
    
    def start_application(self):
        """Start the window manager application"""
        # Main application logic
        pass
    
    def create_gui(self):
        """Create the main GUI interface"""
        # GUI implementation
        pass
    
    def register_hotkeys(self):
        """Register global hotkeys"""
        # Hotkey registration
        pass
    
    def run_automation_script(self, script_name):
        """Execute automation script"""
        # Script execution
        pass

# Implementation guidelines:
# 1. Use tkinter or PyQt for GUI
# 2. Implement configuration file support
# 3. Add logging and error handling
# 4. Create user documentation
# 5. Include unit tests
```

### Project Deliverables
1. Complete source code with documentation
2. User manual and setup instructions
3. Configuration file examples
4. Test cases and validation scripts
5. Video demonstration of key features

### Evaluation Criteria
- **Functionality**: All core features working correctly
- **User Interface**: Intuitive and professional GUI
- **Error Handling**: Robust error management
- **Documentation**: Clear code and user documentation
- **Performance**: Efficient window operations
- **Extensibility**: Easy to add new features

---

## Additional Resources

### Documentation
- [Windows API Documentation](https://docs.microsoft.com/en-us/windows/win32/api/)
- [pywin32 Documentation](https://github.com/mhammond/pywin32)
- [Window Management Best Practices](https://docs.microsoft.com/en-us/windows/win32/winmsg/windowing)

### Tools for Development
- **Spy++**: Analyze window properties and messages
- **Window Detective**: Alternative window analysis tool
- **Process Monitor**: Monitor window-related file and registry operations
- **API Monitor**: Track API calls made by applications

### Sample Applications
Study these applications for inspiration:
- **PowerToys FancyZones**: Window layout management
- **DisplayFusion**: Multi-monitor window management
- **WindowBlinds**: Window appearance customization
- **AltTab**: Enhanced window switching

---

## Summary

Window management is a powerful capability that allows you to create sophisticated desktop automation and productivity tools. Key takeaways:

1. **Window Enumeration**: Master finding and identifying windows
2. **Property Access**: Understand window properties and states
3. **Manipulation**: Learn various ways to control window behavior
4. **Message Handling**: Communicate with windows effectively
5. **GUI Automation**: Create automated interaction sequences
6. **Multi-Monitor**: Handle complex display configurations
7. **Best Practices**: Always validate handles and handle errors

The skills learned in this module enable you to build professional-grade window management utilities that can significantly enhance user productivity and workflow automation.

**Next Steps**: Proceed to [Phase 3 - Intermediate Skills](../Phase%203%20-%20Intermediate%20Skills/) to learn advanced pywin32 concepts and system integration techniques.

#### Window Finding
```python
# Find window by class name and title
def find_window_by_title(title):
    """Find window by partial title match"""
    def enum_windows_callback(hwnd, windows):
        if win32gui.IsWindowVisible(hwnd):
            window_title = win32gui.GetWindowText(hwnd)
            if title.lower() in window_title.lower():
                windows.append((hwnd, window_title))
        return True
    
    windows = []
    win32gui.EnumWindows(enum_windows_callback, windows)
    return windows

# Example usage
notepad_windows = find_window_by_title("Notepad")
for hwnd, title in notepad_windows:
    print(f"Found: {title} (Handle: {hwnd})")
```

#### Window Information
```python
def get_window_info(hwnd):
    """Get comprehensive window information"""
    try:
        # Basic properties
        title = win32gui.GetWindowText(hwnd)
        class_name = win32gui.GetClassName(hwnd)
        
        # Position and size
        rect = win32gui.GetWindowRect(hwnd)
        left, top, right, bottom = rect
        width = right - left
        height = bottom - top
        
        # Visibility and state
        is_visible = win32gui.IsWindowVisible(hwnd)
        is_minimized = win32gui.IsIconic(hwnd)
        is_maximized = win32gui.IsZoomed(hwnd)
        
        return {
            'handle': hwnd,
            'title': title,
            'class_name': class_name,
            'position': (left, top),
            'size': (width, height),
            'visible': is_visible,
            'minimized': is_minimized,
            'maximized': is_maximized
        }
    except Exception as e:
        return {'error': str(e)}

# Example usage
hwnd = win32gui.FindWindow(None, "Calculator")
if hwnd:
    info = get_window_info(hwnd)
    print(f"Window Info: {info}")
```

#### Window Manipulation
```python
def manipulate_window(hwnd, action, **kwargs):
    """Perform various window operations"""
    try:
        if action == 'move':
            x, y = kwargs.get('x', 0), kwargs.get('y', 0)
            width, height = kwargs.get('width', 300), kwargs.get('height', 200)
            win32gui.MoveWindow(hwnd, x, y, width, height, True)
            
        elif action == 'show':
            win32gui.ShowWindow(hwnd, win32con.SW_SHOW)
            
        elif action == 'hide':
            win32gui.ShowWindow(hwnd, win32con.SW_HIDE)
            
        elif action == 'minimize':
            win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)
            
        elif action == 'maximize':
            win32gui.ShowWindow(hwnd, win32con.SW_MAXIMIZE)
            
        elif action == 'restore':
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            
        elif action == 'close':
            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
            
        elif action == 'bring_to_front':
            win32gui.SetForegroundWindow(hwnd)
            win32gui.BringWindowToTop(hwnd)
            
        return True
    except Exception as e:
        print(f"Error manipulating window: {e}")
        return False

# Example usage
hwnd = win32gui.FindWindow(None, "Notepad")
if hwnd:
    # Move and resize window
    manipulate_window(hwnd, 'move', x=100, y=100, width=800, height=600)
    
    # Bring to front
    manipulate_window(hwnd, 'bring_to_front')
```

### Advanced Window Operations

#### Window Enumeration
```python
class WindowEnumerator:
    def __init__(self):
        self.windows = []
    
    def enum_all_windows(self):
        """Enumerate all visible windows"""
        def callback(hwnd, lparam):
            if win32gui.IsWindowVisible(hwnd):
                title = win32gui.GetWindowText(hwnd)
                if title:  # Only windows with titles
                    self.windows.append({
                        'hwnd': hwnd,
                        'title': title,
                        'class': win32gui.GetClassName(hwnd),
                        'rect': win32gui.GetWindowRect(hwnd)
                    })
            return True
        
        self.windows = []
        win32gui.EnumWindows(callback, None)
        return self.windows
    
    def enum_child_windows(self, parent_hwnd):
        """Enumerate child windows of a parent"""
        children = []
        
        def child_callback(hwnd, lparam):
            children.append({
                'hwnd': hwnd,
                'title': win32gui.GetWindowText(hwnd),
                'class': win32gui.GetClassName(hwnd),
                'rect': win32gui.GetWindowRect(hwnd)
            })
            return True
        
        win32gui.EnumChildWindows(parent_hwnd, child_callback, None)
        return children
    
    def find_windows_by_class(self, class_name):
        """Find windows by class name"""
        matching_windows = []
        for window in self.enum_all_windows():
            if window['class'] == class_name:
                matching_windows.append(window)
        return matching_windows

# Example usage
enumerator = WindowEnumerator()
all_windows = enumerator.enum_all_windows()

print("All visible windows:")
for window in all_windows[:10]:  # Show first 10
    print(f"  {window['title']} ({window['class']})")
```

#### Message Handling
```python
def send_text_to_window(hwnd, text):
    """Send text to a window using messages"""
    try:
        # Set focus to the window
        win32gui.SetForegroundWindow(hwnd)
        time.sleep(0.1)  # Small delay
        
        # Send text character by character
        for char in text:
            # Send WM_CHAR message for each character
            win32api.SendMessage(hwnd, win32con.WM_CHAR, ord(char), 0)
            time.sleep(0.01)  # Small delay between characters
        
        return True
    except Exception as e:
        print(f"Error sending text: {e}")
        return False

def send_keystrokes(hwnd, keys):
    """Send keyboard events to a window"""
    try:
        # Virtual key codes
        vk_codes = {
            'enter': win32con.VK_RETURN,
            'escape': win32con.VK_ESCAPE,
            'tab': win32con.VK_TAB,
            'space': win32con.VK_SPACE,
            'backspace': win32con.VK_BACK,
            'delete': win32con.VK_DELETE,
            'home': win32con.VK_HOME,
            'end': win32con.VK_END
        }
        
        win32gui.SetForegroundWindow(hwnd)
        time.sleep(0.1)
        
        for key in keys:
            if key.lower() in vk_codes:
                vk_code = vk_codes[key.lower()]
                # Send key down and key up messages
                win32api.SendMessage(hwnd, win32con.WM_KEYDOWN, vk_code, 0)
                win32api.SendMessage(hwnd, win32con.WM_KEYUP, vk_code, 0)
            time.sleep(0.05)
        
        return True
    except Exception as e:
        print(f"Error sending keystrokes: {e}")
        return False

# Example usage
notepad_hwnd = win32gui.FindWindow("Notepad", None)
if notepad_hwnd:
    send_text_to_window(notepad_hwnd, "Hello, World!")
    send_keystrokes(notepad_hwnd, ['enter', 'enter'])
    send_text_to_window(notepad_hwnd, "This is automated text!")
```

### Multi-Monitor Support

#### Monitor Information
```python
def get_monitor_info():
    """Get information about all monitors"""
    monitors = []
    
    def monitor_callback(hmonitor, hdc, rect, lparam):
        monitor_info = win32api.GetMonitorInfo(hmonitor)
        monitors.append({
            'handle': hmonitor,
            'device': monitor_info['Device'],
            'work_area': monitor_info['Work'],
            'monitor_area': monitor_info['Monitor'],
            'primary': monitor_info['Flags'] == 1
        })
        return True
    
    win32api.EnumDisplayMonitors(None, None, monitor_callback, None)
    return monitors

def move_window_to_monitor(hwnd, monitor_index=0):
    """Move window to specific monitor"""
    try:
        monitors = get_monitor_info()
        if monitor_index >= len(monitors):
            return False
        
        target_monitor = monitors[monitor_index]
        work_area = target_monitor['work_area']
        
        # Calculate window position on target monitor
        x = work_area[0] + 50  # 50px from left edge
        y = work_area[1] + 50  # 50px from top edge
        width = (work_area[2] - work_area[0]) - 100  # Monitor width - margins
        height = (work_area[3] - work_area[1]) - 100  # Monitor height - margins
        
        win32gui.MoveWindow(hwnd, x, y, width, height, True)
        return True
    except Exception as e:
        print(f"Error moving window to monitor: {e}")
        return False

# Example usage
monitors = get_monitor_info()
print(f"Found {len(monitors)} monitors:")
for i, monitor in enumerate(monitors):
    primary = " (Primary)" if monitor['primary'] else ""
    print(f"  Monitor {i}: {monitor['device']}{primary}")
```

### GUI Automation Framework

#### Window Controller Class
```python
class WindowController:
    def __init__(self, hwnd=None, title=None, class_name=None):
        self.hwnd = hwnd
        if not hwnd:
            self.hwnd = self._find_window(title, class_name)
    
    def _find_window(self, title, class_name):
        """Find window by title or class name"""
        if title:
            return win32gui.FindWindow(class_name, title)
        elif class_name:
            return win32gui.FindWindow(class_name, None)
        return None
    
    def is_valid(self):
        """Check if window handle is valid"""
        return self.hwnd and win32gui.IsWindow(self.hwnd)
    
    def get_rect(self):
        """Get window rectangle"""
        if self.is_valid():
            return win32gui.GetWindowRect(self.hwnd)
        return None
    
    def move(self, x, y, width=None, height=None):
        """Move and optionally resize window"""
        if not self.is_valid():
            return False
        
        if width is None or height is None:
            rect = self.get_rect()
            if rect:
                current_width = rect[2] - rect[0]
                current_height = rect[3] - rect[1]
                width = width or current_width
                height = height or current_height
        
        return win32gui.MoveWindow(self.hwnd, x, y, width, height, True)
    
    def show(self, state=win32con.SW_SHOW):
        """Show window with specified state"""
        if self.is_valid():
            win32gui.ShowWindow(self.hwnd, state)
            return True
        return False
    
    def bring_to_front(self):
        """Bring window to foreground"""
        if self.is_valid():
            win32gui.SetForegroundWindow(self.hwnd)
            win32gui.BringWindowToTop(self.hwnd)
            return True
        return False
    
    def send_text(self, text):
        """Send text to window"""
        if not self.is_valid():
            return False
        
        self.bring_to_front()
        time.sleep(0.1)
        
        for char in text:
            win32api.SendMessage(self.hwnd, win32con.WM_CHAR, ord(char), 0)
            time.sleep(0.01)
        
        return True
    
    def click_at(self, x, y):
        """Simulate mouse click at specific coordinates"""
        if not self.is_valid():
            return False
        
        # Convert to window-relative coordinates
        rect = self.get_rect()
        if rect:
            abs_x = rect[0] + x
            abs_y = rect[1] + y
            
            # Set cursor position and click
            win32api.SetCursorPos((abs_x, abs_y))
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, abs_x, abs_y, 0, 0)
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, abs_x, abs_y, 0, 0)
            return True
        
        return False

# Example usage
calculator = WindowController(title="Calculator")
if calculator.is_valid():
    calculator.bring_to_front()
    calculator.move(100, 100, 400, 500)
    time.sleep(1)
    calculator.click_at(50, 100)  # Click on a button
```

## Best Practices

### 1. Error Handling
```python
def safe_window_operation(hwnd, operation):
    """Safely perform window operations with error handling"""
    try:
        # Check if window is valid
        if not win32gui.IsWindow(hwnd):
            raise ValueError("Invalid window handle")
        
        # Check if window is accessible
        if not win32gui.IsWindowVisible(hwnd):
            print("Warning: Window is not visible")
        
        # Perform operation
        result = operation(hwnd)
        return result
        
    except win32gui.error as e:
        print(f"Win32 GUI error: {e}")
        return False
    except Exception as e:
        print(f"Unexpected error: {e}")
        return False
```

### 2. Resource Management
```python
import contextlib

@contextlib.contextmanager
def window_context(title_or_hwnd):
    """Context manager for window operations"""
    hwnd = title_or_hwnd
    if isinstance(title_or_hwnd, str):
        hwnd = win32gui.FindWindow(None, title_or_hwnd)
    
    if not hwnd or not win32gui.IsWindow(hwnd):
        raise ValueError("Window not found or invalid")
    
    try:
        yield hwnd
    finally:
        # Cleanup if needed
        pass

# Usage
try:
    with window_context("Notepad") as hwnd:
        manipulate_window(hwnd, 'move', x=100, y=100)
        # Window operations here
except ValueError as e:
    print(f"Window operation failed: {e}")
```

### 3. Performance Optimization
```python
class WindowCache:
    def __init__(self):
        self.cache = {}
        self.cache_timeout = 5  # seconds
    
    def get_window_info(self, hwnd):
        """Get window info with caching"""
        current_time = time.time()
        
        if hwnd in self.cache:
            cached_info, timestamp = self.cache[hwnd]
            if current_time - timestamp < self.cache_timeout:
                return cached_info
        
        # Refresh cache
        info = get_window_info(hwnd)
        self.cache[hwnd] = (info, current_time)
        return info
    
    def clear_cache(self):
        """Clear expired cache entries"""
        current_time = time.time()
        expired_keys = [
            hwnd for hwnd, (_, timestamp) in self.cache.items()
            if current_time - timestamp >= self.cache_timeout
        ]
        for key in expired_keys:
            del self.cache[key]
```

## Common Pitfalls and Solutions

### 1. Window Finding Issues
```python
def reliable_window_finder(title_pattern, class_pattern=None, timeout=10):
    """More reliable window finding with retry logic"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        # Try exact match first
        hwnd = win32gui.FindWindow(class_pattern, title_pattern)
        if hwnd:
            return hwnd
        
        # Try partial match
        windows = find_window_by_title(title_pattern)
        if windows:
            return windows[0][0]
        
        time.sleep(0.5)  # Wait before retry
    
    return None
```

### 2. Message Handling Timing
```python
def send_message_with_retry(hwnd, message, wparam, lparam, max_retries=3):
    """Send message with retry logic"""
    for attempt in range(max_retries):
        try:
            if not win32gui.IsWindow(hwnd):
                return False
            
            result = win32api.SendMessage(hwnd, message, wparam, lparam)
            return result
            
        except Exception as e:
            if attempt == max_retries - 1:
                print(f"Failed to send message after {max_retries} attempts: {e}")
                return False
            time.sleep(0.1 * (attempt + 1))  # Exponential backoff
    
    return False
```

### 3. Focus and Activation Issues
```python
def ensure_window_focus(hwnd):
    """Ensure window has focus with multiple methods"""
    try:
        # Method 1: Standard approach
        win32gui.SetForegroundWindow(hwnd)
        
        # Method 2: If that fails, try bringing to top first
        if win32gui.GetForegroundWindow() != hwnd:
            win32gui.BringWindowToTop(hwnd)
            win32gui.SetForegroundWindow(hwnd)
        
        # Method 3: If still fails, try showing the window
        if win32gui.GetForegroundWindow() != hwnd:
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            win32gui.SetForegroundWindow(hwnd)
        
        # Verify focus
        return win32gui.GetForegroundWindow() == hwnd
        
    except Exception as e:
        print(f"Error setting window focus: {e}")
        return False
```

## Practical Exercises

### Exercise 1: Window Inspector
Build a tool that displays detailed information about all visible windows.

```python
def window_inspector():
    """Interactive window inspector"""
    enumerator = WindowEnumerator()
    windows = enumerator.enum_all_windows()
    
    print("Window Inspector")
    print("=" * 50)
    
    for i, window in enumerate(windows):
        print(f"{i+1}. {window['title']}")
        print(f"   Class: {window['class']}")
        print(f"   Handle: {window['hwnd']}")
        print(f"   Position: {window['rect']}")
        print()
    
    # Interactive selection
    try:
        choice = int(input("Select window number for details: ")) - 1
        if 0 <= choice < len(windows):
            selected_window = windows[choice]
            detailed_info = get_window_info(selected_window['hwnd'])
            
            print("\nDetailed Information:")
            for key, value in detailed_info.items():
                print(f"  {key}: {value}")
        else:
            print("Invalid selection")
    except ValueError:
        print("Invalid input")

# Run the inspector
if __name__ == "__main__":
    window_inspector()
```

### Exercise 2: Window Layout Manager
Create a utility to save and restore window layouts.

```python
import json
import os

class WindowLayoutManager:
    def __init__(self, layout_file="window_layouts.json"):
        self.layout_file = layout_file
        self.layouts = self.load_layouts()
    
    def load_layouts(self):
        """Load saved layouts from file"""
        if os.path.exists(self.layout_file):
            try:
                with open(self.layout_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error loading layouts: {e}")
        return {}
    
    def save_layouts(self):
        """Save layouts to file"""
        try:
            with open(self.layout_file, 'w') as f:
                json.dump(self.layouts, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving layouts: {e}")
            return False
    
    def capture_layout(self, name):
        """Capture current window layout"""
        enumerator = WindowEnumerator()
        windows = enumerator.enum_all_windows()
        
        layout = []
        for window in windows:
            if window['title']:  # Only windows with titles
                layout.append({
                    'title': window['title'],
                    'class': window['class'],
                    'rect': window['rect']
                })
        
        self.layouts[name] = layout
        self.save_layouts()
        print(f"Layout '{name}' captured with {len(layout)} windows")
    
    def restore_layout(self, name):
        """Restore a saved layout"""
        if name not in self.layouts:
            print(f"Layout '{name}' not found")
            return False
        
        layout = self.layouts[name]
        restored_count = 0
        
        for window_info in layout:
            # Find window by title
            hwnd = win32gui.FindWindow(None, window_info['title'])
            if hwnd:
                rect = window_info['rect']
                x, y = rect[0], rect[1]
                width = rect[2] - rect[0]
                height = rect[3] - rect[1]
                
                if manipulate_window(hwnd, 'move', x=x, y=y, width=width, height=height):
                    restored_count += 1
        
        print(f"Restored {restored_count}/{len(layout)} windows")
        return restored_count > 0
    
    def list_layouts(self):
        """List all saved layouts"""
        if not self.layouts:
            print("No saved layouts")
            return
        
        print("Saved layouts:")
        for name, layout in self.layouts.items():
            print(f"  {name}: {len(layout)} windows")

# Usage example
layout_manager = WindowLayoutManager()

# Capture current layout
layout_manager.capture_layout("work_setup")

# List layouts
layout_manager.list_layouts()

# Restore layout
layout_manager.restore_layout("work_setup")
```

### Exercise 3: GUI Automation Script
Build a script that automates interactions with a calculator application.

```python
class CalculatorAutomator:
    def __init__(self):
        self.hwnd = None
        self.find_calculator()
    
    def find_calculator(self):
        """Find and launch calculator if needed"""
        # Try to find existing calculator
        self.hwnd = win32gui.FindWindow("CalcFrame", None)
        
        if not self.hwnd:
            # Launch calculator
            import subprocess
            subprocess.Popen("calc.exe")
            time.sleep(2)  # Wait for launch
            self.hwnd = win32gui.FindWindow("CalcFrame", None)
        
        if self.hwnd:
            print("Calculator found and ready")
            return True
        else:
            print("Could not find or launch calculator")
            return False
    
    def click_button(self, button_text):
        """Click a calculator button by text"""
        if not self.hwnd:
            return False
        
        # Button mapping (simplified - would need actual button locations)
        button_map = {
            '0': (150, 250), '1': (100, 200), '2': (150, 200), '3': (200, 200),
            '4': (100, 170), '5': (150, 170), '6': (200, 170),
            '7': (100, 140), '8': (150, 140), '9': (200, 140),
            '+': (250, 200), '-': (250, 170), '*': (250, 140), '/': (250, 110),
            '=': (250, 250), 'C': (200, 110)
        }
        
        if button_text in button_map:
            x, y = button_map[button_text]
            controller = WindowController(hwnd=self.hwnd)
            controller.bring_to_front()
            time.sleep(0.1)
            return controller.click_at(x, y)
        
        return False
    
    def calculate(self, expression):
        """Perform a calculation"""
        self.click_button('C')  # Clear first
        time.sleep(0.1)
        
        for char in expression:
            if char in '0123456789+-*/=':
                self.click_button(char)
                time.sleep(0.2)
        
        self.click_button('=')
        print(f"Calculated: {expression}")

# Usage
calc = CalculatorAutomator()
if calc.hwnd:
    calc.calculate("123+456")
    time.sleep(2)
    calc.calculate("789*2")
```

## Project: Window Management Utility

### Project Overview
Build a comprehensive window management utility that provides:
- Window enumeration and filtering
- Layout saving and restoration
- Quick window operations (minimize all, restore all, etc.)
- Multi-monitor support
- Keyboard shortcuts
- System tray integration

### Core Features

#### 1. Main Window Manager Class
```python
import tkinter as tk
from tkinter import ttk, messagebox
import threading

class WindowManagerGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Advanced Window Manager")
        self.root.geometry("800x600")
        
        self.layout_manager = WindowLayoutManager()
        self.setup_ui()
        self.refresh_windows()
    
    def setup_ui(self):
        """Setup the user interface"""
        # Main notebook for tabs
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Windows tab
        windows_frame = ttk.Frame(notebook)
        notebook.add(windows_frame, text="Windows")
        self.setup_windows_tab(windows_frame)
        
        # Layouts tab
        layouts_frame = ttk.Frame(notebook)
        notebook.add(layouts_frame, text="Layouts")
        self.setup_layouts_tab(layouts_frame)
        
        # Tools tab
        tools_frame = ttk.Frame(notebook)
        notebook.add(tools_frame, text="Tools")
        self.setup_tools_tab(tools_frame)
    
    def setup_windows_tab(self, parent):
        """Setup windows management tab"""
        # Treeview for window list
        columns = ('Title', 'Class', 'Handle', 'Position', 'Size')
        self.windows_tree = ttk.Treeview(parent, columns=columns, show='headings')
        
        for col in columns:
            self.windows_tree.heading(col, text=col)
            self.windows_tree.column(col, width=120)
        
        self.windows_tree.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Control buttons
        button_frame = ttk.Frame(parent)
        button_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Button(button_frame, text="Refresh", command=self.refresh_windows).pack(side='left', padx=2)
        ttk.Button(button_frame, text="Bring to Front", command=self.bring_to_front).pack(side='left', padx=2)
        ttk.Button(button_frame, text="Minimize", command=self.minimize_selected).pack(side='left', padx=2)
        ttk.Button(button_frame, text="Close", command=self.close_selected).pack(side='left', padx=2)
    
    def setup_layouts_tab(self, parent):
        """Setup layout management tab"""
        # Layout list
        self.layouts_listbox = tk.Listbox(parent)
        self.layouts_listbox.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Layout controls
        layout_controls = ttk.Frame(parent)
        layout_controls.pack(fill='x', padx=5, pady=5)
        
        self.layout_name_var = tk.StringVar()
        ttk.Label(layout_controls, text="Layout Name:").pack(side='left')
        ttk.Entry(layout_controls, textvariable=self.layout_name_var, width=20).pack(side='left', padx=5)
        
        ttk.Button(layout_controls, text="Capture", command=self.capture_layout).pack(side='left', padx=2)
        ttk.Button(layout_controls, text="Restore", command=self.restore_layout).pack(side='left', padx=2)
        ttk.Button(layout_controls, text="Delete", command=self.delete_layout).pack(side='left', padx=2)
        
        self.refresh_layouts()
    
    def setup_tools_tab(self, parent):
        """Setup tools and utilities tab"""
        # Quick actions
        quick_frame = ttk.LabelFrame(parent, text="Quick Actions")
        quick_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Button(quick_frame, text="Minimize All", command=self.minimize_all).pack(side='left', padx=5, pady=5)
        ttk.Button(quick_frame, text="Restore All", command=self.restore_all).pack(side='left', padx=5, pady=5)
        ttk.Button(quick_frame, text="Tile Windows", command=self.tile_windows).pack(side='left', padx=5, pady=5)
        
        # Monitor info
        monitor_frame = ttk.LabelFrame(parent, text="Monitor Information")
        monitor_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        self.monitor_info_text = tk.Text(monitor_frame, height=10)
        self.monitor_info_text.pack(fill='both', expand=True, padx=5, pady=5)
        
        self.refresh_monitor_info()
    
    def refresh_windows(self):
        """Refresh the windows list"""
        # Clear existing items
        for item in self.windows_tree.get_children():
            self.windows_tree.delete(item)
        
        # Get current windows
        enumerator = WindowEnumerator()
        windows = enumerator.enum_all_windows()
        
        for window in windows:
            rect = window['rect']
            position = f"{rect[0]}, {rect[1]}"
            size = f"{rect[2]-rect[0]}x{rect[3]-rect[1]}"
            
            self.windows_tree.insert('', 'end', values=(
                window['title'][:50],  # Truncate long titles
                window['class'],
                window['hwnd'],
                position,
                size
            ))
    
    def get_selected_window_handle(self):
        """Get the handle of the selected window"""
        selection = self.windows_tree.selection()
        if selection:
            item = self.windows_tree.item(selection[0])
            return int(item['values'][2])  # Handle is in column 2
        return None
    
    def bring_to_front(self):
        """Bring selected window to front"""
        hwnd = self.get_selected_window_handle()
        if hwnd:
            manipulate_window(hwnd, 'bring_to_front')
    
    def minimize_selected(self):
        """Minimize selected window"""
        hwnd = self.get_selected_window_handle()
        if hwnd:
            manipulate_window(hwnd, 'minimize')
            self.refresh_windows()
    
    def close_selected(self):
        """Close selected window"""
        hwnd = self.get_selected_window_handle()
        if hwnd:
            if messagebox.askyesno("Confirm", "Close the selected window?"):
                manipulate_window(hwnd, 'close')
                self.refresh_windows()
    
    def capture_layout(self):
        """Capture current layout"""
        name = self.layout_name_var.get().strip()
        if name:
            self.layout_manager.capture_layout(name)
            self.refresh_layouts()
            self.layout_name_var.set("")
        else:
            messagebox.showwarning("Warning", "Please enter a layout name")
    
    def restore_layout(self):
        """Restore selected layout"""
        selection = self.layouts_listbox.curselection()
        if selection:
            layout_name = self.layouts_listbox.get(selection[0])
            self.layout_manager.restore_layout(layout_name)
            self.refresh_windows()
    
    def delete_layout(self):
        """Delete selected layout"""
        selection = self.layouts_listbox.curselection()
        if selection:
            layout_name = self.layouts_listbox.get(selection[0])
            if messagebox.askyesno("Confirm", f"Delete layout '{layout_name}'?"):
                del self.layout_manager.layouts[layout_name]
                self.layout_manager.save_layouts()
                self.refresh_layouts()
    
    def refresh_layouts(self):
        """Refresh the layouts list"""
        self.layouts_listbox.delete(0, tk.END)
        for name in self.layout_manager.layouts.keys():
            self.layouts_listbox.insert(tk.END, name)
    
    def minimize_all(self):
        """Minimize all windows"""
        enumerator = WindowEnumerator()
        windows = enumerator.enum_all_windows()
        
        for window in windows:
            if window['title'] != "Advanced Window Manager":  # Don't minimize ourselves
                manipulate_window(window['hwnd'], 'minimize')
        
        self.refresh_windows()
    
    def restore_all(self):
        """Restore all minimized windows"""
        enumerator = WindowEnumerator()
        windows = enumerator.enum_all_windows()
        
        for window in windows:
            if win32gui.IsIconic(window['hwnd']):  # If minimized
                manipulate_window(window['hwnd'], 'restore')
        
        self.refresh_windows()
    
    def tile_windows(self):
        """Tile visible windows"""
        enumerator = WindowEnumerator()
        windows = [w for w in enumerator.enum_all_windows() 
                  if w['title'] != "Advanced Window Manager" and 
                  win32gui.IsWindowVisible(w['hwnd']) and 
                  not win32gui.IsIconic(w['hwnd'])]
        
        if not windows:
            return
        
        # Get primary monitor work area
        monitors = get_monitor_info()
        primary_monitor = next((m for m in monitors if m['primary']), monitors[0])
        work_area = primary_monitor['work_area']
        
        # Calculate tile layout
        cols = int(len(windows) ** 0.5) + 1
        rows = (len(windows) + cols - 1) // cols
        
        tile_width = (work_area[2] - work_area[0]) // cols
        tile_height = (work_area[3] - work_area[1]) // rows
        
        for i, window in enumerate(windows):
            row = i // cols
            col = i % cols
            
            x = work_area[0] + col * tile_width
            y = work_area[1] + row * tile_height
            
            manipulate_window(window['hwnd'], 'move', 
                            x=x, y=y, width=tile_width, height=tile_height)
        
        self.refresh_windows()
    
    def refresh_monitor_info(self):
        """Refresh monitor information display"""
        self.monitor_info_text.delete('1.0', tk.END)
        
        monitors = get_monitor_info()
        info_text = f"Found {len(monitors)} monitor(s):\n\n"
        
        for i, monitor in enumerate(monitors):
            primary = " (Primary)" if monitor['primary'] else ""
            info_text += f"Monitor {i+1}{primary}:\n"
            info_text += f"  Device: {monitor['device']}\n"
            info_text += f"  Resolution: {monitor['monitor_area'][2]}x{monitor['monitor_area'][3]}\n"
            info_text += f"  Work Area: {monitor['work_area']}\n\n"
        
        self.monitor_info_text.insert('1.0', info_text)
    
    def run(self):
        """Start the application"""
        self.root.mainloop()

# Launch the application
if __name__ == "__main__":
    app = WindowManagerGUI()
    app.run()
```

### Additional Features

#### 1. Keyboard Shortcuts
```python
import keyboard

class KeyboardShortcuts:
    def __init__(self, window_manager):
        self.window_manager = window_manager
        self.setup_shortcuts()
    
    def setup_shortcuts(self):
        """Setup global keyboard shortcuts"""
        keyboard.add_hotkey('ctrl+alt+m', self.minimize_all)
        keyboard.add_hotkey('ctrl+alt+r', self.restore_all)
        keyboard.add_hotkey('ctrl+alt+t', self.tile_windows)
        keyboard.add_hotkey('ctrl+alt+1', lambda: self.restore_layout_by_index(0))
        keyboard.add_hotkey('ctrl+alt+2', lambda: self.restore_layout_by_index(1))
    
    def minimize_all(self):
        """Hotkey handler for minimize all"""
        self.window_manager.minimize_all()
    
    def restore_all(self):
        """Hotkey handler for restore all"""
        self.window_manager.restore_all()
    
    def tile_windows(self):
        """Hotkey handler for tile windows"""
        self.window_manager.tile_windows()
    
    def restore_layout_by_index(self, index):
        """Restore layout by index"""
        layouts = list(self.window_manager.layout_manager.layouts.keys())
        if 0 <= index < len(layouts):
            layout_name = layouts[index]
            self.window_manager.layout_manager.restore_layout(layout_name)
```

#### 2. System Tray Integration
```python
import pystray
from PIL import Image
import threading

class SystemTrayIntegration:
    def __init__(self, window_manager):
        self.window_manager = window_manager
        self.icon = None
        self.setup_tray()
    
    def setup_tray(self):
        """Setup system tray icon"""
        # Create a simple icon (you'd normally load from file)
        image = Image.new('RGB', (64, 64), color='blue')
        
        menu = pystray.Menu(
            pystray.MenuItem("Show", self.show_window),
            pystray.MenuItem("Minimize All", self.minimize_all),
            pystray.MenuItem("Restore All", self.restore_all),
            pystray.MenuItem("Tile Windows", self.tile_windows),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem("Exit", self.quit_app)
        )
        
        self.icon = pystray.Icon("WindowManager", image, menu=menu)
    
    def show_window(self, icon, item):
        """Show the main window"""
        self.window_manager.root.deiconify()
        self.window_manager.root.lift()
    
    def minimize_all(self, icon, item):
        """Minimize all windows"""
        self.window_manager.minimize_all()
    
    def restore_all(self, icon, item):
        """Restore all windows"""
        self.window_manager.restore_all()
    
    def tile_windows(self, icon, item):
        """Tile windows"""
        self.window_manager.tile_windows()
    
    def quit_app(self, icon, item):
        """Quit the application"""
        icon.stop()
        self.window_manager.root.quit()
    
    def run(self):
        """Run the tray icon"""
        self.icon.run_detached()
```

## Assessment and Testing

### Unit Tests
```python
import unittest
from unittest.mock import patch, MagicMock

class TestWindowManagement(unittest.TestCase):
    def setUp(self):
        self.test_hwnd = 12345
    
    @patch('win32gui.IsWindow')
    @patch('win32gui.GetWindowText')
    def test_get_window_info(self, mock_get_text, mock_is_window):
        """Test window information retrieval"""
        mock_is_window.return_value = True
        mock_get_text.return_value = "Test Window"
        
        # Test would continue with actual implementation
        pass
    
    def test_window_enumeration(self):
        """Test window enumeration functionality"""
        enumerator = WindowEnumerator()
        windows = enumerator.enum_all_windows()
        
        # Verify results
        self.assertIsInstance(windows, list)
        if windows:
            self.assertIn('hwnd', windows[0])
            self.assertIn('title', windows[0])
    
    def test_layout_manager(self):
        """Test layout save and restore"""
        manager = WindowLayoutManager("test_layouts.json")
        
        # Test capture
        manager.capture_layout("test_layout")
        self.assertIn("test_layout", manager.layouts)
        
        # Clean up
        if os.path.exists("test_layouts.json"):
            os.remove("test_layouts.json")

if __name__ == "__main__":
    unittest.main()
```

### Integration Tests
```python
def integration_test():
    """Test the complete window management workflow"""
    print("Starting integration test...")
    
    # Test 1: Find a known window (like Explorer)
    explorer_hwnd = win32gui.FindWindow("CabinetWClass", None)
    if explorer_hwnd:
        print(f" Found Explorer window: {explorer_hwnd}")
        
        # Test window manipulation
        original_rect = win32gui.GetWindowRect(explorer_hwnd)
        print(f" Original position: {original_rect}")
        
        # Move window
        if manipulate_window(explorer_hwnd, 'move', x=100, y=100, width=600, height=400):
            print(" Window moved successfully")
            
            # Restore original position
            x, y = original_rect[0], original_rect[1]
            width = original_rect[2] - original_rect[0]
            height = original_rect[3] - original_rect[1]
            manipulate_window(explorer_hwnd, 'move', x=x, y=y, width=width, height=height)
            print(" Window restored to original position")
        else:
            print(" Failed to move window")
    else:
        print(" Explorer window not found")
    
    # Test 2: Window enumeration
    enumerator = WindowEnumerator()
    windows = enumerator.enum_all_windows()
    print(f" Found {len(windows)} windows")
    
    # Test 3: Layout management
    layout_manager = WindowLayoutManager("test_layout.json")
    layout_manager.capture_layout("test")
    print(" Layout captured")
    
    # Clean up
    if os.path.exists("test_layout.json"):
        os.remove("test_layout.json")
    
    print("Integration test completed!")

# Run integration test
if __name__ == "__main__":
    integration_test()
```

## Summary

This module has covered comprehensive window management using pywin32, including:

1. **Window Finding and Enumeration**: Techniques for locating and listing windows
2. **Window Manipulation**: Moving, resizing, showing, hiding, and controlling windows
3. **Message Handling**: Sending keyboard and mouse events to windows
4. **Multi-Monitor Support**: Working with multiple displays
5. **GUI Automation**: Building automation frameworks for desktop applications
6. **Layout Management**: Saving and restoring window arrangements
7. **Advanced Features**: System tray integration and keyboard shortcuts

The practical project demonstrates how to combine these concepts into a real-world application. You now have the skills to build sophisticated window management tools and GUI automation solutions.

**Next Steps**: 
- Practice with the provided exercises
- Complete the window management utility project
- Explore advanced topics like custom window procedures
- Move on to Phase 3 for intermediate-level pywin32 programming

**Estimated Completion Time**: 1 week
**Difficulty Level**: Intermediate
**Prerequisites**: Understanding of basic GUI concepts and Windows API fundamentals
