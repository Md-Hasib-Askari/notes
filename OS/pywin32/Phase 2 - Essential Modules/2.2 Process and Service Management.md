# 2.2 Process and Service Management

## Learning Objectives
By the end of this section, you will:
- Master process creation, enumeration, and manipulation
- Understand Windows service architecture and control
- Implement process monitoring and resource tracking
- Handle threading and synchronization
- Build comprehensive process and service management tools

## Process Management with win32process

### Process Creation and Control
```python
import win32process
import win32api
import win32con
import win32event
import time
import threading

class ProcessManager:
    """Advanced process management using win32process"""
    
    def __init__(self):
        self.active_processes = {}
    
    def create_process(self, command_line, working_directory=None, environment=None, 
                      window_style=win32con.SW_NORMAL, wait_for_completion=False):
        """Create a new process with advanced options"""
        try:
            # Prepare startup info
            startup_info = win32process.STARTUPINFO()
            startup_info.dwFlags = win32process.STARTF_USESHOWWINDOW
            startup_info.wShowWindow = window_style
            
            # Create the process
            process_info = win32process.CreateProcess(
                None,  # Application name (use command line)
                command_line,  # Command line
                None,  # Process security attributes
                None,  # Thread security attributes
                False,  # Inherit handles
                0,  # Creation flags
                environment,  # Environment variables
                working_directory,  # Current directory
                startup_info  # Startup info
            )
            
            process_handle, thread_handle, process_id, thread_id = process_info
            
            # Store process information
            process_data = {
                'process_handle': process_handle,
                'thread_handle': thread_handle,
                'process_id': process_id,
                'thread_id': thread_id,
                'command_line': command_line,
                'start_time': time.time(),
                'status': 'running'
            }
            
            self.active_processes[process_id] = process_data
            
            if wait_for_completion:
                return self.wait_for_process(process_id)
            
            return process_id
            
        except Exception as e:
            print(f"Error creating process: {e}")
            return None
    
    def enumerate_processes(self, include_system=False):
        """Enumerate all running processes"""
        try:
            process_ids = win32process.EnumProcesses()
            processes = []
            
            for pid in process_ids:
                try:
                    # Skip system processes if not requested
                    if not include_system and pid in [0, 4]:
                        continue
                    
                    # Get process handle
                    process_handle = win32api.OpenProcess(
                        win32con.PROCESS_QUERY_INFORMATION | win32con.PROCESS_VM_READ,
                        False,
                        pid
                    )
                    
                    if process_handle:
                        # Get process information
                        process_info = self._get_process_info(process_handle, pid)
                        processes.append(process_info)
                        
                        win32api.CloseHandle(process_handle)
                
                except Exception:
                    # Skip processes we can't access
                    continue
            
            return processes
            
        except Exception as e:
            print(f"Error enumerating processes: {e}")
            return []
    
    def _get_process_info(self, process_handle, pid):
        """Get detailed process information"""
        try:
            # Get process name
            try:
                process_name = win32process.GetModuleFileNameEx(process_handle, 0)
            except:
                process_name = f"PID_{pid}"
            
            # Get memory information
            try:
                memory_info = win32process.GetProcessMemoryInfo(process_handle)
                working_set = memory_info['WorkingSetSize']
                peak_working_set = memory_info['PeakWorkingSetSize']
            except:
                working_set = 0
                peak_working_set = 0
            
            # Get process times
            try:
                creation_time, exit_time, kernel_time, user_time = win32process.GetProcessTimes(process_handle)
                cpu_time = kernel_time + user_time
            except:
                creation_time = None
                cpu_time = 0
            
            return {
                'pid': pid,
                'name': process_name.split('\\')[-1] if process_name else f"PID_{pid}",
                'full_path': process_name,
                'memory_usage': working_set,
                'peak_memory': peak_working_set,
                'cpu_time': cpu_time,
                'creation_time': creation_time,
                'status': 'running'
            }
            
        except Exception as e:
            return {
                'pid': pid,
                'name': f"PID_{pid}",
                'full_path': 'Unknown',
                'memory_usage': 0,
                'peak_memory': 0,
                'cpu_time': 0,
                'creation_time': None,
                'status': 'unknown'
            }
    
    def terminate_process(self, pid, exit_code=0):
        """Terminate a process by PID"""
        try:
            process_handle = win32api.OpenProcess(
                win32con.PROCESS_TERMINATE,
                False,
                pid
            )
            
            if process_handle:
                result = win32process.TerminateProcess(process_handle, exit_code)
                win32api.CloseHandle(process_handle)
                
                # Update our tracking
                if pid in self.active_processes:
                    self.active_processes[pid]['status'] = 'terminated'
                
                return result
            
            return False
            
        except Exception as e:
            print(f"Error terminating process {pid}: {e}")
            return False
    
    def wait_for_process(self, pid, timeout=None):
        """Wait for process to complete"""
        if pid not in self.active_processes:
            return False
        
        process_handle = self.active_processes[pid]['process_handle']
        timeout_ms = int(timeout * 1000) if timeout else win32event.INFINITE
        
        try:
            result = win32event.WaitForSingleObject(process_handle, timeout_ms)
            
            if result == win32event.WAIT_OBJECT_0:
                # Process completed
                exit_code = win32process.GetExitCodeProcess(process_handle)
                self.active_processes[pid]['status'] = 'completed'
                self.active_processes[pid]['exit_code'] = exit_code
                return True
            elif result == win32event.WAIT_TIMEOUT:
                return False
            
        except Exception as e:
            print(f"Error waiting for process: {e}")
            return False
    
    def get_process_status(self, pid):
        """Get status of tracked process"""
        if pid in self.active_processes:
            return self.active_processes[pid]['status']
        return 'not_found'
    
    def cleanup_completed_processes(self):
        """Clean up handles for completed processes"""
        completed_pids = []
        
        for pid, process_data in self.active_processes.items():
            if process_data['status'] in ['completed', 'terminated']:
                try:
                    win32api.CloseHandle(process_data['process_handle'])
                    win32api.CloseHandle(process_data['thread_handle'])
                    completed_pids.append(pid)
                except:
                    pass
        
        for pid in completed_pids:
            del self.active_processes[pid]

# Example usage
def process_management_demo():
    """Demonstrate process management capabilities"""
    manager = ProcessManager()
    
    print("=== PROCESS ENUMERATION ===")
    processes = manager.enumerate_processes(include_system=True)
    
    # Show top 10 processes by memory usage
    processes.sort(key=lambda p: p['memory_usage'], reverse=True)
    print("Top 10 processes by memory usage:")
    for i, proc in enumerate(processes[:10]):
        memory_mb = proc['memory_usage'] / (1024 * 1024)
        print(f"{i+1:2d}. {proc['name']:<20} PID: {proc['pid']:<6} Memory: {memory_mb:.1f} MB")
    
    print("\n=== PROCESS CREATION ===")
    # Create a simple process (notepad)
    pid = manager.create_process("notepad.exe")
    if pid:
        print(f"Created notepad process with PID: {pid}")
        
        # Wait a bit then terminate
        time.sleep(3)
        print(f"Terminating process {pid}")
        manager.terminate_process(pid)
        
        # Check status
        status = manager.get_process_status(pid)
        print(f"Process status: {status}")
    
    # Cleanup
    manager.cleanup_completed_processes()

# Run the demo
process_management_demo()
```

### Environment Variables and Working Directory
```python
import win32process
import win32api
import os

class ProcessEnvironment:
    """Manage process environment variables and working directory"""
    
    @staticmethod
    def create_process_with_environment(command, custom_env=None, working_dir=None):
        """Create process with custom environment"""
        try:
            # Get current environment
            current_env = dict(os.environ)
            
            # Update with custom environment if provided
            if custom_env:
                current_env.update(custom_env)
            
            # Convert environment to Windows format
            env_block = []
            for key, value in current_env.items():
                env_block.append(f"{key}={value}")
            env_string = '\0'.join(env_block) + '\0\0'
            
            # Setup startup info
            startup_info = win32process.STARTUPINFO()
            
            # Create process
            process_info = win32process.CreateProcess(
                None,  # Application name
                command,  # Command line
                None,  # Process security
                None,  # Thread security
                False,  # Inherit handles
                win32process.CREATE_UNICODE_ENVIRONMENT,  # Creation flags
                env_string,  # Environment
                working_dir,  # Current directory
                startup_info  # Startup info
            )
            
            return process_info
            
        except Exception as e:
            print(f"Error creating process with environment: {e}")
            return None
    
    @staticmethod
    def get_process_environment(pid):
        """Get environment variables of a running process"""
        try:
            # This is a simplified version - actual implementation
            # would require more complex memory reading
            process_handle = win32api.OpenProcess(
                win32con.PROCESS_QUERY_INFORMATION | win32con.PROCESS_VM_READ,
                False,
                pid
            )
            
            if process_handle:
                # In a real implementation, you would need to read
                # the process environment block from memory
                win32api.CloseHandle(process_handle)
                return {"note": "Environment reading requires advanced memory operations"}
            
        except Exception as e:
            print(f"Error getting process environment: {e}")
            return None

# Example usage
def environment_demo():
    """Demonstrate environment variable management"""
    # Custom environment for child process
    custom_env = {
        'CUSTOM_VAR': 'Hello from pywin32',
        'DEBUG_MODE': '1',
        'APP_CONFIG': 'production'
    }
    
    # Create process with custom environment
    print("Creating process with custom environment...")
    process_info = ProcessEnvironment.create_process_with_environment(
        'cmd.exe /c echo %CUSTOM_VAR% && pause',
        custom_env=custom_env
    )
    
    if process_info:
        process_handle, thread_handle, process_id, thread_id = process_info
        print(f"Created process {process_id} with custom environment")
        
        # Wait for process to complete
        win32event.WaitForSingleObject(process_handle, 10000)  # 10 second timeout
        
        # Cleanup
        win32api.CloseHandle(process_handle)
        win32api.CloseHandle(thread_handle)

# Run the demo
environment_demo()
```

## Windows Service Management

### Service Control and Monitoring
```python
import win32service
import win32serviceutil
import win32api
import win32con
import time

class ServiceManager:
    """Windows service management and control"""
    
    def __init__(self):
        self.scm_handle = None
        self._connect_to_scm()
    
    def _connect_to_scm(self):
        """Connect to Service Control Manager"""
        try:
            self.scm_handle = win32service.OpenSCManager(
                None,  # Machine name (None = local)
                None,  # Database name (None = default)
                win32service.SC_MANAGER_ALL_ACCESS
            )
        except Exception as e:
            print(f"Error connecting to SCM: {e}")
    
    def enumerate_services(self, service_type=None, service_state=None):
        """Enumerate Windows services"""
        if not self.scm_handle:
            return []
        
        try:
            # Set default values
            if service_type is None:
                service_type = win32service.SERVICE_WIN32
            if service_state is None:
                service_state = win32service.SERVICE_STATE_ALL
            
            # Enumerate services
            services = win32service.EnumServicesStatus(
                self.scm_handle,
                service_type,
                service_state
            )
            
            service_list = []
            for service in services:
                service_name, display_name, service_status = service
                
                # Get additional service information
                service_info = self.get_service_info(service_name)
                if service_info:
                    service_info.update({
                        'service_name': service_name,
                        'display_name': display_name,
                        'status': self._get_service_state_name(service_status[1]),
                        'controls_accepted': service_status[2],
                        'win32_exit_code': service_status[3],
                        'service_exit_code': service_status[4],
                        'check_point': service_status[5],
                        'wait_hint': service_status[6]
                    })
                    service_list.append(service_info)
            
            return service_list
            
        except Exception as e:
            print(f"Error enumerating services: {e}")
            return []
    
    def get_service_info(self, service_name):
        """Get detailed information about a specific service"""
        if not self.scm_handle:
            return None
        
        try:
            service_handle = win32service.OpenService(
                self.scm_handle,
                service_name,
                win32service.SERVICE_QUERY_CONFIG | win32service.SERVICE_QUERY_STATUS
            )
            
            # Get service configuration
            config = win32service.QueryServiceConfig(service_handle)
            
            # Get service status
            status = win32service.QueryServiceStatusEx(service_handle)
            
            service_info = {
                'service_type': config[0],
                'start_type': self._get_start_type_name(config[1]),
                'error_control': config[2],
                'binary_path': config[3],
                'load_order_group': config[4],
                'tag_id': config[5],
                'dependencies': config[6],
                'service_start_name': config[7],
                'display_name': config[8],
                'current_state': self._get_service_state_name(status['CurrentState']),
                'process_id': status.get('ProcessId', 0),
                'service_flags': status.get('ServiceFlags', 0)
            }
            
            win32service.CloseServiceHandle(service_handle)
            return service_info
            
        except Exception as e:
            print(f"Error getting service info for {service_name}: {e}")
            return None
    
    def control_service(self, service_name, control_code):
        """Send control code to service"""
        if not self.scm_handle:
            return False
        
        try:
            service_handle = win32service.OpenService(
                self.scm_handle,
                service_name,
                win32service.SERVICE_ALL_ACCESS
            )
            
            # Send control code
            status = win32service.ControlService(service_handle, control_code)
            
            win32service.CloseServiceHandle(service_handle)
            return True
            
        except Exception as e:
            print(f"Error controlling service {service_name}: {e}")
            return False
    
    def start_service(self, service_name, args=None):
        """Start a Windows service"""
        if not self.scm_handle:
            return False
        
        try:
            service_handle = win32service.OpenService(
                self.scm_handle,
                service_name,
                win32service.SERVICE_START
            )
            
            win32service.StartService(service_handle, args or [])
            
            win32service.CloseServiceHandle(service_handle)
            return True
            
        except Exception as e:
            print(f"Error starting service {service_name}: {e}")
            return False
    
    def stop_service(self, service_name):
        """Stop a Windows service"""
        return self.control_service(service_name, win32service.SERVICE_CONTROL_STOP)
    
    def pause_service(self, service_name):
        """Pause a Windows service"""
        return self.control_service(service_name, win32service.SERVICE_CONTROL_PAUSE)
    
    def continue_service(self, service_name):
        """Continue a paused Windows service"""
        return self.control_service(service_name, win32service.SERVICE_CONTROL_CONTINUE)
    
    def wait_for_service_status(self, service_name, desired_status, timeout=30):
        """Wait for service to reach desired status"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            service_info = self.get_service_info(service_name)
            if service_info and service_info['current_state'] == desired_status:
                return True
            time.sleep(1)
        
        return False
    
    def _get_service_state_name(self, state_code):
        """Convert service state code to name"""
        states = {
            win32service.SERVICE_STOPPED: 'STOPPED',
            win32service.SERVICE_START_PENDING: 'START_PENDING',
            win32service.SERVICE_STOP_PENDING: 'STOP_PENDING',
            win32service.SERVICE_RUNNING: 'RUNNING',
            win32service.SERVICE_CONTINUE_PENDING: 'CONTINUE_PENDING',
            win32service.SERVICE_PAUSE_PENDING: 'PAUSE_PENDING',
            win32service.SERVICE_PAUSED: 'PAUSED'
        }
        return states.get(state_code, f'UNKNOWN_{state_code}')
    
    def _get_start_type_name(self, start_type):
        """Convert start type code to name"""
        start_types = {
            win32service.SERVICE_BOOT_START: 'BOOT',
            win32service.SERVICE_SYSTEM_START: 'SYSTEM',
            win32service.SERVICE_AUTO_START: 'AUTOMATIC',
            win32service.SERVICE_DEMAND_START: 'MANUAL',
            win32service.SERVICE_DISABLED: 'DISABLED'
        }
        return start_types.get(start_type, f'UNKNOWN_{start_type}')
    
    def close(self):
        """Close SCM handle"""
        if self.scm_handle:
            win32service.CloseServiceHandle(self.scm_handle)
            self.scm_handle = None

# Example usage
def service_management_demo():
    """Demonstrate service management capabilities"""
    manager = ServiceManager()
    
    try:
        print("=== WINDOWS SERVICES ===")
        services = manager.enumerate_services()
        
        # Filter running services
        running_services = [s for s in services if s['current_state'] == 'RUNNING']
        print(f"Found {len(running_services)} running services out of {len(services)} total")
        
        # Show some interesting services
        interesting_services = ['Spooler', 'Themes', 'AudioSrv', 'BITS']
        
        print("\nStatus of interesting services:")
        for service_name in interesting_services:
            service_info = manager.get_service_info(service_name)
            if service_info:
                print(f"  {service_name}: {service_info['current_state']} ({service_info['start_type']})")
        
        # Demonstrate service control (be careful with this!)
        print("\n=== SERVICE CONTROL DEMO ===")
        print("Note: Service control operations require administrator privileges")
        
        # Example of getting detailed info for Windows Audio service
        audio_service = manager.get_service_info('AudioSrv')
        if audio_service:
            print(f"\nWindows Audio Service Details:")
            print(f"  Display Name: {audio_service['display_name']}")
            print(f"  Binary Path: {audio_service['binary_path']}")
            print(f"  Start Type: {audio_service['start_type']}")
            print(f"  Current State: {audio_service['current_state']}")
            if audio_service['process_id']:
                print(f"  Process ID: {audio_service['process_id']}")
    
    finally:
        manager.close()

# Run the demo
service_management_demo()
```

### Custom Service Creation
```python
import win32service
import win32serviceutil
import win32event
import win32api
import servicemanager
import socket
import time
import threading

class MonitoringService(win32serviceutil.ServiceFramework):
    """Example Windows service for system monitoring"""
    
    _svc_name_ = "PyWin32MonitorService"
    _svc_display_name_ = "PyWin32 System Monitor Service"
    _svc_description_ = "A monitoring service created with pywin32"
    
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        socket.setdefaulttimeout(60)
    
    def SvcStop(self):
        """Stop the service"""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STOPPED,
            (self._svc_name_, '')
        )
    
    def SvcDoRun(self):
        """Main service execution"""
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STARTED,
            (self._svc_name_, '')
        )
        
        # Start monitoring thread
        monitor_thread = threading.Thread(target=self.monitor_system)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        # Wait for stop signal
        win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)
    
    def monitor_system(self):
        """System monitoring loop"""
        while self.is_running:
            try:
                # Get system information
                memory_status = win32api.GlobalMemoryStatus()
                memory_load = memory_status['MemoryLoad']
                
                # Log if memory usage is high
                if memory_load > 80:
                    servicemanager.LogMsg(
                        servicemanager.EVENTLOG_WARNING_TYPE,
                        0xF000,  # Custom event ID
                        (f"High memory usage detected: {memory_load}%", '')
                    )
                
                # Check disk space (simplified)
                try:
                    free_bytes, total_bytes = win32api.GetDiskFreeSpaceEx("C:\\")[:2]
                    disk_usage = ((total_bytes - free_bytes) / total_bytes) * 100
                    
                    if disk_usage > 90:
                        servicemanager.LogMsg(
                            servicemanager.EVENTLOG_WARNING_TYPE,
                            0xF001,
                            (f"Low disk space: {disk_usage:.1f}% used", '')
                        )
                except:
                    pass
                
                # Wait before next check
                time.sleep(60)  # Check every minute
                
            except Exception as e:
                servicemanager.LogMsg(
                    servicemanager.EVENTLOG_ERROR_TYPE,
                    0xF002,
                    (f"Monitor error: {str(e)}", '')
                )
                time.sleep(60)

class ServiceInstaller:
    """Utility to install/remove the monitoring service"""
    
    @staticmethod
    def install_service():
        """Install the monitoring service"""
        try:
            win32serviceutil.InstallService(
                MonitoringService._svc_reg_class_,
                MonitoringService._svc_name_,
                MonitoringService._svc_display_name_,
                description=MonitoringService._svc_description_
            )
            print(f"Service '{MonitoringService._svc_display_name_}' installed successfully")
            return True
        except Exception as e:
            print(f"Error installing service: {e}")
            return False
    
    @staticmethod
    def remove_service():
        """Remove the monitoring service"""
        try:
            win32serviceutil.RemoveService(MonitoringService._svc_name_)
            print(f"Service '{MonitoringService._svc_display_name_}' removed successfully")
            return True
        except Exception as e:
            print(f"Error removing service: {e}")
            return False
    
    @staticmethod
    def start_service():
        """Start the monitoring service"""
        try:
            win32serviceutil.StartService(MonitoringService._svc_name_)
            print(f"Service '{MonitoringService._svc_display_name_}' started")
            return True
        except Exception as e:
            print(f"Error starting service: {e}")
            return False
    
    @staticmethod
    def stop_service():
        """Stop the monitoring service"""
        try:
            win32serviceutil.StopService(MonitoringService._svc_name_)
            print(f"Service '{MonitoringService._svc_display_name_}' stopped")
            return True
        except Exception as e:
            print(f"Error stopping service: {e}")
            return False

# Service management interface
def service_demo():
    """Demonstrate custom service creation and management"""
    print("=== CUSTOM SERVICE DEMO ===")
    print("Note: This requires administrator privileges")
    
    installer = ServiceInstaller()
    
    # Check if service exists
    try:
        service_status = win32serviceutil.QueryServiceStatus(MonitoringService._svc_name_)
        service_exists = True
        print(f"Service already exists with status: {service_status[1]}")
    except:
        service_exists = False
        print("Service does not exist")
    
    if not service_exists:
        print("\nInstalling service...")
        if installer.install_service():
            print("Service installed successfully")
        else:
            print("Failed to install service")
            return
    
    print("\nService management options:")
    print("1. Start service")
    print("2. Stop service") 
    print("3. Remove service")
    print("4. Check status")
    
    # For demo purposes, just show the options
    print("\nNote: Actual service operations require administrator privileges")
    print("To test the service:")
    print("1. Run this script as administrator")
    print("2. Install the service")
    print("3. Start the service")
    print("4. Check Windows Event Viewer for service logs")

# Entry point for service
if __name__ == '__main__':
    if len(sys.argv) == 1:
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(MonitoringService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        win32serviceutil.HandleCommandLine(MonitoringService)
```

## Threading and Synchronization

### Thread Management
```python
import win32api
import win32event
import win32process
import threading
import time
import queue

class ThreadManager:
    """Manage threads and synchronization objects"""
    
    def __init__(self):
        self.threads = {}
        self.events = {}
        self.mutexes = {}
        self.thread_counter = 0
    
    def create_worker_thread(self, target_function, args=None, thread_name=None):
        """Create a worker thread with Windows event synchronization"""
        self.thread_counter += 1
        thread_id = self.thread_counter
        
        if thread_name is None:
            thread_name = f"Worker_{thread_id}"
        
        # Create event for thread control
        stop_event = win32event.CreateEvent(None, True, False, None)
        self.events[thread_id] = stop_event
        
        # Thread wrapper function
        def thread_wrapper():
            try:
                current_thread_id = win32api.GetCurrentThreadId()
                print(f"Thread {thread_name} started (Windows TID: {current_thread_id})")
                
                # Execute target function
                if args:
                    target_function(stop_event, *args)
                else:
                    target_function(stop_event)
                    
            except Exception as e:
                print(f"Thread {thread_name} error: {e}")
            finally:
                print(f"Thread {thread_name} completed")
        
        # Create and start thread
        thread = threading.Thread(target=thread_wrapper, name=thread_name)
        thread.daemon = True
        thread.start()
        
        self.threads[thread_id] = {
            'thread': thread,
            'name': thread_name,
            'stop_event': stop_event,
            'start_time': time.time()
        }
        
        return thread_id
    
    def stop_thread(self, thread_id):
        """Signal thread to stop"""
        if thread_id in self.threads:
            win32event.SetEvent(self.threads[thread_id]['stop_event'])
            return True
        return False
    
    def wait_for_thread(self, thread_id, timeout=None):
        """Wait for thread to complete"""
        if thread_id not in self.threads:
            return False
        
        thread = self.threads[thread_id]['thread']
        thread.join(timeout)
        return not thread.is_alive()
    
    def create_mutex(self, mutex_name):
        """Create a named mutex for process synchronization"""
        try:
            mutex_handle = win32event.CreateMutex(None, False, mutex_name)
            self.mutexes[mutex_name] = mutex_handle
            return mutex_handle
        except Exception as e:
            print(f"Error creating mutex {mutex_name}: {e}")
            return None
    
    def acquire_mutex(self, mutex_name, timeout=5000):
        """Acquire mutex with timeout"""
        if mutex_name not in self.mutexes:
            return False
        
        mutex_handle = self.mutexes[mutex_name]
        result = win32event.WaitForSingleObject(mutex_handle, timeout)
        return result == win32event.WAIT_OBJECT_0
    
    def release_mutex(self, mutex_name):
        """Release mutex"""
        if mutex_name not in self.mutexes:
            return False
        
        try:
            win32event.ReleaseMutex(self.mutexes[mutex_name])
            return True
        except Exception as e:
            print(f"Error releasing mutex {mutex_name}: {e}")
            return False
    
    def cleanup(self):
        """Clean up all threads and synchronization objects"""
        # Stop all threads
        for thread_id in list(self.threads.keys()):
            self.stop_thread(thread_id)
        
        # Wait for threads to finish
        for thread_id, thread_info in self.threads.items():
            thread_info['thread'].join(timeout=5)
        
        # Close events
        for event_handle in self.events.values():
            try:
                win32api.CloseHandle(event_handle)
            except:
                pass
        
        # Close mutexes
        for mutex_handle in self.mutexes.values():
            try:
                win32api.CloseHandle(mutex_handle)
            except:
                pass
        
        self.threads.clear()
        self.events.clear()
        self.mutexes.clear()

# Example worker functions
def system_monitor_worker(stop_event):
    """Example worker that monitors system resources"""
    while True:
        # Check if stop event is signaled
        if win32event.WaitForSingleObject(stop_event, 0) == win32event.WAIT_OBJECT_0:
            break
        
        # Get system information
        memory_status = win32api.GlobalMemoryStatus()
        memory_load = memory_status['MemoryLoad']
        
        print(f"[Monitor] Memory usage: {memory_load}%")
        
        # Sleep for 2 seconds
        time.sleep(2)

def file_processor_worker(stop_event, file_queue):
    """Example worker that processes files from a queue"""
    while True:
        # Check if stop event is signaled
        if win32event.WaitForSingleObject(stop_event, 0) == win32event.WAIT_OBJECT_0:
            break
        
        try:
            # Get file from queue (non-blocking)
            filename = file_queue.get(timeout=1)
            print(f"[Processor] Processing file: {filename}")
            
            # Simulate file processing
            time.sleep(1)
            
            file_queue.task_done()
            
        except queue.Empty:
            continue

# Example usage
def threading_demo():
    """Demonstrate threading and synchronization"""
    manager = ThreadManager()
    
    try:
        print("=== THREADING DEMO ===")
        
        # Create mutex for shared resource
        mutex_name = "PyWin32_Demo_Mutex"
        manager.create_mutex(mutex_name)
        
        # Start system monitor thread
        monitor_thread_id = manager.create_worker_thread(
            system_monitor_worker,
            thread_name="SystemMonitor"
        )
        
        # Create file processing queue and worker
        file_queue = queue.Queue()
        processor_thread_id = manager.create_worker_thread(
            file_processor_worker,
            args=(file_queue,),
            thread_name="FileProcessor"
        )
        
        # Add some files to process
        for i in range(5):
            file_queue.put(f"file_{i}.txt")
        
        print("Threads started. Running for 10 seconds...")
        time.sleep(10)
        
        print("Stopping threads...")
        manager.stop_thread(monitor_thread_id)
        manager.stop_thread(processor_thread_id)
        
        # Wait for threads to finish
        manager.wait_for_thread(monitor_thread_id, timeout=5)
        manager.wait_for_thread(processor_thread_id, timeout=5)
        
        print("All threads stopped")
        
    finally:
        manager.cleanup()

# Run the demo
threading_demo()
```

## Practical Project: Process Monitor and Service Manager

### Complete Implementation
```python
import win32process
import win32service
import win32api
import win32con
import win32event
import time
import json
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime
import threading

class ProcessServiceMonitor:
    """Complete process and service monitoring application"""
    
    def __init__(self):
        self.process_manager = ProcessManager()
        self.service_manager = ServiceManager()
        self.monitoring_active = False
        self.update_interval = 2  # seconds
        
    def get_system_overview(self):
        """Get comprehensive system overview"""
        # Get processes
        processes = self.process_manager.enumerate_processes(include_system=True)
        
        # Get services
        services = self.service_manager.enumerate_services()
        
        # Calculate statistics
        total_processes = len(processes)
        total_memory = sum(p['memory_usage'] for p in processes)
        
        running_services = len([s for s in services if s['current_state'] == 'RUNNING'])
        total_services = len(services)
        
        return {
            'timestamp': datetime.now().isoformat(),
            'processes': {
                'total': total_processes,
                'total_memory_usage': total_memory,
                'top_processes': sorted(processes, key=lambda p: p['memory_usage'], reverse=True)[:10]
            },
            'services': {
                'total': total_services,
                'running': running_services,
                'stopped': total_services - running_services
            },
            'system': {
                'memory_status': win32api.GlobalMemoryStatus(),
                'tick_count': win32api.GetTickCount()
            }
        }
    
    def export_data(self, filename):
        """Export current system data to JSON"""
        try:
            overview = self.get_system_overview()
            with open(filename, 'w') as f:
                json.dump(overview, f, indent=2, default=str)
            return True
        except Exception as e:
            print(f"Error exporting data: {e}")
            return False

class MonitorGUI:
    """GUI for the process and service monitor"""
    
    def __init__(self):
        self.monitor = ProcessServiceMonitor()
        self.root = tk.Tk()
        self.root.title("Process and Service Monitor")
        self.root.geometry("1000x700")
        
        self.setup_gui()
        self.update_timer = None
        
    def setup_gui(self):
        """Setup the GUI layout"""
        # Create notebook for tabs
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Process tab
        process_frame = ttk.Frame(notebook)
        notebook.add(process_frame, text="Processes")
        self.setup_process_tab(process_frame)
        
        # Service tab
        service_frame = ttk.Frame(notebook)
        notebook.add(service_frame, text="Services")
        self.setup_service_tab(service_frame)
        
        # System tab
        system_frame = ttk.Frame(notebook)
        notebook.add(system_frame, text="System Overview")
        self.setup_system_tab(system_frame)
        
        # Control frame
        control_frame = ttk.Frame(self.root)
        control_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.start_button = ttk.Button(control_frame, text="Start Monitoring", command=self.start_monitoring)
        self.start_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = ttk.Button(control_frame, text="Stop Monitoring", command=self.stop_monitoring, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        self.export_button = ttk.Button(control_frame, text="Export Data", command=self.export_data)
        self.export_button.pack(side=tk.LEFT, padx=5)
        
        self.refresh_button = ttk.Button(control_frame, text="Refresh", command=self.refresh_data)
        self.refresh_button.pack(side=tk.LEFT, padx=5)
        
        # Status label
        self.status_label = ttk.Label(control_frame, text="Ready")
        self.status_label.pack(side=tk.RIGHT, padx=5)
    
    def setup_process_tab(self, parent):
        """Setup process monitoring tab"""
        # Process list
        columns = ('PID', 'Name', 'Memory (MB)', 'CPU Time', 'Status')
        self.process_tree = ttk.Treeview(parent, columns=columns, show='headings')
        
        for col in columns:
            self.process_tree.heading(col, text=col)
            self.process_tree.column(col, width=120)
        
        # Scrollbar for process list
        process_scroll = ttk.Scrollbar(parent, orient=tk.VERTICAL, command=self.process_tree.yview)
        self.process_tree.configure(yscrollcommand=process_scroll.set)
        
        # Pack process widgets
        self.process_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        process_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Context menu for processes
        self.process_menu = tk.Menu(self.root, tearoff=0)
        self.process_menu.add_command(label="Terminate Process", command=self.terminate_selected_process)
        self.process_menu.add_command(label="Process Details", command=self.show_process_details)
        
        self.process_tree.bind("<Button-3>", self.show_process_context_menu)
    
    def setup_service_tab(self, parent):
        """Setup service monitoring tab"""
        # Service list
        columns = ('Name', 'Display Name', 'Status', 'Start Type')
        self.service_tree = ttk.Treeview(parent, columns=columns, show='headings')
        
        for col in columns:
            self.service_tree.heading(col, text=col)
            self.service_tree.column(col, width=200)
        
        # Scrollbar for service list
        service_scroll = ttk.Scrollbar(parent, orient=tk.VERTICAL, command=self.service_tree.yview)
        self.service_tree.configure(yscrollcommand=service_scroll.set)
        
        # Pack service widgets
        self.service_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        service_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Context menu for services
        self.service_menu = tk.Menu(self.root, tearoff=0)
        self.service_menu.add_command(label="Start Service", command=self.start_selected_service)
        self.service_menu.add_command(label="Stop Service", command=self.stop_selected_service)
        self.service_menu.add_command(label="Service Details", command=self.show_service_details)
        
        self.service_tree.bind("<Button-3>", self.show_service_context_menu)
    
    def setup_system_tab(self, parent):
        """Setup system overview tab"""
        # System information display
        self.system_text = tk.Text(parent, wrap=tk.WORD, state=tk.DISABLED)
        system_scroll = ttk.Scrollbar(parent, orient=tk.VERTICAL, command=self.system_text.yview)
        self.system_text.configure(yscrollcommand=system_scroll.set)
        
        self.system_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        system_scroll.pack(side=tk.RIGHT, fill=tk.Y)
    
    def start_monitoring(self):
        """Start automatic monitoring"""
        self.monitor.monitoring_active = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.status_label.config(text="Monitoring Active")
        self.schedule_update()
    
    def stop_monitoring(self):
        """Stop automatic monitoring"""
        self.monitor.monitoring_active = False
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.status_label.config(text="Monitoring Stopped")
        
        if self.update_timer:
            self.root.after_cancel(self.update_timer)
    
    def schedule_update(self):
        """Schedule next update"""
        if self.monitor.monitoring_active:
            self.refresh_data()
            self.update_timer = self.root.after(2000, self.schedule_update)  # Update every 2 seconds
    
    def refresh_data(self):
        """Refresh all data"""
        try:
            self.update_process_list()
            self.update_service_list()
            self.update_system_overview()
            self.status_label.config(text=f"Last updated: {datetime.now().strftime('%H:%M:%S')}")
        except Exception as e:
            messagebox.showerror("Error", f"Error refreshing data: {e}")
    
    def update_process_list(self):
        """Update process list"""
        # Clear existing items
        for item in self.process_tree.get_children():
            self.process_tree.delete(item)
        
        # Get processes
        processes = self.monitor.process_manager.enumerate_processes(include_system=True)
        
        # Sort by memory usage
        processes.sort(key=lambda p: p['memory_usage'], reverse=True)
        
        # Add to tree
        for proc in processes:
            memory_mb = proc['memory_usage'] / (1024 * 1024)
            self.process_tree.insert('', tk.END, values=(
                proc['pid'],
                proc['name'],
                f"{memory_mb:.1f}",
                proc['cpu_time'],
                proc['status']
            ))
    
    def update_service_list(self):
        """Update service list"""
        # Clear existing items
        for item in self.service_tree.get_children():
            self.service_tree.delete(item)
        
        # Get services
        services = self.monitor.service_manager.enumerate_services()
        
        # Sort by name
        services.sort(key=lambda s: s['display_name'])
        
        # Add to tree
        for svc in services:
            self.service_tree.insert('', tk.END, values=(
                svc['service_name'],
                svc['display_name'],
                svc['current_state'],
                svc['start_type']
            ))
    
    def update_system_overview(self):
        """Update system overview"""
        overview = self.monitor.get_system_overview()
        
        self.system_text.config(state=tk.NORMAL)
        self.system_text.delete(1.0, tk.END)
        
        # Format overview data
        text = f"System Overview - {overview['timestamp']}\n"
        text += "=" * 50 + "\n\n"
        
        text += f"PROCESSES\n"
        text += f"  Total: {overview['processes']['total']}\n"
        text += f"  Total Memory: {overview['processes']['total_memory_usage'] / (1024*1024):.1f} MB\n\n"
        
        text += f"SERVICES\n"
        text += f"  Total: {overview['services']['total']}\n"
        text += f"  Running: {overview['services']['running']}\n"
        text += f"  Stopped: {overview['services']['stopped']}\n\n"
        
        memory = overview['system']['memory_status']
        text += f"MEMORY\n"
        text += f"  Load: {memory['MemoryLoad']}%\n"
        text += f"  Total Physical: {memory['TotalPhys'] / (1024*1024*1024):.1f} GB\n"
        text += f"  Available Physical: {memory['AvailPhys'] / (1024*1024*1024):.1f} GB\n\n"
        
        text += f"TOP PROCESSES BY MEMORY\n"
        for i, proc in enumerate(overview['processes']['top_processes'][:5]):
            memory_mb = proc['memory_usage'] / (1024 * 1024)
            text += f"  {i+1}. {proc['name']} - {memory_mb:.1f} MB\n"
        
        self.system_text.insert(1.0, text)
        self.system_text.config(state=tk.DISABLED)
    
    def show_process_context_menu(self, event):
        """Show context menu for process"""
        item = self.process_tree.selection()[0] if self.process_tree.selection() else None
        if item:
            self.process_menu.post(event.x_root, event.y_root)
    
    def show_service_context_menu(self, event):
        """Show context menu for service"""
        item = self.service_tree.selection()[0] if self.service_tree.selection() else None
        if item:
            self.service_menu.post(event.x_root, event.y_root)
    
    def terminate_selected_process(self):
        """Terminate selected process"""
        selection = self.process_tree.selection()
        if not selection:
            return
        
        item = selection[0]
        pid = int(self.process_tree.item(item)['values'][0])
        
        if messagebox.askyesno("Confirm", f"Terminate process with PID {pid}?"):
            if self.monitor.process_manager.terminate_process(pid):
                messagebox.showinfo("Success", f"Process {pid} terminated")
                self.refresh_data()
            else:
                messagebox.showerror("Error", f"Failed to terminate process {pid}")
    
    def start_selected_service(self):
        """Start selected service"""
        selection = self.service_tree.selection()
        if not selection:
            return
        
        item = selection[0]
        service_name = self.service_tree.item(item)['values'][0]
        
        if self.monitor.service_manager.start_service(service_name):
            messagebox.showinfo("Success", f"Service {service_name} started")
            self.refresh_data()
        else:
            messagebox.showerror("Error", f"Failed to start service {service_name}")
    
    def stop_selected_service(self):
        """Stop selected service"""
        selection = self.service_tree.selection()
        if not selection:
            return
        
        item = selection[0]
        service_name = self.service_tree.item(item)['values'][0]
        
        if messagebox.askyesno("Confirm", f"Stop service {service_name}?"):
            if self.monitor.service_manager.stop_service(service_name):
                messagebox.showinfo("Success", f"Service {service_name} stopped")
                self.refresh_data()
            else:
                messagebox.showerror("Error", f"Failed to stop service {service_name}")
    
    def export_data(self):
        """Export current data to file"""
        from tkinter import filedialog
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filename:
            if self.monitor.export_data(filename):
                messagebox.showinfo("Success", f"Data exported to {filename}")
            else:
                messagebox.showerror("Error", "Failed to export data")
    
    def run(self):
        """Run the GUI"""
        # Initial data load
        self.refresh_data()
        
        # Start GUI
        self.root.mainloop()
        
        # Cleanup
        self.monitor.service_manager.close()

# Run the application
if __name__ == "__main__":
    try:
        app = MonitorGUI()
        app.run()
    except Exception as e:
        print(f"Application error: {e}")
```

## Exercises

### Exercise 1: Process Resource Monitor
Create a utility that:
- Tracks CPU and memory usage over time
- Detects processes consuming excessive resources
- Provides historical data analysis
- Sends alerts for resource violations

### Exercise 2: Service Dependency Analyzer
Build a tool that:
- Maps service dependencies
- Visualizes dependency chains
- Identifies circular dependencies
- Provides impact analysis for service changes

### Exercise 3: Automated Process Manager
Develop a system that:
- Monitors critical processes
- Restarts failed processes automatically
- Maintains process configuration
- Logs all process events

### Exercise 4: Performance Baseline Tool
Create an application that:
- Establishes system performance baselines
- Detects performance anomalies
- Compares current vs historical performance
- Generates performance reports

## Best Practices

### Process Management
- Always check permissions before process operations
- Handle access denied errors gracefully
- Use appropriate timeouts for process operations
- Clean up process handles properly

### Service Management
- Verify service dependencies before operations
- Handle service startup delays appropriately
- Implement proper error recovery
- Log service operation results

### Threading
- Use Windows synchronization objects properly
- Implement proper thread cleanup
- Handle thread exceptions appropriately
- Avoid resource contention

## Common Pitfalls

### Process Issues
- Insufficient privileges for process access
- Process already terminated
- Process protection by antivirus
- Handle leaks from unclosed processes

### Service Issues
- Service dependencies not met
- Insufficient permissions for service control
- Service timeout during operations
- Service configuration errors

### Threading Problems
- Race conditions in shared resources
- Deadlocks with multiple synchronization objects
- Thread cleanup not performed
- Exception handling in threads

## Next Steps

Excellent work completing Process and Service Management! You now have:
- Advanced process control capabilities
- Comprehensive service management skills
- Understanding of threading and synchronization
- A complete monitoring application

**Next**: Move to [2.3 Registry Operations](./2.3%20Registry%20Operations.md) to learn about Windows registry manipulation and management.

---

**Estimated Time**: 10-14 hours
**Project**: Process monitor and service manager
**Next Module**: [2.3 Registry Operations](./2.3%20Registry%20Operations.md)
