# 5.4 Integration Patterns and Architecture

## Learning Objectives
By the end of this module, you will:
- Master enterprise integration patterns for Windows automation solutions
- Design scalable and maintainable automation architectures
- Implement cross-platform compatibility and deployment strategies
- Develop robust integration solutions for complex enterprise environments
- Apply industry best practices for large-scale automation projects

## Module Overview

This module represents the culmination of your pywin32 journey, focusing on enterprise-level integration patterns and architectural design. You'll learn to create sophisticated automation frameworks that can scale across organizations, integrate with diverse systems, and maintain high standards of reliability and performance.

Enterprise integration requires understanding not just the technical aspects of pywin32, but also broader architectural principles, design patterns, and organizational requirements that drive successful automation initiatives.

## Key Topics

### 1. Enterprise Integration Patterns

#### 1.1 Message-Based Integration

**Event-Driven Architecture Implementation**
```python
import asyncio
import json
import threading
import queue
import time
import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
from typing import Dict, List, Any, Callable, Optional
from enum import Enum

class MessageType(Enum):
    COMMAND = "command"
    EVENT = "event"
    QUERY = "query"
    RESPONSE = "response"

@dataclass
class Message:
    """Standard message format for enterprise integration"""
    id: str
    type: MessageType
    source: str
    destination: str
    payload: Dict[str, Any]
    timestamp: float
    correlation_id: Optional[str] = None
    reply_to: Optional[str] = None
    headers: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        if self.headers is None:
            self.headers = {}
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = time.time()

class MessageBus:
    """Enterprise message bus for decoupled communication"""
    
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.handlers: Dict[str, Callable] = {}
        self.message_queue = asyncio.Queue()
        self.running = False
        self.middleware: List[Callable] = []
        self.dead_letter_queue = queue.Queue()
        
    def subscribe(self, message_type: str, handler: Callable):
        """Subscribe to specific message types"""
        if message_type not in self.subscribers:
            self.subscribers[message_type] = []
        self.subscribers[message_type].append(handler)
    
    def unsubscribe(self, message_type: str, handler: Callable):
        """Unsubscribe from message types"""
        if message_type in self.subscribers:
            self.subscribers[message_type].remove(handler)
    
    def add_middleware(self, middleware: Callable):
        """Add middleware for message processing"""
        self.middleware.append(middleware)
    
    async def publish(self, message: Message):
        """Publish message to the bus"""
        await self.message_queue.put(message)
    
    async def start(self):
        """Start message processing"""
        self.running = True
        await self._process_messages()
    
    def stop(self):
        """Stop message processing"""
        self.running = False
    
    async def _process_messages(self):
        """Process messages from queue"""
        while self.running:
            try:
                message = await asyncio.wait_for(
                    self.message_queue.get(), timeout=1.0
                )
                await self._handle_message(message)
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                print(f"Message processing error: {e}")
    
    async def _handle_message(self, message: Message):
        """Handle individual message"""
        try:
            # Apply middleware
            for middleware in self.middleware:
                message = await middleware(message)
                if message is None:
                    return  # Message filtered out
            
            # Route to subscribers
            message_type = message.type.value
            if message_type in self.subscribers:
                for handler in self.subscribers[message_type]:
                    try:
                        if asyncio.iscoroutinefunction(handler):
                            await handler(message)
                        else:
                            handler(message)
                    except Exception as e:
                        print(f"Handler error for {message_type}: {e}")
                        self.dead_letter_queue.put((message, e))
            
        except Exception as e:
            print(f"Message handling error: {e}")
            self.dead_letter_queue.put((message, e))

class WindowsAutomationService:
    """Windows automation service with message-based integration"""
    
    def __init__(self, service_name: str, message_bus: MessageBus):
        self.service_name = service_name
        self.message_bus = message_bus
        self.request_handlers = {}
        self.setup_handlers()
    
    def setup_handlers(self):
        """Setup message handlers"""
        self.message_bus.subscribe("command", self.handle_command)
        self.message_bus.subscribe("query", self.handle_query)
    
    async def handle_command(self, message: Message):
        """Handle command messages"""
        command = message.payload.get('command')
        if command in self.request_handlers:
            try:
                result = await self.request_handlers[command](message.payload)
                
                # Send response if reply_to is specified
                if message.reply_to:
                    response = Message(
                        id=str(uuid.uuid4()),
                        type=MessageType.RESPONSE,
                        source=self.service_name,
                        destination=message.reply_to,
                        payload={'result': result, 'success': True},
                        correlation_id=message.id
                    )
                    await self.message_bus.publish(response)
                    
            except Exception as e:
                if message.reply_to:
                    error_response = Message(
                        id=str(uuid.uuid4()),
                        type=MessageType.RESPONSE,
                        source=self.service_name,
                        destination=message.reply_to,
                        payload={'error': str(e), 'success': False},
                        correlation_id=message.id
                    )
                    await self.message_bus.publish(error_response)
    
    async def handle_query(self, message: Message):
        """Handle query messages"""
        # Similar to handle_command but for read-only operations
        await self.handle_command(message)
    
    def register_handler(self, command: str, handler: Callable):
        """Register command handler"""
        self.request_handlers[command] = handler

# Example: Excel Automation Service
class ExcelAutomationService(WindowsAutomationService):
    """Excel automation service with enterprise integration"""
    
    def __init__(self, message_bus: MessageBus):
        super().__init__("excel-automation", message_bus)
        self.excel_instances = {}
        
    def setup_handlers(self):
        super().setup_handlers()
        
        # Register Excel-specific handlers
        self.register_handler("create_workbook", self.create_workbook)
        self.register_handler("process_data", self.process_data)
        self.register_handler("generate_report", self.generate_report)
        self.register_handler("close_workbook", self.close_workbook)
    
    async def create_workbook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Create new Excel workbook"""
        try:
            import win32com.client
            
            session_id = payload.get('session_id', str(uuid.uuid4()))
            template_path = payload.get('template_path')
            
            excel = win32com.client.Dispatch('Excel.Application')
            excel.Visible = payload.get('visible', False)
            
            if template_path:
                workbook = excel.Workbooks.Open(template_path)
            else:
                workbook = excel.Workbooks.Add()
            
            self.excel_instances[session_id] = {
                'excel': excel,
                'workbook': workbook,
                'created_at': time.time()
            }
            
            # Publish event
            event = Message(
                id=str(uuid.uuid4()),
                type=MessageType.EVENT,
                source=self.service_name,
                destination="*",
                payload={
                    'event': 'workbook_created',
                    'session_id': session_id,
                    'workbook_name': workbook.Name
                }
            )
            await self.message_bus.publish(event)
            
            return {
                'session_id': session_id,
                'workbook_name': workbook.Name,
                'status': 'created'
            }
            
        except Exception as e:
            raise Exception(f"Failed to create workbook: {e}")
    
    async def process_data(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Process data in Excel workbook"""
        session_id = payload.get('session_id')
        data = payload.get('data', [])
        worksheet_name = payload.get('worksheet', 'Sheet1')
        start_cell = payload.get('start_cell', 'A1')
        
        if session_id not in self.excel_instances:
            raise Exception(f"Invalid session: {session_id}")
        
        try:
            workbook = self.excel_instances[session_id]['workbook']
            
            # Get or create worksheet
            try:
                worksheet = workbook.Worksheets(worksheet_name)
            except:
                worksheet = workbook.Worksheets.Add()
                worksheet.Name = worksheet_name
            
            # Process data efficiently
            if data:
                # Convert start_cell to row, column
                import re
                match = re.match(r'([A-Z]+)(\d+)', start_cell.upper())
                if match:
                    col_str, row_str = match.groups()
                    row = int(row_str)
                    col = sum((ord(c) - ord('A') + 1) * (26 ** i) 
                             for i, c in enumerate(reversed(col_str)))
                    
                    # Set data range
                    if isinstance(data[0], list):
                        # 2D data
                        end_row = row + len(data) - 1
                        end_col = col + len(data[0]) - 1
                        range_addr = f"{start_cell}:{self._col_num_to_letter(end_col)}{end_row}"
                        worksheet.Range(range_addr).Value = data
                    else:
                        # 1D data
                        for i, value in enumerate(data):
                            worksheet.Cells(row + i, col).Value = value
            
            # Publish processing event
            event = Message(
                id=str(uuid.uuid4()),
                type=MessageType.EVENT,
                source=self.service_name,
                destination="*",
                payload={
                    'event': 'data_processed',
                    'session_id': session_id,
                    'worksheet': worksheet_name,
                    'records_processed': len(data)
                }
            )
            await self.message_bus.publish(event)
            
            return {
                'session_id': session_id,
                'records_processed': len(data),
                'status': 'completed'
            }
            
        except Exception as e:
            raise Exception(f"Data processing failed: {e}")
    
    def _col_num_to_letter(self, col_num):
        """Convert column number to letter"""
        result = ""
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + ord('A')) + result
            col_num //= 26
        return result

# Enterprise Integration Manager
class EnterpriseIntegrationManager:
    """Manages enterprise-wide automation integration"""
    
    def __init__(self):
        self.message_bus = MessageBus()
        self.services = {}
        self.config = {}
        self.health_monitor = None
        
    async def initialize(self, config_path: str):
        """Initialize integration manager"""
        self.config = await self._load_config(config_path)
        
        # Initialize services
        await self._initialize_services()
        
        # Setup middleware
        self._setup_middleware()
        
        # Start health monitoring
        self._start_health_monitoring()
        
        # Start message bus
        await self.message_bus.start()
    
    async def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load configuration from file"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Failed to load config: {e}")
            return {}
    
    async def _initialize_services(self):
        """Initialize automation services"""
        service_configs = self.config.get('services', {})
        
        for service_name, service_config in service_configs.items():
            service_type = service_config.get('type')
            
            if service_type == 'excel':
                service = ExcelAutomationService(self.message_bus)
                self.services[service_name] = service
            # Add other service types as needed
    
    def _setup_middleware(self):
        """Setup message bus middleware"""
        # Logging middleware
        async def logging_middleware(message: Message) -> Message:
            print(f"Message: {message.type.value} from {message.source} to {message.destination}")
            return message
        
        # Authentication middleware
        async def auth_middleware(message: Message) -> Message:
            # Implement authentication logic
            return message
        
        # Rate limiting middleware
        async def rate_limit_middleware(message: Message) -> Message:
            # Implement rate limiting logic
            return message
        
        self.message_bus.add_middleware(logging_middleware)
        self.message_bus.add_middleware(auth_middleware)
        self.message_bus.add_middleware(rate_limit_middleware)
    
    def _start_health_monitoring(self):
        """Start health monitoring for services"""
        def health_check_worker():
            while True:
                for service_name, service in self.services.items():
                    try:
                        # Implement health check logic
                        health_status = self._check_service_health(service)
                        if not health_status['healthy']:
                            print(f"Service {service_name} is unhealthy: {health_status['reason']}")
                    except Exception as e:
                        print(f"Health check failed for {service_name}: {e}")
                
                time.sleep(30)  # Check every 30 seconds
        
        self.health_monitor = threading.Thread(target=health_check_worker, daemon=True)
        self.health_monitor.start()
    
    def _check_service_health(self, service) -> Dict[str, Any]:
        """Check health of individual service"""
        # Implement health check logic
        return {'healthy': True, 'reason': ''}

# Example usage
async def enterprise_integration_example():
    """Example of enterprise integration setup"""
    
    # Create integration manager
    manager = EnterpriseIntegrationManager()
    
    # Initialize with configuration
    config = {
        'services': {
            'excel-service': {
                'type': 'excel',
                'max_instances': 5,
                'timeout': 300
            }
        },
        'middleware': {
            'logging': True,
            'authentication': True,
            'rate_limiting': {'max_requests_per_minute': 100}
        }
    }
    
    # Save config temporarily
    with open('integration_config.json', 'w') as f:
        json.dump(config, f)
    
    try:
        await manager.initialize('integration_config.json')
        
        # Example: Create workbook via message bus
        command = Message(
            id=str(uuid.uuid4()),
            type=MessageType.COMMAND,
            source="client-app",
            destination="excel-automation",
            payload={
                'command': 'create_workbook',
                'session_id': 'demo-session',
                'visible': False
            },
            reply_to="client-app"
        )
        
        await manager.message_bus.publish(command)
        
        # Wait a bit for processing
        await asyncio.sleep(2)
        
        # Process some data
        data_command = Message(
            id=str(uuid.uuid4()),
            type=MessageType.COMMAND,
            source="client-app",
            destination="excel-automation",
            payload={
                'command': 'process_data',
                'session_id': 'demo-session',
                'data': [
                    ['Name', 'Age', 'City'],
                    ['John', 30, 'New York'],
                    ['Jane', 25, 'Los Angeles'],
                    ['Bob', 35, 'Chicago']
                ],
                'start_cell': 'A1'
            }
        )
        
        await manager.message_bus.publish(data_command)
        
    except Exception as e:
        print(f"Integration example failed: {e}")
    finally:
        manager.message_bus.stop()
```

#### 1.2 Service-Oriented Architecture (SOA)

**Microservices Architecture for Windows Automation**
```python
import json
import asyncio
import aiohttp
from aiohttp import web, ClientSession
from dataclasses import dataclass, asdict
from typing import Dict, List, Any, Optional
import logging
import uuid
import time

@dataclass
class ServiceDefinition:
    """Service definition for registry"""
    name: str
    version: str
    host: str
    port: int
    endpoints: List[str]
    health_check_url: str
    metadata: Dict[str, Any]

class ServiceRegistry:
    """Central service registry for microservices"""
    
    def __init__(self):
        self.services: Dict[str, ServiceDefinition] = {}
        self.service_instances: Dict[str, List[ServiceDefinition]] = {}
        
    def register_service(self, service: ServiceDefinition) -> bool:
        """Register a service"""
        service_key = f"{service.name}:{service.version}"
        self.services[service_key] = service
        
        if service.name not in self.service_instances:
            self.service_instances[service.name] = []
        
        # Remove existing instance if present
        self.service_instances[service.name] = [
            s for s in self.service_instances[service.name] 
            if not (s.host == service.host and s.port == service.port)
        ]
        
        self.service_instances[service.name].append(service)
        return True
    
    def unregister_service(self, service_name: str, host: str, port: int) -> bool:
        """Unregister a service"""
        if service_name in self.service_instances:
            self.service_instances[service_name] = [
                s for s in self.service_instances[service_name]
                if not (s.host == host and s.port == port)
            ]
            return True
        return False
    
    def discover_service(self, service_name: str) -> Optional[ServiceDefinition]:
        """Discover available service instance"""
        instances = self.service_instances.get(service_name, [])
        if instances:
            # Simple round-robin for now
            return instances[0]
        return None
    
    def get_all_services(self) -> List[ServiceDefinition]:
        """Get all registered services"""
        all_services = []
        for instances in self.service_instances.values():
            all_services.extend(instances)
        return all_services

class AutomationMicroservice:
    """Base class for automation microservices"""
    
    def __init__(self, name: str, version: str, port: int):
        self.name = name
        self.version = version
        self.port = port
        self.app = web.Application()
        self.registry_url = None
        self.service_definition = None
        self.setup_routes()
        
    def setup_routes(self):
        """Setup HTTP routes"""
        self.app.router.add_get('/health', self.health_check)
        self.app.router.add_get('/info', self.service_info)
        self.app.router.add_post('/shutdown', self.shutdown)
        
    async def health_check(self, request):
        """Health check endpoint"""
        return web.json_response({
            'status': 'healthy',
            'timestamp': time.time(),
            'service': self.name,
            'version': self.version
        })
    
    async def service_info(self, request):
        """Service information endpoint"""
        return web.json_response({
            'name': self.name,
            'version': self.version,
            'port': self.port,
            'endpoints': [str(route.resource) for route in self.app.router.routes()],
            'uptime': time.time() - self.start_time if hasattr(self, 'start_time') else 0
        })
    
    async def shutdown(self, request):
        """Shutdown endpoint"""
        await self.unregister_from_registry()
        return web.json_response({'status': 'shutting down'})
    
    async def start(self, registry_url: str = None):
        """Start the microservice"""
        self.start_time = time.time()
        self.registry_url = registry_url
        
        if registry_url:
            await self.register_with_registry()
        
        runner = web.AppRunner(self.app)
        await runner.setup()
        site = web.TCPSite(runner, 'localhost', self.port)
        await site.start()
        
        logging.info(f"Service {self.name} started on port {self.port}")
    
    async def register_with_registry(self):
        """Register service with registry"""
        if not self.registry_url:
            return
        
        self.service_definition = ServiceDefinition(
            name=self.name,
            version=self.version,
            host='localhost',
            port=self.port,
            endpoints=[str(route.resource) for route in self.app.router.routes()],
            health_check_url=f'http://localhost:{self.port}/health',
            metadata={'started_at': self.start_time}
        )
        
        try:
            async with ClientSession() as session:
                async with session.post(
                    f'{self.registry_url}/register',
                    json=asdict(self.service_definition)
                ) as response:
                    if response.status == 200:
                        logging.info(f"Service {self.name} registered with registry")
                    else:
                        logging.error(f"Failed to register service: {response.status}")
        except Exception as e:
            logging.error(f"Registry registration failed: {e}")
    
    async def unregister_from_registry(self):
        """Unregister service from registry"""
        if not self.registry_url or not self.service_definition:
            return
        
        try:
            async with ClientSession() as session:
                async with session.post(
                    f'{self.registry_url}/unregister',
                    json={
                        'service_name': self.name,
                        'host': self.service_definition.host,
                        'port': self.service_definition.port
                    }
                ) as response:
                    if response.status == 200:
                        logging.info(f"Service {self.name} unregistered from registry")
        except Exception as e:
            logging.error(f"Registry unregistration failed: {e}")

class ExcelMicroservice(AutomationMicroservice):
    """Excel automation microservice"""
    
    def __init__(self, port: int = 8001):
        super().__init__("excel-service", "1.0.0", port)
        self.excel_sessions = {}
        
    def setup_routes(self):
        super().setup_routes()
        self.app.router.add_post('/excel/create', self.create_workbook)
        self.app.router.add_post('/excel/data', self.process_data)
        self.app.router.add_post('/excel/save', self.save_workbook)
        self.app.router.add_post('/excel/close', self.close_workbook)
        self.app.router.add_get('/excel/sessions', self.list_sessions)
    
    async def create_workbook(self, request):
        """Create Excel workbook endpoint"""
        try:
            data = await request.json()
            session_id = data.get('session_id', str(uuid.uuid4()))
            template_path = data.get('template_path')
            visible = data.get('visible', False)
            
            # Import here to avoid issues if Excel is not available
            import win32com.client
            
            excel = win32com.client.Dispatch('Excel.Application')
            excel.Visible = visible
            
            if template_path:
                workbook = excel.Workbooks.Open(template_path)
            else:
                workbook = excel.Workbooks.Add()
            
            self.excel_sessions[session_id] = {
                'excel': excel,
                'workbook': workbook,
                'created_at': time.time()
            }
            
            return web.json_response({
                'session_id': session_id,
                'workbook_name': workbook.Name,
                'status': 'created'
            })
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'status': 'failed'
            }, status=500)
    
    async def process_data(self, request):
        """Process data endpoint"""
        try:
            data = await request.json()
            session_id = data.get('session_id')
            worksheet_data = data.get('data', [])
            worksheet_name = data.get('worksheet', 'Sheet1')
            start_cell = data.get('start_cell', 'A1')
            
            if session_id not in self.excel_sessions:
                return web.json_response({
                    'error': 'Invalid session',
                    'status': 'failed'
                }, status=400)
            
            session = self.excel_sessions[session_id]
            workbook = session['workbook']
            
            # Get or create worksheet
            try:
                worksheet = workbook.Worksheets(worksheet_name)
            except:
                worksheet = workbook.Worksheets.Add()
                worksheet.Name = worksheet_name
            
            # Process data
            if worksheet_data:
                if isinstance(worksheet_data[0], list):
                    # 2D data
                    rows, cols = len(worksheet_data), len(worksheet_data[0])
                    range_addr = f"{start_cell}:{self._get_cell_address(start_cell, rows-1, cols-1)}"
                    worksheet.Range(range_addr).Value = worksheet_data
                else:
                    # 1D data
                    for i, value in enumerate(worksheet_data):
                        row, col = self._parse_cell_address(start_cell)
                        worksheet.Cells(row + i, col).Value = value
            
            return web.json_response({
                'session_id': session_id,
                'records_processed': len(worksheet_data),
                'status': 'completed'
            })
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'status': 'failed'
            }, status=500)
    
    async def save_workbook(self, request):
        """Save workbook endpoint"""
        try:
            data = await request.json()
            session_id = data.get('session_id')
            file_path = data.get('file_path')
            
            if session_id not in self.excel_sessions:
                return web.json_response({
                    'error': 'Invalid session',
                    'status': 'failed'
                }, status=400)
            
            workbook = self.excel_sessions[session_id]['workbook']
            
            if file_path:
                workbook.SaveAs(file_path)
            else:
                workbook.Save()
            
            return web.json_response({
                'session_id': session_id,
                'file_path': file_path or workbook.FullName,
                'status': 'saved'
            })
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'status': 'failed'
            }, status=500)
    
    async def close_workbook(self, request):
        """Close workbook endpoint"""
        try:
            data = await request.json()
            session_id = data.get('session_id')
            save_changes = data.get('save_changes', False)
            
            if session_id not in self.excel_sessions:
                return web.json_response({
                    'error': 'Invalid session',
                    'status': 'failed'
                }, status=400)
            
            session = self.excel_sessions[session_id]
            workbook = session['workbook']
            excel = session['excel']
            
            workbook.Close(SaveChanges=save_changes)
            excel.Quit()
            
            del self.excel_sessions[session_id]
            
            return web.json_response({
                'session_id': session_id,
                'status': 'closed'
            })
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'status': 'failed'
            }, status=500)
    
    async def list_sessions(self, request):
        """List active sessions endpoint"""
        sessions = []
        for session_id, session_data in self.excel_sessions.items():
            sessions.append({
                'session_id': session_id,
                'workbook_name': session_data['workbook'].Name,
                'created_at': session_data['created_at'],
                'duration': time.time() - session_data['created_at']
            })
        
        return web.json_response({'sessions': sessions})
    
    def _parse_cell_address(self, cell_address):
        """Parse cell address to row, column numbers"""
        import re
        match = re.match(r'([A-Z]+)(\d+)', cell_address.upper())
        if match:
            col_str, row_str = match.groups()
            row = int(row_str)
            col = sum((ord(c) - ord('A') + 1) * (26 ** i) 
                     for i, c in enumerate(reversed(col_str)))
            return row, col
        return 1, 1
    
    def _get_cell_address(self, start_cell, row_offset, col_offset):
        """Get cell address with offsets"""
        start_row, start_col = self._parse_cell_address(start_cell)
        end_row = start_row + row_offset
        end_col = start_col + col_offset
        end_col_str = self._col_num_to_letter(end_col)
        return f"{end_col_str}{end_row}"
    
    def _col_num_to_letter(self, col_num):
        """Convert column number to letter"""
        result = ""
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + ord('A')) + result
            col_num //= 26
        return result

class RegistryService(AutomationMicroservice):
    """Service registry microservice"""
    
    def __init__(self, port: int = 8000):
        super().__init__("registry-service", "1.0.0", port)
        self.registry = ServiceRegistry()
    
    def setup_routes(self):
        super().setup_routes()
        self.app.router.add_post('/register', self.register_service)
        self.app.router.add_post('/unregister', self.unregister_service)
        self.app.router.add_get('/discover/{service_name}', self.discover_service)
        self.app.router.add_get('/services', self.list_services)
    
    async def register_service(self, request):
        """Register service endpoint"""
        try:
            data = await request.json()
            service = ServiceDefinition(**data)
            success = self.registry.register_service(service)
            
            return web.json_response({
                'success': success,
                'service': data
            })
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'success': False
            }, status=400)
    
    async def unregister_service(self, request):
        """Unregister service endpoint"""
        try:
            data = await request.json()
            service_name = data['service_name']
            host = data['host']
            port = data['port']
            
            success = self.registry.unregister_service(service_name, host, port)
            
            return web.json_response({'success': success})
            
        except Exception as e:
            return web.json_response({
                'error': str(e),
                'success': False
            }, status=400)
    
    async def discover_service(self, request):
        """Discover service endpoint"""
        service_name = request.match_info['service_name']
        service = self.registry.discover_service(service_name)
        
        if service:
            return web.json_response(asdict(service))
        else:
            return web.json_response({
                'error': 'Service not found'
            }, status=404)
    
    async def list_services(self, request):
        """List all services endpoint"""
        services = self.registry.get_all_services()
        return web.json_response({
            'services': [asdict(service) for service in services]
        })
```

### 2. Cross-Platform Compatibility

#### 2.1 Abstraction Layers

**Platform Abstraction Framework**
```python
import os
import sys
import platform
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass

@dataclass
class PlatformInfo:
    """Platform information structure"""
    system: str  # Windows, Linux, Darwin
    version: str
    architecture: str
    python_version: str
    supports_windows_api: bool
    supports_com: bool

class PlatformAbstraction(ABC):
    """Abstract base for platform-specific implementations"""
    
    @abstractmethod
    def get_platform_info(self) -> PlatformInfo:
        """Get platform information"""
        pass
    
    @abstractmethod
    def execute_office_automation(self, app_name: str, operation: str, **kwargs) -> Any:
        """Execute office automation"""
        pass
    
    @abstractmethod
    def get_system_processes(self) -> List[Dict[str, Any]]:
        """Get system process information"""
        pass
    
    @abstractmethod
    def manage_windows_service(self, service_name: str, action: str) -> bool:
        """Manage system services"""
        pass

class WindowsPlatform(PlatformAbstraction):
    """Windows-specific implementation"""
    
    def __init__(self):
        self.com_available = self._check_com_availability()
        self.win32_available = self._check_win32_availability()
    
    def _check_com_availability(self) -> bool:
        """Check if COM is available"""
        try:
            import win32com.client
            return True
        except ImportError:
            return False
    
    def _check_win32_availability(self) -> bool:
        """Check if pywin32 is available"""
        try:
            import win32api
            return True
        except ImportError:
            return False
    
    def get_platform_info(self) -> PlatformInfo:
        """Get Windows platform information"""
        return PlatformInfo(
            system="Windows",
            version=platform.version(),
            architecture=platform.architecture()[0],
            python_version=sys.version,
            supports_windows_api=self.win32_available,
            supports_com=self.com_available
        )
    
    def execute_office_automation(self, app_name: str, operation: str, **kwargs) -> Any:
        """Execute Office automation on Windows"""
        if not self.com_available:
            raise NotImplementedError("COM not available on this system")
        
        import win32com.client
        
        try:
            if app_name.lower() == 'excel':
                return self._excel_automation(operation, **kwargs)
            elif app_name.lower() == 'word':
                return self._word_automation(operation, **kwargs)
            elif app_name.lower() == 'powerpoint':
                return self._powerpoint_automation(operation, **kwargs)
            else:
                raise ValueError(f"Unsupported application: {app_name}")
                
        except Exception as e:
            raise RuntimeError(f"Office automation failed: {e}")
    
    def _excel_automation(self, operation: str, **kwargs) -> Any:
        """Excel-specific automation"""
        import win32com.client
        
        if operation == 'create_workbook':
            excel = win32com.client.Dispatch('Excel.Application')
            excel.Visible = kwargs.get('visible', False)
            workbook = excel.Workbooks.Add()
            return {'excel': excel, 'workbook': workbook}
        
        elif operation == 'process_data':
            excel_obj = kwargs.get('excel_object')
            data = kwargs.get('data', [])
            worksheet = kwargs.get('worksheet', 'Sheet1')
            
            if excel_obj and 'workbook' in excel_obj:
                ws = excel_obj['workbook'].Worksheets(worksheet)
                if data:
                    ws.Range("A1").Resize(len(data), len(data[0])).Value = data
                return True
        
        return None
    
    def _word_automation(self, operation: str, **kwargs) -> Any:
        """Word-specific automation"""
        import win32com.client
        
        if operation == 'create_document':
            word = win32com.client.Dispatch('Word.Application')
            word.Visible = kwargs.get('visible', False)
            document = word.Documents.Add()
            return {'word': word, 'document': document}
        
        return None
    
    def _powerpoint_automation(self, operation: str, **kwargs) -> Any:
        """PowerPoint-specific automation"""
        import win32com.client
        
        if operation == 'create_presentation':
            ppt = win32com.client.Dispatch('PowerPoint.Application')
            ppt.Visible = kwargs.get('visible', True)
            presentation = ppt.Presentations.Add()
            return {'powerpoint': ppt, 'presentation': presentation}
        
        return None
    
    def get_system_processes(self) -> List[Dict[str, Any]]:
        """Get Windows system processes"""
        if not self.win32_available:
            raise NotImplementedError("Win32 API not available")
        
        import win32process
        import win32con
        import win32api
        
        processes = []
        try:
            # Use psutil if available for more detailed info
            import psutil
            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
                try:
                    processes.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'memory': proc.info['memory_info'].rss,
                        'cpu_percent': proc.info['cpu_percent']
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        except ImportError:
            # Fallback to basic win32 API
            import win32pdh
            processes = [{'pid': 0, 'name': 'Basic process info only', 'memory': 0, 'cpu_percent': 0}]
        
        return processes
    
    def manage_windows_service(self, service_name: str, action: str) -> bool:
        """Manage Windows services"""
        if not self.win32_available:
            raise NotImplementedError("Win32 API not available")
        
        import win32service
        import win32serviceutil
        
        try:
            if action == 'start':
                win32serviceutil.StartService(service_name)
                return True
            elif action == 'stop':
                win32serviceutil.StopService(service_name)
                return True
            elif action == 'status':
                status = win32serviceutil.QueryServiceStatus(service_name)
                return status[1] == win32service.SERVICE_RUNNING
            else:
                return False
        except Exception:
            return False

class LinuxPlatform(PlatformAbstraction):
    """Linux-specific implementation"""
    
    def get_platform_info(self) -> PlatformInfo:
        """Get Linux platform information"""
        return PlatformInfo(
            system="Linux",
            version=platform.version(),
            architecture=platform.architecture()[0],
            python_version=sys.version,
            supports_windows_api=False,
            supports_com=False
        )
    
    def execute_office_automation(self, app_name: str, operation: str, **kwargs) -> Any:
        """Execute office automation on Linux"""
        # Use LibreOffice via uno bridge or other methods
        if operation == 'create_workbook':
            return self._libreoffice_calc_automation(**kwargs)
        
        raise NotImplementedError("Office automation not fully implemented on Linux")
    
    def _libreoffice_calc_automation(self, **kwargs):
        """LibreOffice Calc automation"""
        try:
            import uno
            from com.sun.star.beans import PropertyValue
            
            # Connect to LibreOffice
            localContext = uno.getComponentContext()
            resolver = localContext.ServiceManager.createInstanceWithContext(
                "com.sun.star.bridge.UnoUrlResolver", localContext)
            
            # This is a simplified example
            return {'type': 'libreoffice_calc', 'status': 'created'}
            
        except ImportError:
            raise NotImplementedError("LibreOffice UNO bridge not available")
    
    def get_system_processes(self) -> List[Dict[str, Any]]:
        """Get Linux system processes"""
        try:
            import psutil
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
                try:
                    processes.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'memory': proc.info['memory_info'].rss,
                        'cpu_percent': proc.info['cpu_percent']
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return processes
        except ImportError:
            raise NotImplementedError("Process information requires psutil")
    
    def manage_windows_service(self, service_name: str, action: str) -> bool:
        """Manage Linux services (systemd)"""
        import subprocess
        
        try:
            if action == 'start':
                result = subprocess.run(['systemctl', 'start', service_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
            elif action == 'stop':
                result = subprocess.run(['systemctl', 'stop', service_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
            elif action == 'status':
                result = subprocess.run(['systemctl', 'is-active', service_name], 
                                      capture_output=True, text=True)
                return result.stdout.strip() == 'active'
            else:
                return False
        except Exception:
            return False

class MacOSPlatform(PlatformAbstraction):
    """macOS-specific implementation"""
    
    def get_platform_info(self) -> PlatformInfo:
        """Get macOS platform information"""
        return PlatformInfo(
            system="Darwin",
            version=platform.version(),
            architecture=platform.architecture()[0],
            python_version=sys.version,
            supports_windows_api=False,
            supports_com=False
        )
    
    def execute_office_automation(self, app_name: str, operation: str, **kwargs) -> Any:
        """Execute office automation on macOS"""
        # Use AppleScript or Office for Mac APIs
        if app_name.lower() == 'excel' and operation == 'create_workbook':
            return self._excel_mac_automation(**kwargs)
        
        raise NotImplementedError("Office automation not fully implemented on macOS")
    
    def _excel_mac_automation(self, **kwargs):
        """Excel for Mac automation using AppleScript"""
        import subprocess
        
        applescript = '''
        tell application "Microsoft Excel"
            make new workbook
            return name of active workbook
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', applescript], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return {'workbook_name': result.stdout.strip()}
            else:
                raise RuntimeError(f"AppleScript error: {result.stderr}")
        except Exception as e:
            raise RuntimeError(f"macOS automation failed: {e}")
    
    def get_system_processes(self) -> List[Dict[str, Any]]:
        """Get macOS system processes"""
        try:
            import psutil
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
                try:
                    processes.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'memory': proc.info['memory_info'].rss,
                        'cpu_percent': proc.info['cpu_percent']
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return processes
        except ImportError:
            raise NotImplementedError("Process information requires psutil")
    
    def manage_windows_service(self, service_name: str, action: str) -> bool:
        """Manage macOS services (launchd)"""
        import subprocess
        
        try:
            if action == 'start':
                result = subprocess.run(['launchctl', 'start', service_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
            elif action == 'stop':
                result = subprocess.run(['launchctl', 'stop', service_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
            elif action == 'status':
                result = subprocess.run(['launchctl', 'list', service_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
            else:
                return False
        except Exception:
            return False

class CrossPlatformAutomationFramework:
    """Cross-platform automation framework"""
    
    def __init__(self):
        self.platform = self._detect_platform()
        self.capabilities = self.platform.get_platform_info()
    
    def _detect_platform(self) -> PlatformAbstraction:
        """Detect and return appropriate platform implementation"""
        system = platform.system()
        
        if system == "Windows":
            return WindowsPlatform()
        elif system == "Linux":
            return LinuxPlatform()
        elif system == "Darwin":
            return MacOSPlatform()
        else:
            raise NotImplementedError(f"Platform {system} not supported")
    
    def get_capabilities(self) -> PlatformInfo:
        """Get platform capabilities"""
        return self.capabilities
    
    def execute_automation(self, app_name: str, operation: str, **kwargs) -> Any:
        """Execute automation task on current platform"""
        return self.platform.execute_office_automation(app_name, operation, **kwargs)
    
    def get_processes(self) -> List[Dict[str, Any]]:
        """Get system process information"""
        return self.platform.get_system_processes()
    
    def manage_service(self, service_name: str, action: str) -> bool:
        """Manage system service"""
        return self.platform.manage_windows_service(service_name, action)
    
    def is_feature_supported(self, feature: str) -> bool:
        """Check if specific feature is supported on current platform"""
        feature_map = {
            'windows_api': self.capabilities.supports_windows_api,
            'com_automation': self.capabilities.supports_com,
            'office_automation': True,  # Supported on all platforms with different implementations
            'process_management': True,
            'service_management': True
        }
        
        return feature_map.get(feature, False)

# Example usage
def cross_platform_automation_example():
    """Example of cross-platform automation"""
    
    # Create framework instance
    framework = CrossPlatformAutomationFramework()
    
    # Get platform information
    capabilities = framework.get_capabilities()
    print(f"Running on: {capabilities.system} {capabilities.version}")
    print(f"Windows API support: {capabilities.supports_windows_api}")
    print(f"COM support: {capabilities.supports_com}")
    
    # Check feature support
    if framework.is_feature_supported('office_automation'):
        try:
            # Execute Excel automation
            result = framework.execute_automation('excel', 'create_workbook', visible=False)
            print(f"Excel automation result: {result}")
        except Exception as e:
            print(f"Excel automation failed: {e}")
    else:
        print("Office automation not supported on this platform")
    
    # Get system processes
    try:
        processes = framework.get_processes()
        print(f"Found {len(processes)} processes")
        # Show first 5 processes
        for proc in processes[:5]:
            print(f"  PID: {proc['pid']}, Name: {proc['name']}")
    except Exception as e:
        print(f"Process enumeration failed: {e}")
```

## Practical Exercises

### Exercise 1: Enterprise Message Bus Implementation
Create a comprehensive message bus system for enterprise automation.

**Requirements:**
- Implement publish-subscribe pattern with topic filtering
- Add message persistence and replay capabilities
- Include dead letter queue for failed messages
- Support multiple transport mechanisms (HTTP, TCP, file-based)
- Implement message transformation and routing rules

### Exercise 2: Microservices Orchestration Platform
Build a platform for orchestrating automation microservices.

**Requirements:**
- Service discovery and registration
- Load balancing and failover mechanisms
- Configuration management
- Health monitoring and alerting
- API gateway with authentication and rate limiting

### Exercise 3: Cross-Platform Automation Framework
Develop a framework that provides consistent automation APIs across platforms.

**Requirements:**
- Abstract common automation operations
- Platform-specific implementations for Windows, Linux, and macOS
- Feature detection and capability reporting
- Graceful degradation for unsupported features
- Comprehensive testing on multiple platforms

### Exercise 4: Enterprise Integration Hub
Create a central hub for integrating multiple automation systems.

**Requirements:**
- Support for multiple communication protocols
- Data transformation and mapping capabilities
- Workflow orchestration engine
- Monitoring and analytics dashboard
- Plugin architecture for custom integrations

## Best Practices

### 1. Architecture Design

**Scalability Principles**
- Design for horizontal scaling from the beginning
- Use stateless services where possible
- Implement proper caching strategies
- Plan for data partitioning and sharding
- Consider eventual consistency models

**Reliability Patterns**
- Implement circuit breakers for external dependencies
- Use retry mechanisms with exponential backoff
- Design for graceful degradation
- Implement comprehensive health checks
- Plan for disaster recovery scenarios

### 2. Integration Patterns

**Loose Coupling**
- Use message-based communication
- Implement proper abstraction layers
- Avoid tight dependencies between services
- Use configuration for runtime behavior
- Design for pluggable components

**Data Consistency**
- Implement proper transaction boundaries
- Use event sourcing for audit trails
- Consider eventual consistency trade-offs
- Implement compensation patterns
- Design for data reconciliation

### 3. Security and Compliance

**Security by Design**
- Implement defense in depth
- Use principle of least privilege
- Encrypt data in transit and at rest
- Implement proper authentication and authorization
- Regular security audits and updates

**Compliance Considerations**
- Implement audit trails for all operations
- Consider data residency requirements
- Implement data retention policies
- Plan for regulatory reporting
- Design for privacy by design

## Common Pitfalls

### 1. Over-Engineering
- **Problem**: Creating overly complex architectures
- **Solution**: Start simple and evolve based on actual requirements

### 2. Ignoring Non-Functional Requirements
- **Problem**: Focusing only on functional requirements
- **Solution**: Consider performance, scalability, security from the start

### 3. Tight Coupling
- **Problem**: Creating dependencies that make changes difficult
- **Solution**: Use proper abstraction and interface design

### 4. Inadequate Error Handling
- **Problem**: Not handling errors properly in distributed systems
- **Solution**: Implement comprehensive error handling and recovery

### 5. Security Afterthought
- **Problem**: Adding security as an afterthought
- **Solution**: Build security into the architecture from the beginning

## Capstone Project: Enterprise Automation Framework

Create a comprehensive enterprise automation framework that demonstrates all concepts learned throughout the course.

### Project Requirements

**Architecture Components:**
- Microservices-based architecture with service discovery
- Message bus for inter-service communication
- Cross-platform compatibility layer
- Configuration management system
- Monitoring and observability platform
- Security and authentication framework

**Automation Capabilities:**
- Office application automation (Excel, Word, PowerPoint)
- System administration and monitoring
- File system operations and monitoring
- Network operations and communication
- Database integration and operations
- Custom workflow orchestration

**Enterprise Features:**
- Multi-tenant support with isolation
- Role-based access control
- Comprehensive audit logging
- Performance monitoring and alerting
- Automated deployment and scaling
- Business intelligence and reporting

**Technical Requirements:**
- Support for Windows, Linux, and macOS
- RESTful APIs with comprehensive documentation
- Web-based management interface
- Command-line tools for administration
- Plugin architecture for extensibility
- Comprehensive test suite with CI/CD integration

### Implementation Phases

1. **Phase 1: Core Architecture (Weeks 1-2)**
   - Design overall system architecture
   - Implement core services (registry, message bus, config)
   - Create basic web interface
   - Establish development and deployment pipeline

2. **Phase 2: Automation Services (Weeks 3-4)**
   - Implement office automation services
   - Add system management capabilities
   - Create cross-platform compatibility layer
   - Develop monitoring and health check systems

3. **Phase 3: Enterprise Features (Weeks 5-6)**
   - Implement security and authentication
   - Add multi-tenant support
   - Create comprehensive logging and auditing
   - Develop business intelligence capabilities

4. **Phase 4: Integration and Testing (Weeks 7-8)**
   - Integrate all components
   - Comprehensive testing on multiple platforms
   - Performance optimization and tuning
   - Documentation and deployment guide

### Success Criteria

**Technical Metrics:**
- Support for at least 3 different platforms
- Sub-second response time for 95% of API calls
- 99.9% uptime with proper monitoring
- Zero-downtime deployment capability
- Comprehensive test coverage (>90%)

**Business Metrics:**
- Reduction in manual task execution time
- Improved process reliability and consistency
- Enhanced audit and compliance capabilities
- Reduced operational overhead
- Increased developer productivity

## Module Summary

In this final module, you've mastered:

- **Enterprise Integration Patterns**: Message-based architectures, service-oriented design, and microservices patterns for large-scale automation solutions
- **Cross-Platform Compatibility**: Abstraction layers and platform-specific implementations that enable automation across different operating systems
- **Scalable Architecture Design**: Principles and patterns for building automation solutions that can scale from small teams to enterprise-wide deployments
- **Best Practices**: Industry-standard approaches to security, reliability, performance, and maintainability in enterprise automation systems
- **Complete Framework Development**: Integration of all pywin32 concepts into a comprehensive, production-ready automation framework

## Course Completion

Congratulations! You have completed the Expert Level of the pywin32 Windows Programming course. You now possess:

### Master-Level Skills:
- **Low-Level System Programming**: Direct Windows API access and system-level operations
- **Advanced COM Development**: Custom COM servers and sophisticated automation solutions
- **Expert Debugging**: Advanced troubleshooting and performance optimization techniques
- **Enterprise Architecture**: Large-scale integration patterns and framework development

### Professional Capabilities:
- **Technical Leadership**: Ability to lead complex Windows automation projects
- **Architecture Design**: Skills to design scalable, maintainable automation solutions
- **Problem Solving**: Expert-level debugging and optimization capabilities
- **Innovation**: Capability to create novel solutions for complex automation challenges

### Career Opportunities:
- **Senior Software Engineer**: Windows automation and systems programming
- **Solutions Architect**: Enterprise automation and integration platforms
- **Technical Consultant**: Windows automation expertise for organizations
- **Team Lead**: Leading automation development teams
- **Product Owner**: Automation tools and platform development

You are now equipped to tackle the most challenging Windows automation projects and lead others in mastering these technologies. Continue to apply these skills, contribute to the community, and stay current with evolving technologies in the Windows automation ecosystem.

**Congratulations on achieving Expert-Level pywin32 mastery!**
