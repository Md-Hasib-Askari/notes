# 5.2 COM Server Development

## Learning Objectives
By the end of this module, you will:
- Master the creation of custom COM servers using pywin32
- Understand COM server architecture and threading models
- Implement complex COM interfaces and event handling
- Build scalable and maintainable COM automation solutions
- Apply advanced COM security and deployment patterns

## Module Overview

This module covers expert-level COM (Component Object Model) server development using pywin32. You'll learn to create sophisticated COM servers that can be consumed by various applications, implement custom interfaces, handle events, and build enterprise-grade automation solutions.

COM servers represent one of the most powerful aspects of Windows automation, allowing you to create reusable components that can be accessed from multiple programming languages and applications.

## Key Topics

### 1. COM Server Architecture

#### 1.1 COM Server Types

**In-Process Servers (DLL)**
```python
import pythoncom
import win32com.server.policy
import win32com.server.util
from win32com.server.exception import COMException

class DocumentProcessor:
    """COM server for document processing automation"""
    _com_interfaces_ = ['IDocumentProcessor']
    _public_methods_ = ['ProcessDocument', 'GetStatus', 'SetConfiguration']
    _public_attrs_ = ['Version', 'LastError']
    _readonly_attrs_ = ['Version']
    
    # COM registration information
    _reg_clsid_ = "{12345678-1234-1234-1234-123456789012}"
    _reg_desc_ = "Document Processing COM Server"
    _reg_progid_ = "DocumentProcessor.Application"
    _reg_verprogid_ = "DocumentProcessor.Application.1"
    
    def __init__(self):
        self.version = "1.0.0"
        self.last_error = ""
        self.config = {}
        
    def ProcessDocument(self, document_path, output_path, options=None):
        """Process a document with specified options"""
        try:
            # Document processing logic
            if not os.path.exists(document_path):
                raise COMException("Document not found", scode=0x80070002)
                
            # Processing implementation
            result = self._process_document_internal(document_path, output_path, options)
            return result
            
        except Exception as e:
            self.last_error = str(e)
            raise COMException(f"Processing failed: {e}")
    
    def GetStatus(self):
        """Get current processing status"""
        return {
            'ready': True,
            'last_error': self.last_error,
            'version': self.version
        }
    
    def SetConfiguration(self, config_dict):
        """Set server configuration"""
        self.config.update(config_dict)
        return True

# Registration function
def register():
    import win32com.server.register
    win32com.server.register.UseCommandLine(DocumentProcessor)

if __name__ == '__main__':
    register()
```

**Out-of-Process Servers (EXE)**
```python
import sys
import threading
import time
import pythoncom
import win32com.server.localserver
from win32com.server.exception import COMException

class DataProcessingService:
    """Out-of-process COM server for data processing"""
    _com_interfaces_ = ['IDataProcessor']
    _public_methods_ = ['StartProcessing', 'StopProcessing', 'GetProgress', 'ProcessData']
    _public_attrs_ = ['IsRunning', 'Progress']
    
    _reg_clsid_ = "{87654321-4321-4321-4321-210987654321}"
    _reg_desc_ = "Data Processing Service"
    _reg_progid_ = "DataProcessor.Service"
    _reg_class_spec_ = __name__ + ".DataProcessingService"
    
    def __init__(self):
        self.is_running = False
        self.progress = 0
        self.processing_thread = None
        self.stop_event = threading.Event()
        
    def StartProcessing(self, data_source, configuration):
        """Start data processing operation"""
        if self.is_running:
            raise COMException("Processing already in progress")
            
        self.is_running = True
        self.stop_event.clear()
        
        self.processing_thread = threading.Thread(
            target=self._process_data_worker,
            args=(data_source, configuration)
        )
        self.processing_thread.start()
        return True
    
    def StopProcessing(self):
        """Stop current processing operation"""
        if self.is_running:
            self.stop_event.set()
            if self.processing_thread:
                self.processing_thread.join(timeout=5)
            self.is_running = False
        return True
    
    def GetProgress(self):
        """Get current processing progress"""
        return {
            'percentage': self.progress,
            'is_running': self.is_running,
            'estimated_completion': self._calculate_eta()
        }
    
    def _process_data_worker(self, data_source, configuration):
        """Background processing worker"""
        try:
            # Simulate data processing
            total_items = 100
            for i in range(total_items):
                if self.stop_event.is_set():
                    break
                    
                # Process item
                time.sleep(0.1)  # Simulate work
                self.progress = (i + 1) / total_items * 100
                
            self.is_running = False
            
        except Exception as e:
            self.is_running = False
            raise COMException(f"Processing error: {e}")

class ServerApp:
    """Main server application"""
    
    def __init__(self):
        self.running = True
        
    def run(self):
        """Run the COM server"""
        pythoncom.CoInitialize()
        try:
            # Register class factory
            clsid = DataProcessingService._reg_clsid_
            pythoncom.CoRegisterClassObject(
                clsid,
                win32com.server.factory.Factory(DataProcessingService),
                pythoncom.CLSCTX_LOCAL_SERVER,
                pythoncom.REGCLS_MULTIPLEUSE
            )
            
            print("Data Processing Service started")
            
            # Message loop
            while self.running:
                pythoncom.PumpWaitingMessages()
                time.sleep(0.1)
                
        finally:
            pythoncom.CoUninitialize()

if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1] == '/regserver':
        # Register the server
        import win32com.server.register
        win32com.server.register.UseCommandLine(DataProcessingService)
    else:
        # Run the server
        app = ServerApp()
        app.run()
```

#### 1.2 Threading Models

**Single-Threaded Apartment (STA)**
```python
import pythoncom
import threading
from win32com.server.exception import COMException

class STAComServer:
    """STA COM server implementation"""
    _com_interfaces_ = ['ISTAServer']
    _public_methods_ = ['ProcessRequest', 'GetData']
    
    def __init__(self):
        # Ensure STA initialization
        pythoncom.CoInitialize()
        self.data_store = {}
        
    def ProcessRequest(self, request_data):
        """Process request in STA context"""
        # All operations run on main thread
        thread_id = threading.get_ident()
        print(f"Processing on thread: {thread_id}")
        
        result = self._process_request_sync(request_data)
        return result
    
    def _process_request_sync(self, data):
        """Synchronous request processing"""
        # UI operations, single-threaded components
        return f"Processed: {data}"

class MTAComServer:
    """MTA COM server implementation"""
    _com_interfaces_ = ['IMTAServer']
    _public_methods_ = ['ProcessRequestAsync', 'GetResults']
    
    def __init__(self):
        # MTA initialization
        pythoncom.CoInitializeEx(pythoncom.COINIT_MULTITHREADED)
        self.request_queue = []
        self.results = {}
        self.lock = threading.Lock()
        
    def ProcessRequestAsync(self, request_data):
        """Process request asynchronously"""
        with self.lock:
            request_id = len(self.request_queue)
            self.request_queue.append((request_id, request_data))
            
        # Process in background thread
        thread = threading.Thread(
            target=self._process_async,
            args=(request_id, request_data)
        )
        thread.start()
        
        return request_id
    
    def _process_async(self, request_id, data):
        """Asynchronous processing worker"""
        try:
            # CPU-intensive operations can run in parallel
            result = self._perform_heavy_computation(data)
            
            with self.lock:
                self.results[request_id] = result
                
        except Exception as e:
            with self.lock:
                self.results[request_id] = f"Error: {e}"
```

### 2. Custom Interface Implementation

#### 2.1 Interface Definition Language (IDL)

**Creating Custom Interfaces**
```python
# Custom interface implementation
import pythoncom
from win32com.server.exception import COMException

class IAdvancedProcessor:
    """Custom COM interface definition"""
    _case_insensitive_ = True
    _public_methods_ = [
        'Initialize',
        'Process',
        'GetStatus',
        'Cleanup',
        'Subscribe',
        'Unsubscribe'
    ]
    _public_attrs_ = ['State', 'Configuration']

class AdvancedProcessor:
    """Advanced COM server with custom interface"""
    _com_interfaces_ = [IAdvancedProcessor]
    _reg_clsid_ = "{ABCD1234-5678-9ABC-DEF0-123456789ABC}"
    _reg_desc_ = "Advanced Processing COM Server"
    _reg_progid_ = "AdvancedProcessor.Application"
    
    def __init__(self):
        self.state = "Initialized"
        self.configuration = {}
        self.subscribers = []
        self.processor_engine = None
        
    def Initialize(self, config_path):
        """Initialize processor with configuration"""
        try:
            with open(config_path, 'r') as f:
                import json
                self.configuration = json.load(f)
                
            self.processor_engine = ProcessingEngine(self.configuration)
            self.state = "Ready"
            
            # Notify subscribers
            self._notify_subscribers("Initialized", {"status": "ready"})
            
            return True
            
        except Exception as e:
            raise COMException(f"Initialization failed: {e}")
    
    def Process(self, input_data, options=None):
        """Process data with advanced options"""
        if self.state != "Ready":
            raise COMException("Processor not ready")
            
        try:
            self.state = "Processing"
            self._notify_subscribers("ProcessingStarted", {"data_size": len(input_data)})
            
            result = self.processor_engine.process(input_data, options or {})
            
            self.state = "Ready"
            self._notify_subscribers("ProcessingCompleted", {"result_size": len(result)})
            
            return result
            
        except Exception as e:
            self.state = "Error"
            self._notify_subscribers("ProcessingError", {"error": str(e)})
            raise COMException(f"Processing failed: {e}")
    
    def GetStatus(self):
        """Get detailed processor status"""
        return {
            'state': self.state,
            'configuration': self.configuration,
            'subscribers': len(self.subscribers),
            'engine_info': self.processor_engine.get_info() if self.processor_engine else None
        }
    
    def Subscribe(self, callback_object):
        """Subscribe to processor events"""
        if callback_object not in self.subscribers:
            self.subscribers.append(callback_object)
            return True
        return False
    
    def Unsubscribe(self, callback_object):
        """Unsubscribe from processor events"""
        if callback_object in self.subscribers:
            self.subscribers.remove(callback_object)
            return True
        return False
    
    def _notify_subscribers(self, event_type, event_data):
        """Notify all subscribers of events"""
        for subscriber in self.subscribers[:]:  # Copy to avoid modification during iteration
            try:
                subscriber.OnProcessorEvent(event_type, event_data)
            except:
                # Remove invalid subscribers
                self.subscribers.remove(subscriber)

class ProcessingEngine:
    """Internal processing engine"""
    
    def __init__(self, configuration):
        self.config = configuration
        self.initialized = True
        
    def process(self, data, options):
        """Core processing logic"""
        # Implementation specific to processing requirements
        processed_data = self._apply_transformations(data, options)
        return processed_data
    
    def get_info(self):
        """Get engine information"""
        return {
            'version': '2.0.0',
            'capabilities': ['transform', 'validate', 'export'],
            'performance_metrics': self._get_performance_stats()
        }
    
    def _apply_transformations(self, data, options):
        """Apply data transformations"""
        # Transform data based on configuration and options
        return f"Processed: {data} with options: {options}"
    
    def _get_performance_stats(self):
        """Get performance statistics"""
        return {
            'avg_processing_time': 0.05,
            'throughput': 1000,
            'error_rate': 0.01
        }
```

#### 2.2 Event Handling and Callbacks

**Event-Driven COM Server**
```python
import pythoncom
import win32com.server.util
from win32com.server.exception import COMException
import threading
import queue
import time

class EventDrivenServer:
    """COM server with advanced event handling"""
    _com_interfaces_ = ['IEventServer']
    _public_methods_ = [
        'StartMonitoring',
        'StopMonitoring',
        'AddEventHandler',
        'RemoveEventHandler',
        'TriggerEvent'
    ]
    _public_attrs_ = ['IsMonitoring', 'EventCount']
    
    def __init__(self):
        self.is_monitoring = False
        self.event_count = 0
        self.event_handlers = []
        self.monitor_thread = None
        self.event_queue = queue.Queue()
        self.stop_event = threading.Event()
        
    def StartMonitoring(self, sources):
        """Start monitoring specified sources"""
        if self.is_monitoring:
            return False
            
        self.is_monitoring = True
        self.stop_event.clear()
        
        # Start monitoring thread
        self.monitor_thread = threading.Thread(
            target=self._monitoring_worker,
            args=(sources,)
        )
        self.monitor_thread.start()
        
        # Start event processing thread
        event_thread = threading.Thread(target=self._event_processor)
        event_thread.start()
        
        return True
    
    def StopMonitoring(self):
        """Stop monitoring"""
        if not self.is_monitoring:
            return False
            
        self.stop_event.set()
        self.is_monitoring = False
        
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
            
        return True
    
    def AddEventHandler(self, handler_object):
        """Add event handler"""
        if handler_object not in self.event_handlers:
            self.event_handlers.append(handler_object)
            return True
        return False
    
    def RemoveEventHandler(self, handler_object):
        """Remove event handler"""
        if handler_object in self.event_handlers:
            self.event_handlers.remove(handler_object)
            return True
        return False
    
    def TriggerEvent(self, event_type, event_data):
        """Manually trigger an event"""
        event = {
            'type': event_type,
            'data': event_data,
            'timestamp': time.time(),
            'source': 'manual'
        }
        self.event_queue.put(event)
        return True
    
    def _monitoring_worker(self, sources):
        """Background monitoring worker"""
        while not self.stop_event.is_set():
            try:
                # Monitor various sources
                for source in sources:
                    event_data = self._check_source(source)
                    if event_data:
                        event = {
                            'type': 'source_event',
                            'data': event_data,
                            'timestamp': time.time(),
                            'source': source
                        }
                        self.event_queue.put(event)
                        
                time.sleep(0.1)  # Monitoring interval
                
            except Exception as e:
                error_event = {
                    'type': 'monitoring_error',
                    'data': {'error': str(e)},
                    'timestamp': time.time(),
                    'source': 'monitor'
                }
                self.event_queue.put(error_event)
    
    def _event_processor(self):
        """Process events from queue"""
        while self.is_monitoring or not self.event_queue.empty():
            try:
                event = self.event_queue.get(timeout=1)
                self.event_count += 1
                
                # Notify all handlers
                for handler in self.event_handlers[:]:
                    try:
                        handler.OnEvent(event)
                    except:
                        # Remove invalid handlers
                        self.event_handlers.remove(handler)
                        
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Event processing error: {e}")
    
    def _check_source(self, source):
        """Check a monitoring source for events"""
        # Implementation depends on source type
        # This is a placeholder for actual monitoring logic
        import random
        if random.random() < 0.1:  # 10% chance of event
            return {'source': source, 'value': random.randint(1, 100)}
        return None

# Event handler example
class EventHandler:
    """Example event handler"""
    
    def OnEvent(self, event):
        """Handle incoming events"""
        print(f"Event received: {event['type']} from {event['source']}")
        print(f"Data: {event['data']}")
        print(f"Timestamp: {event['timestamp']}")
```

### 3. Advanced COM Features

#### 3.1 Object Pooling and Lifecycle Management

**Object Pool Implementation**
```python
import threading
import time
from collections import deque
from contextlib import contextmanager

class COMObjectPool:
    """Thread-safe object pool for COM servers"""
    
    def __init__(self, factory_func, min_size=5, max_size=20, max_age=300):
        self.factory_func = factory_func
        self.min_size = min_size
        self.max_size = max_size
        self.max_age = max_age
        
        self.pool = deque()
        self.active_objects = set()
        self.lock = threading.RLock()
        self.stats = {
            'created': 0,
            'reused': 0,
            'expired': 0,
            'peak_active': 0
        }
        
        # Initialize minimum pool size
        self._populate_pool()
        
        # Start cleanup thread
        self.cleanup_thread = threading.Thread(target=self._cleanup_worker, daemon=True)
        self.cleanup_thread.start()
    
    def _populate_pool(self):
        """Populate pool to minimum size"""
        with self.lock:
            while len(self.pool) < self.min_size:
                obj_info = {
                    'object': self.factory_func(),
                    'created': time.time(),
                    'last_used': time.time()
                }
                self.pool.append(obj_info)
                self.stats['created'] += 1
    
    @contextmanager
    def get_object(self):
        """Get object from pool with context manager"""
        obj = self._get_object()
        try:
            yield obj
        finally:
            self._return_object(obj)
    
    def _get_object(self):
        """Get object from pool"""
        with self.lock:
            # Try to get from pool
            if self.pool:
                obj_info = self.pool.popleft()
                obj = obj_info['object']
                self.active_objects.add(obj)
                self.stats['reused'] += 1
                
                # Update peak active count
                active_count = len(self.active_objects)
                if active_count > self.stats['peak_active']:
                    self.stats['peak_active'] = active_count
                
                return obj
            
            # Create new object if under max size
            if len(self.active_objects) < self.max_size:
                obj = self.factory_func()
                self.active_objects.add(obj)
                self.stats['created'] += 1
                return obj
            
            # Pool exhausted
            raise RuntimeError("Object pool exhausted")
    
    def _return_object(self, obj):
        """Return object to pool"""
        with self.lock:
            if obj in self.active_objects:
                self.active_objects.remove(obj)
                
                # Reset object state if needed
                if hasattr(obj, 'reset'):
                    obj.reset()
                
                # Add back to pool if not expired
                obj_info = {
                    'object': obj,
                    'created': getattr(obj, '_created', time.time()),
                    'last_used': time.time()
                }
                
                if len(self.pool) < self.max_size:
                    self.pool.append(obj_info)
                else:
                    # Pool is full, discard object
                    if hasattr(obj, 'cleanup'):
                        obj.cleanup()
    
    def _cleanup_worker(self):
        """Background cleanup of expired objects"""
        while True:
            try:
                current_time = time.time()
                
                with self.lock:
                    # Remove expired objects
                    expired_objects = []
                    remaining_objects = deque()
                    
                    while self.pool:
                        obj_info = self.pool.popleft()
                        age = current_time - obj_info['created']
                        
                        if age > self.max_age:
                            expired_objects.append(obj_info['object'])
                            self.stats['expired'] += 1
                        else:
                            remaining_objects.append(obj_info)
                    
                    self.pool = remaining_objects
                    
                    # Cleanup expired objects
                    for obj in expired_objects:
                        if hasattr(obj, 'cleanup'):
                            obj.cleanup()
                    
                    # Maintain minimum pool size
                    self._populate_pool()
                
                time.sleep(60)  # Cleanup every minute
                
            except Exception as e:
                print(f"Pool cleanup error: {e}")
                time.sleep(60)

class PooledCOMServer:
    """COM server with object pooling support"""
    _com_interfaces_ = ['IPooledServer']
    _public_methods_ = ['ProcessRequest', 'GetStats', 'Reset']
    
    # Class-level pool
    _object_pool = None
    _pool_lock = threading.Lock()
    
    @classmethod
    def get_pool(cls):
        """Get or create object pool"""
        if cls._object_pool is None:
            with cls._pool_lock:
                if cls._object_pool is None:
                    cls._object_pool = COMObjectPool(
                        factory_func=lambda: ProcessingEngine(),
                        min_size=3,
                        max_size=10
                    )
        return cls._object_pool
    
    def __init__(self):
        self._created = time.time()
        self.request_count = 0
        
    def ProcessRequest(self, request_data):
        """Process request using pooled resources"""
        pool = self.get_pool()
        
        with pool.get_object() as engine:
            result = engine.process(request_data)
            self.request_count += 1
            return result
    
    def GetStats(self):
        """Get server and pool statistics"""
        pool = self.get_pool()
        return {
            'server_stats': {
                'created': self._created,
                'request_count': self.request_count
            },
            'pool_stats': pool.stats,
            'pool_size': len(pool.pool),
            'active_objects': len(pool.active_objects)
        }
    
    def reset(self):
        """Reset server state (called by pool)"""
        self.request_count = 0
```

#### 3.2 Security and Authentication

**Secure COM Server Implementation**
```python
import win32security
import win32api
import win32con
import pythoncom
from win32com.server.exception import COMException

class SecureCOMServer:
    """COM server with security features"""
    _com_interfaces_ = ['ISecureServer']
    _public_methods_ = [
        'AuthenticateUser',
        'AuthorizeOperation',
        'ProcessSecureRequest',
        'GetUserContext',
        'AuditOperation'
    ]
    
    def __init__(self):
        self.authenticated_users = {}
        self.audit_log = []
        self.security_context = None
        
    def AuthenticateUser(self, username, credentials):
        """Authenticate user with credentials"""
        try:
            # Get current security context
            token = win32security.OpenProcessToken(
                win32api.GetCurrentProcess(),
                win32security.TOKEN_QUERY
            )
            
            user_sid = win32security.GetTokenInformation(
                token, win32security.TokenUser
            )[0]
            
            # Validate credentials (implementation specific)
            if self._validate_credentials(username, credentials):
                session_token = self._generate_session_token()
                
                self.authenticated_users[session_token] = {
                    'username': username,
                    'sid': user_sid,
                    'authenticated_at': time.time(),
                    'permissions': self._get_user_permissions(username)
                }
                
                self._audit_operation('Authentication', username, 'Success')
                return session_token
            else:
                self._audit_operation('Authentication', username, 'Failed')
                raise COMException("Authentication failed", scode=0x80070005)
                
        except Exception as e:
            self._audit_operation('Authentication', username, f'Error: {e}')
            raise COMException(f"Authentication error: {e}")
    
    def AuthorizeOperation(self, session_token, operation, resource):
        """Authorize user operation"""
        if session_token not in self.authenticated_users:
            raise COMException("Invalid session", scode=0x80070005)
        
        user_info = self.authenticated_users[session_token]
        permissions = user_info['permissions']
        
        # Check if user has required permission
        required_permission = f"{operation}:{resource}"
        
        if self._check_permission(permissions, required_permission):
            self._audit_operation('Authorization', user_info['username'], 
                                f'Granted: {required_permission}')
            return True
        else:
            self._audit_operation('Authorization', user_info['username'], 
                                f'Denied: {required_permission}')
            raise COMException("Access denied", scode=0x80070005)
    
    def ProcessSecureRequest(self, session_token, request_data, operation_type):
        """Process request with security checks"""
        # Authenticate and authorize
        if session_token not in self.authenticated_users:
            raise COMException("Authentication required", scode=0x80070005)
        
        user_info = self.authenticated_users[session_token]
        
        # Check authorization
        self.AuthorizeOperation(session_token, operation_type, 'data_processing')
        
        try:
            # Impersonate user for operation
            with self._impersonate_user(user_info['sid']):
                result = self._process_request_secure(request_data, operation_type)
                
            self._audit_operation('ProcessRequest', user_info['username'], 
                                f'Success: {operation_type}')
            return result
            
        except Exception as e:
            self._audit_operation('ProcessRequest', user_info['username'], 
                                f'Error: {e}')
            raise COMException(f"Processing error: {e}")
    
    def GetUserContext(self, session_token):
        """Get current user context"""
        if session_token not in self.authenticated_users:
            return None
        
        user_info = self.authenticated_users[session_token]
        return {
            'username': user_info['username'],
            'permissions': user_info['permissions'],
            'session_age': time.time() - user_info['authenticated_at']
        }
    
    def AuditOperation(self, session_token, operation, details):
        """Log audit information"""
        if session_token in self.authenticated_users:
            username = self.authenticated_users[session_token]['username']
        else:
            username = 'Anonymous'
        
        self._audit_operation(operation, username, details)
        return True
    
    def _validate_credentials(self, username, credentials):
        """Validate user credentials"""
        # Implementation specific credential validation
        # This could integrate with Active Directory, LDAP, etc.
        try:
            # Example: validate against Windows user
            handle = win32security.LogonUser(
                username,
                '',  # domain
                credentials,
                win32security.LOGON32_LOGON_INTERACTIVE,
                win32security.LOGON32_PROVIDER_DEFAULT
            )
            win32api.CloseHandle(handle)
            return True
        except:
            return False
    
    def _get_user_permissions(self, username):
        """Get user permissions"""
        # Implementation specific permission retrieval
        # This could come from database, Active Directory, etc.
        default_permissions = ['read:data', 'process:basic']
        
        # Example: check if user is in admin group
        try:
            user_groups = self._get_user_groups(username)
            if 'Administrators' in user_groups:
                default_permissions.extend(['write:data', 'admin:system'])
        except:
            pass
        
        return default_permissions
    
    def _check_permission(self, user_permissions, required_permission):
        """Check if user has required permission"""
        # Simple permission check
        if required_permission in user_permissions:
            return True
        
        # Check wildcard permissions
        operation, resource = required_permission.split(':', 1)
        wildcard_permission = f"{operation}:*"
        
        return wildcard_permission in user_permissions
    
    @contextmanager
    def _impersonate_user(self, user_sid):
        """Impersonate user for operation"""
        # Implementation for user impersonation
        # This is a placeholder - actual implementation would use
        # Windows impersonation APIs
        try:
            yield
        finally:
            pass
    
    def _audit_operation(self, operation, username, details):
        """Log audit entry"""
        audit_entry = {
            'timestamp': time.time(),
            'operation': operation,
            'username': username,
            'details': details,
            'client_info': self._get_client_info()
        }
        
        self.audit_log.append(audit_entry)
        
        # Log to Windows Event Log
        try:
            import win32evtlog
            win32evtlog.ReportEvent(
                win32evtlog.RegisterEventSource(None, "SecureCOMServer"),
                win32evtlog.EVENTLOG_INFORMATION_TYPE,
                0,
                1001,
                None,
                [f"{operation}: {username} - {details}"]
            )
        except:
            pass
    
    def _get_client_info(self):
        """Get client connection information"""
        try:
            # Get COM call context
            call_context = pythoncom.CoGetCallContext()
            # Extract client information if available
            return {'call_context': str(call_context)}
        except:
            return {'call_context': 'Unknown'}
    
    def _generate_session_token(self):
        """Generate secure session token"""
        import secrets
        return secrets.token_urlsafe(32)
    
    def _get_user_groups(self, username):
        """Get user group memberships"""
        try:
            import win32net
            user_info = win32net.NetUserGetLocalGroups(None, username)
            return [group['name'] for group in user_info]
        except:
            return []
    
    def _process_request_secure(self, request_data, operation_type):
        """Secure request processing"""
        # Implementation specific processing
        return f"Processed {operation_type}: {len(request_data)} bytes"
```

## Practical Exercises

### Exercise 1: Basic COM Server Creation
Create a simple COM server that provides calculator functionality.

**Requirements:**
- Implement basic arithmetic operations (add, subtract, multiply, divide)
- Include error handling for division by zero
- Support both in-process and out-of-process registration
- Add configuration options for precision and operation mode

### Exercise 2: Event-Driven File Monitor
Build a COM server that monitors file system changes and notifies clients.

**Requirements:**
- Monitor specified directories for file changes
- Support multiple event types (created, modified, deleted, renamed)
- Implement subscriber pattern for event notifications
- Include filtering options for file types and patterns
- Handle large numbers of simultaneous file changes

### Exercise 3: Multi-Threaded Data Processor
Create a COM server that processes data using multiple threads.

**Requirements:**
- Support both synchronous and asynchronous processing
- Implement worker thread pool for parallel processing
- Provide progress reporting and cancellation support
- Include performance metrics and monitoring
- Handle different data formats (JSON, XML, CSV)

### Exercise 4: Secure Document Service
Develop a COM server with authentication and authorization features.

**Requirements:**
- Implement user authentication system
- Support role-based access control
- Include audit logging for all operations
- Provide secure document processing capabilities
- Integration with Windows security APIs

## Best Practices

### 1. Design Principles

**Interface Design**
- Keep interfaces simple and focused
- Use descriptive method and property names
- Provide comprehensive error information
- Support both synchronous and asynchronous operations
- Design for extensibility and versioning

**Threading Considerations**
- Choose appropriate threading model (STA vs MTA)
- Use thread-safe data structures
- Implement proper synchronization mechanisms
- Avoid blocking operations in main thread
- Handle thread lifecycle properly

**Memory Management**
- Implement proper reference counting
- Clean up resources in destructors
- Use context managers for resource management
- Monitor memory usage and leaks
- Implement object pooling for frequently used objects

### 2. Performance Optimization

**Object Lifecycle**
- Use object pooling for expensive-to-create objects
- Implement lazy initialization where appropriate
- Cache frequently accessed data
- Minimize object creation and destruction
- Use weak references to avoid circular dependencies

**Communication Efficiency**
- Batch operations when possible
- Use appropriate data types for marshaling
- Minimize cross-process calls
- Implement compression for large data transfers
- Use asynchronous operations for long-running tasks

### 3. Error Handling and Logging

**Comprehensive Error Handling**
```python
def robust_operation(self, data):
    """Example of robust error handling"""
    try:
        # Validate input
        if not self._validate_input(data):
            raise COMException("Invalid input data", scode=0x80070057)
        
        # Perform operation
        result = self._perform_operation(data)
        
        # Validate result
        if not self._validate_result(result):
            raise COMException("Operation produced invalid result")
        
        return result
        
    except COMException:
        # Re-raise COM exceptions
        raise
    except MemoryError:
        # Handle out of memory
        raise COMException("Insufficient memory", scode=0x8007000E)
    except PermissionError:
        # Handle access denied
        raise COMException("Access denied", scode=0x80070005)
    except Exception as e:
        # Handle unexpected errors
        self._log_error(f"Unexpected error: {e}")
        raise COMException("Internal server error", scode=0x80004005)

def _log_error(self, message):
    """Log error information"""
    import traceback
    import logging
    
    # Configure logging
    logger = logging.getLogger('COMServer')
    logger.error(f"{message}\nTraceback: {traceback.format_exc()}")
    
    # Also log to Windows Event Log
    try:
        import win32evtlog
        win32evtlog.ReportEvent(
            win32evtlog.RegisterEventSource(None, "COMServer"),
            win32evtlog.EVENTLOG_ERROR_TYPE,
            0,
            2001,
            None,
            [message]
        )
    except:
        pass
```

## Common Pitfalls

### 1. Threading Issues
- **Problem**: Using STA objects from MTA threads
- **Solution**: Use proper marshaling or choose appropriate threading model

### 2. Memory Leaks
- **Problem**: Circular references between COM objects
- **Solution**: Use weak references and implement proper cleanup

### 3. Registration Problems
- **Problem**: COM server not properly registered
- **Solution**: Use administrative privileges and verify registry entries

### 4. Performance Issues
- **Problem**: Excessive cross-process calls
- **Solution**: Batch operations and use appropriate data structures

### 5. Security Vulnerabilities
- **Problem**: Insufficient authentication and authorization
- **Solution**: Implement comprehensive security framework

## Capstone Project: Enterprise COM Automation Server

Create a comprehensive COM server that demonstrates all concepts learned in this module.

### Project Requirements

**Core Features:**
- Multi-interface COM server architecture
- Support for both in-process and out-of-process hosting
- Event-driven architecture with subscriber notifications
- Authentication and authorization system
- Object pooling and resource management
- Comprehensive error handling and logging
- Performance monitoring and optimization

**Technical Specifications:**
- Implement at least 3 custom interfaces
- Support minimum 5 different operation types
- Handle concurrent operations from multiple clients
- Include security features (authentication, authorization, auditing)
- Provide administrative interface for configuration
- Support plugin architecture for extensibility

**Testing Requirements:**
- Create comprehensive test suite
- Include performance benchmarks
- Test security features thoroughly
- Verify thread safety and concurrent access
- Test error handling and recovery scenarios

### Implementation Guide

1. **Architecture Design**
   - Define interface contracts
   - Design class hierarchy
   - Plan threading strategy
   - Design security model

2. **Core Implementation**
   - Implement COM server classes
   - Create interface implementations
   - Add event handling system
   - Implement security features

3. **Testing and Optimization**
   - Create test clients
   - Perform load testing
   - Optimize performance bottlenecks
   - Validate security implementation

4. **Documentation and Deployment**
   - Create user documentation
   - Write deployment guide
   - Include troubleshooting information
   - Provide example client code

## Module Summary

In this module, you've mastered:

- **COM Server Architecture**: Understanding of in-process and out-of-process servers, threading models, and interface design
- **Advanced COM Features**: Implementation of custom interfaces, event handling, object pooling, and security features
- **Performance Optimization**: Techniques for optimizing COM server performance and scalability
- **Security Implementation**: Authentication, authorization, and auditing in COM servers
- **Best Practices**: Design principles, error handling, and deployment strategies for enterprise COM solutions

You're now equipped to create sophisticated COM servers that can serve as the backbone of enterprise automation solutions. The skills gained in this module prepare you for architecting and implementing complex Windows automation systems that are secure, scalable, and maintainable.

**Next Module**: [5.3 Advanced Debugging and Troubleshooting](./5.3%20Advanced%20Debugging%20and%20Troubleshooting.md)
